
forth.so:     file format elf64-x86-64


Disassembly of section .text:

0000000000003000 <_start>:
	.align 4

	.globl _start
	.type _start,%function
_start:
	subq $8, %rsp
    3000:	48 83 ec 08          	sub    $0x8,%rsp
	pushq %rcx
    3004:	51                   	push   %rcx
	pushq %rdx
    3005:	52                   	push   %rdx

0:
	lea ImageBase(%rip), %rdi
    3006:	48 8d 3d f3 cf ff ff 	lea    -0x300d(%rip),%rdi        # 0 <ImageBase>
	lea _DYNAMIC(%rip), %rsi
    300d:	48 8d 35 ec 8f 00 00 	lea    0x8fec(%rip),%rsi        # c000 <_DYNAMIC>

	popq %rcx
    3014:	59                   	pop    %rcx
	popq %rdx
    3015:	5a                   	pop    %rdx
	pushq %rcx
    3016:	51                   	push   %rcx
	pushq %rdx
    3017:	52                   	push   %rdx
	call _relocate
    3018:	e8 b3 64 00 00       	call   94d0 <_relocate>

	popq %rdi
    301d:	5f                   	pop    %rdi
	popq %rsi
    301e:	5e                   	pop    %rsi

	call _entry
    301f:	e8 7c 02 00 00       	call   32a0 <_entry>
	addq $8, %rsp
    3024:	48 83 c4 08          	add    $0x8,%rsp

0000000000003028 <.exit>:

.exit:	
  	ret
    3028:	c3                   	ret    
    3029:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003030 <m_loop>:
	return rc;
}

VOID
m_loop()
{        CHAR16   cc;
    3030:	f3 0f 1e fa          	endbr64 
    3034:	53                   	push   %rbx
    3035:	0f 1f 00             	nopl   (%rax)
	do
	{
	   cc=getch ();
    3038:	e8 53 35 00 00       	call   6590 <getch>
    303d:	0f b7 f8             	movzwl %ax,%edi
    3040:	89 fb                	mov    %edi,%ebx
	   putch(cc);
    3042:	e8 99 35 00 00       	call   65e0 <putch>
	   putch('^');
    3047:	bf 5e 00 00 00       	mov    $0x5e,%edi
    304c:	e8 8f 35 00 00       	call   65e0 <putch>
	   putch('&');
    3051:	bf 26 00 00 00       	mov    $0x26,%edi
    3056:	e8 85 35 00 00       	call   65e0 <putch>
	} while(cc!=L' ');
    305b:	66 83 fb 20          	cmp    $0x20,%bx
    305f:	75 d7                	jne    3038 <m_loop+0x8>
}
    3061:	5b                   	pop    %rbx
    3062:	c3                   	ret    
    3063:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    306a:	00 00 00 00 
    306e:	66 90                	xchg   %ax,%ax

0000000000003070 <efi_main>:
VOID
start4th_m();

EFI_STATUS
efi_main (EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
    3070:	f3 0f 1e fa          	endbr64 
    3074:	41 54                	push   %r12
    3076:	55                   	push   %rbp
    3077:	53                   	push   %rbx
    3078:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
	InitializeLib(image, systab);
    307f:	e8 cc 06 00 00       	call   3750 <InitializeLib>
	Print(L"Forth application started\n");
    3084:	31 c0                	xor    %eax,%eax
    3086:	48 8d 3d 73 af 00 00 	lea    0xaf73(%rip),%rdi        # e000 <_DYNAMIC+0x2000>
    308d:	e8 ce 2e 00 00       	call   5f60 <Print>
	rc = uefi_call_wrapper(BS->SetWatchdogTimer, 4, seconds, 0x1ffff,
    3092:	45 31 c9             	xor    %r9d,%r9d
    3095:	45 31 c0             	xor    %r8d,%r8d
    3098:	31 c9                	xor    %ecx,%ecx
    309a:	48 8b 05 1f 8c 00 00 	mov    0x8c1f(%rip),%rax        # bcc0 <BS>
    30a1:	ba ff ff 01 00       	mov    $0x1ffff,%edx
    30a6:	ff 90 00 01 00 00    	call   *0x100(%rax)
	if (EFI_ERROR(rc)) {
    30ac:	48 85 c0             	test   %rax,%rax
    30af:	78 5b                	js     310c <efi_main+0x9c>
    30b1:	4c 8d 25 cc af 00 00 	lea    0xafcc(%rip),%r12        # e084 <_DYNAMIC+0x2084>
    30b8:	48 8d 2d d5 af 00 00 	lea    0xafd5(%rip),%rbp        # e094 <_DYNAMIC+0x2094>
    30bf:	90                   	nop
	SetWatchdog(0);
//	WaitForSingleEvent(ST->ConIn->WaitForKey, 0);
//	uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, L"\n\n");
	for(;;)
	{
		Print(L"C_loop\n");
    30c0:	4c 89 e7             	mov    %r12,%rdi
    30c3:	31 c0                	xor    %eax,%eax
    30c5:	e8 96 2e 00 00       	call   5f60 <Print>
m_loop()
    30ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	   cc=getch ();
    30d0:	e8 bb 34 00 00       	call   6590 <getch>
    30d5:	0f b7 f8             	movzwl %ax,%edi
    30d8:	89 fb                	mov    %edi,%ebx
	   putch(cc);
    30da:	e8 01 35 00 00       	call   65e0 <putch>
	   putch('^');
    30df:	bf 5e 00 00 00       	mov    $0x5e,%edi
    30e4:	e8 f7 34 00 00       	call   65e0 <putch>
	   putch('&');
    30e9:	bf 26 00 00 00       	mov    $0x26,%edi
    30ee:	e8 ed 34 00 00       	call   65e0 <putch>
	} while(cc!=L' ');
    30f3:	66 83 fb 20          	cmp    $0x20,%bx
    30f7:	75 d7                	jne    30d0 <efi_main+0x60>
		m_loop();
		Print(L"Forth\n");
    30f9:	48 89 ef             	mov    %rbp,%rdi
    30fc:	31 c0                	xor    %eax,%eax
    30fe:	e8 5d 2e 00 00       	call   5f60 <Print>
		start4th_m();
    3103:	31 c0                	xor    %eax,%eax
    3105:	e8 2e 00 00 00       	call   3138 <start4th_m>
	for(;;)
    310a:	eb b4                	jmp    30c0 <efi_main+0x50>
		StatusToString(Buffer, rc);
    310c:	48 8d 6c 24 20       	lea    0x20(%rsp),%rbp
    3111:	49 89 c4             	mov    %rax,%r12
    3114:	48 89 c6             	mov    %rax,%rsi
    3117:	48 89 ef             	mov    %rbp,%rdi
    311a:	e8 81 02 00 00       	call   33a0 <StatusToString>
		Print(L"Bad response from QueryMode: %s (%d)\n", Buffer, rc);
    311f:	4c 89 e2             	mov    %r12,%rdx
    3122:	48 89 ee             	mov    %rbp,%rsi
    3125:	31 c0                	xor    %eax,%eax
    3127:	48 8d 3d 0a af 00 00 	lea    0xaf0a(%rip),%rdi        # e038 <_DYNAMIC+0x2038>
    312e:	e8 2d 2e 00 00       	call   5f60 <Print>
    3133:	e9 79 ff ff ff       	jmp    30b1 <efi_main+0x41>

0000000000003138 <start4th_m>:
	.text
	.align 4

	.globl start4th_m
start4th_m:
	endbr64 
    3138:	f3 0f 1e fa          	endbr64 
	push   %rbx
    313c:	53                   	push   %rbx
	sub    $0x10,%rsp
    313d:	48 83 ec 10          	sub    $0x10,%rsp
	lea    0xe(%rsp),%rbx
    3141:	48 8d 5c 24 0e       	lea    0xe(%rsp),%rbx
	xchg   %ax,%ax
    3146:	66 90                	xchg   %ax,%ax
0:	call   getch
    3148:	e8 43 34 00 00       	call   6590 <getch>
	mov    %rbx,%rdi
    314d:	48 89 df             	mov    %rbx,%rdi
	mov    %ax,0xe(%rsp)
    3150:	66 89 44 24 0e       	mov    %ax,0xe(%rsp)
	call   Output
    3155:	e8 16 00 00 00       	call   3170 <Output>
	cmpw   $0x20,0xe(%rsp)
    315a:	66 83 7c 24 0e 20    	cmpw   $0x20,0xe(%rsp)
	jne    0b
    3160:	75 e6                	jne    3148 <start4th_m+0x10>
	add    $0x10,%rsp
    3162:	48 83 c4 10          	add    $0x10,%rsp
	pop    %rbx
    3166:	5b                   	pop    %rbx
	ret    
    3167:	c3                   	ret    
    3168:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    316f:	00 

0000000000003170 <Output>:
VOID
Output (
    IN CHAR16   *Str
    )
// Write a string to the console at the current cursor location
{
    3170:	f3 0f 1e fa          	endbr64 
    3174:	48 83 ec 28          	sub    $0x28,%rsp
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Str);
    3178:	48 8b 05 49 8b 00 00 	mov    0x8b49(%rip),%rax        # bcc8 <ST>
{
    317f:	48 89 fa             	mov    %rdi,%rdx
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Str);
    3182:	48 8b 40 40          	mov    0x40(%rax),%rax
    3186:	48 89 c1             	mov    %rax,%rcx
    3189:	ff 50 08             	call   *0x8(%rax)
}
    318c:	48 83 c4 28          	add    $0x28,%rsp
    3190:	c3                   	ret    
    3191:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3198:	00 00 00 00 
    319c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000031a0 <IInput>:
    IN CHAR16                           *Prompt OPTIONAL,
    OUT CHAR16                          *InStr,
    IN UINTN                            StrLen
    )
// Input a string at the current cursor location, for StrLen
{
    31a0:	f3 0f 1e fa          	endbr64 
    31a4:	41 57                	push   %r15
    31a6:	49 89 f7             	mov    %rsi,%r15
    31a9:	41 56                	push   %r14
    31ab:	4d 89 c6             	mov    %r8,%r14
    31ae:	41 55                	push   %r13
    31b0:	49 89 cd             	mov    %rcx,%r13
    31b3:	41 54                	push   %r12
    31b5:	49 89 fc             	mov    %rdi,%r12
    31b8:	55                   	push   %rbp
    31b9:	53                   	push   %rbx
    31ba:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_INPUT_KEY                   Key;
    EFI_STATUS                      Status;
    UINTN                           Len;

    if (Prompt) {
    31be:	48 85 d2             	test   %rdx,%rdx
    31c1:	74 06                	je     31c9 <IInput+0x29>
        ConOut->OutputString (ConOut, Prompt);
    31c3:	48 89 f9             	mov    %rdi,%rcx
    31c6:	ff 57 08             	call   *0x8(%rdi)
{
    31c9:	31 db                	xor    %ebx,%ebx
    31cb:	48 8d 6c 24 2c       	lea    0x2c(%rsp),%rbp
    }

    Len = 0;
    for (; ;) {
        WaitForSingleEvent (ConIn->WaitForKey, 0);
    31d0:	49 8b 7f 10          	mov    0x10(%r15),%rdi
    31d4:	31 f6                	xor    %esi,%esi
    31d6:	e8 a5 02 00 00       	call   3480 <WaitForSingleEvent>

        Status = uefi_call_wrapper(ConIn->ReadKeyStroke, 2, ConIn, &Key);
    31db:	48 89 ea             	mov    %rbp,%rdx
    31de:	4c 89 f9             	mov    %r15,%rcx
    31e1:	41 ff 57 08          	call   *0x8(%r15)
        if (EFI_ERROR(Status)) {
    31e5:	48 85 c0             	test   %rax,%rax
    31e8:	78 6e                	js     3258 <IInput+0xb8>
            DEBUG((D_ERROR, "Input: error return from ReadKey %x\n", Status));
            break;
        }

        if (Key.UnicodeChar == '\n' ||
    31ea:	0f b7 44 24 2e       	movzwl 0x2e(%rsp),%eax
    31ef:	66 83 f8 0a          	cmp    $0xa,%ax
    31f3:	74 63                	je     3258 <IInput+0xb8>
    31f5:	66 83 f8 0d          	cmp    $0xd,%ax
    31f9:	74 5d                	je     3258 <IInput+0xb8>
            Key.UnicodeChar == '\r') {
            break;
        }
        
        if (Key.UnicodeChar == '\b') {
    31fb:	66 83 f8 08          	cmp    $0x8,%ax
    31ff:	74 37                	je     3238 <IInput+0x98>
                Len -= 1;
            }
            continue;
        }

        if (Key.UnicodeChar >= ' ') {
    3201:	66 83 f8 1f          	cmp    $0x1f,%ax
    3205:	76 c9                	jbe    31d0 <IInput+0x30>
            if (Len < StrLen-1) {
    3207:	49 8d 56 ff          	lea    -0x1(%r14),%rdx
    320b:	48 39 da             	cmp    %rbx,%rdx
    320e:	76 c0                	jbe    31d0 <IInput+0x30>
                InStr[Len] = Key.UnicodeChar;
    3210:	48 8d 0c 1b          	lea    (%rbx,%rbx,1),%rcx

                InStr[Len+1] = 0;
    3214:	31 f6                	xor    %esi,%esi
    3216:	48 83 c3 01          	add    $0x1,%rbx
                InStr[Len] = Key.UnicodeChar;
    321a:	49 8d 54 0d 00       	lea    0x0(%r13,%rcx,1),%rdx
    321f:	66 89 02             	mov    %ax,(%rdx)
                InStr[Len+1] = 0;
    3222:	66 41 89 74 0d 02    	mov    %si,0x2(%r13,%rcx,1)
                uefi_call_wrapper(ConOut->OutputString, 2, ConOut, &InStr[Len]);
    3228:	4c 89 e1             	mov    %r12,%rcx
    322b:	41 ff 54 24 08       	call   *0x8(%r12)

                Len += 1;
    3230:	eb 9e                	jmp    31d0 <IInput+0x30>
    3232:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            if (Len) {
    3238:	48 85 db             	test   %rbx,%rbx
    323b:	74 93                	je     31d0 <IInput+0x30>
                uefi_call_wrapper(ConOut->OutputString, 2, ConOut, L"\b \b");
    323d:	48 8d 15 5e ae 00 00 	lea    0xae5e(%rip),%rdx        # e0a2 <_DYNAMIC+0x20a2>
    3244:	4c 89 e1             	mov    %r12,%rcx
                Len -= 1;
    3247:	48 83 eb 01          	sub    $0x1,%rbx
                uefi_call_wrapper(ConOut->OutputString, 2, ConOut, L"\b \b");
    324b:	41 ff 54 24 08       	call   *0x8(%r12)
                Len -= 1;
    3250:	e9 7b ff ff ff       	jmp    31d0 <IInput+0x30>
    3255:	0f 1f 00             	nopl   (%rax)
            }
            continue;
        }
    }

    InStr[Len] = 0;
    3258:	31 c0                	xor    %eax,%eax
    325a:	66 41 89 44 5d 00    	mov    %ax,0x0(%r13,%rbx,2)
}
    3260:	48 83 c4 38          	add    $0x38,%rsp
    3264:	5b                   	pop    %rbx
    3265:	5d                   	pop    %rbp
    3266:	41 5c                	pop    %r12
    3268:	41 5d                	pop    %r13
    326a:	41 5e                	pop    %r14
    326c:	41 5f                	pop    %r15
    326e:	c3                   	ret    
    326f:	90                   	nop

0000000000003270 <Input>:
{
    3270:	f3 0f 1e fa          	endbr64 
        ST->ConIn,
    3274:	48 8b 05 4d 8a 00 00 	mov    0x8a4d(%rip),%rax        # bcc8 <ST>
{
    327b:	49 89 f9             	mov    %rdi,%r9
    327e:	48 89 f1             	mov    %rsi,%rcx
    3281:	49 89 d0             	mov    %rdx,%r8
    IInput (
    3284:	4c 89 ca             	mov    %r9,%rdx
    3287:	48 8b 70 30          	mov    0x30(%rax),%rsi
    328b:	48 8b 78 40          	mov    0x40(%rax),%rdi
    328f:	e9 0c ff ff ff       	jmp    31a0 <IInput>
    3294:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    329b:	00 00 00 
    329e:	66 90                	xchg   %ax,%ax

00000000000032a0 <_entry>:
}

extern EFI_STATUS efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab);

EFI_STATUS _entry(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
    32a0:	f3 0f 1e fa          	endbr64 
    32a4:	41 56                	push   %r14
	size_t __init_array_length = __init_array_end - __init_array_start;
    32a6:	4c 8d 35 03 8a 00 00 	lea    0x8a03(%rip),%r14        # bcb0 <NullGuid>
{
    32ad:	41 55                	push   %r13
    32af:	49 89 f5             	mov    %rsi,%r13
    32b2:	41 54                	push   %r12
    32b4:	49 89 fc             	mov    %rdi,%r12
    32b7:	55                   	push   %rbp
	size_t __init_array_length = __init_array_end - __init_array_start;
    32b8:	48 8d 2d f1 89 00 00 	lea    0x89f1(%rip),%rbp        # bcb0 <NullGuid>
{
    32bf:	53                   	push   %rbx
	size_t __init_array_length = __init_array_end - __init_array_start;
    32c0:	4c 29 f5             	sub    %r14,%rbp
	EFI_STATUS status;
	InitializeLib(image, systab);
    32c3:	e8 88 04 00 00       	call   3750 <InitializeLib>
	for (size_t i = 0; i < __init_array_length; i++) {
    32c8:	48 c1 fd 03          	sar    $0x3,%rbp
    32cc:	74 16                	je     32e4 <_entry+0x44>
    32ce:	31 db                	xor    %ebx,%ebx
		funcp func = __init_array_start[i];
    32d0:	49 8b 04 de          	mov    (%r14,%rbx,8),%rax
		if (func != NULL)
    32d4:	48 85 c0             	test   %rax,%rax
    32d7:	74 02                	je     32db <_entry+0x3b>
			func();
    32d9:	ff d0                	call   *%rax
	for (size_t i = 0; i < __init_array_length; i++) {
    32db:	48 83 c3 01          	add    $0x1,%rbx
    32df:	48 39 dd             	cmp    %rbx,%rbp
    32e2:	75 ec                	jne    32d0 <_entry+0x30>
	size_t __CTOR_length = __CTOR_END__ - __CTOR_LIST__;
    32e4:	48 8d 1d c5 89 00 00 	lea    0x89c5(%rip),%rbx        # bcb0 <NullGuid>
    32eb:	48 8d 05 be 89 00 00 	lea    0x89be(%rip),%rax        # bcb0 <NullGuid>
	for (size_t i = 0; i < __CTOR_length; i++) {
    32f2:	31 ed                	xor    %ebp,%ebp
	size_t __CTOR_length = __CTOR_END__ - __CTOR_LIST__;
    32f4:	49 89 de             	mov    %rbx,%r14
    32f7:	49 29 c6             	sub    %rax,%r14
	for (size_t i = 0; i < __CTOR_length; i++) {
    32fa:	49 c1 fe 03          	sar    $0x3,%r14
    32fe:	74 18                	je     3318 <_entry+0x78>
		funcp func = __CTOR_LIST__[current];
    3300:	48 8b 43 f8          	mov    -0x8(%rbx),%rax
		if (func != NULL)
    3304:	48 85 c0             	test   %rax,%rax
    3307:	74 02                	je     330b <_entry+0x6b>
			func();
    3309:	ff d0                	call   *%rax
	for (size_t i = 0; i < __CTOR_length; i++) {
    330b:	48 83 c5 01          	add    $0x1,%rbp
    330f:	48 83 eb 08          	sub    $0x8,%rbx
    3313:	49 39 ee             	cmp    %rbp,%r14
    3316:	75 e8                	jne    3300 <_entry+0x60>

	ctors();
	status = efi_main(image, systab);
    3318:	4c 89 ee             	mov    %r13,%rsi
	size_t __DTOR_length = __DTOR_END__ - __DTOR_LIST__;
    331b:	48 8d 2d 8e 89 00 00 	lea    0x898e(%rip),%rbp        # bcb0 <NullGuid>
	status = efi_main(image, systab);
    3322:	4c 89 e7             	mov    %r12,%rdi
	for (size_t i = 0; i < __DTOR_length; i++) {
    3325:	31 db                	xor    %ebx,%ebx
	status = efi_main(image, systab);
    3327:	e8 44 fd ff ff       	call   3070 <efi_main>
	size_t __DTOR_length = __DTOR_END__ - __DTOR_LIST__;
    332c:	4c 8d 2d 7d 89 00 00 	lea    0x897d(%rip),%r13        # bcb0 <NullGuid>
    3333:	4c 29 ed             	sub    %r13,%rbp
	status = efi_main(image, systab);
    3336:	49 89 c4             	mov    %rax,%r12
	for (size_t i = 0; i < __DTOR_length; i++) {
    3339:	48 c1 fd 03          	sar    $0x3,%rbp
    333d:	74 16                	je     3355 <_entry+0xb5>
    333f:	90                   	nop
		funcp func = __DTOR_LIST__[i];
    3340:	49 8b 44 dd 00       	mov    0x0(%r13,%rbx,8),%rax
		if (func != NULL)
    3345:	48 85 c0             	test   %rax,%rax
    3348:	74 02                	je     334c <_entry+0xac>
			func();
    334a:	ff d0                	call   *%rax
	for (size_t i = 0; i < __DTOR_length; i++) {
    334c:	48 83 c3 01          	add    $0x1,%rbx
    3350:	48 39 dd             	cmp    %rbx,%rbp
    3353:	75 eb                	jne    3340 <_entry+0xa0>
	size_t __fini_array_length = __fini_array_end - __fini_array_start;
    3355:	48 8d 1d 54 89 00 00 	lea    0x8954(%rip),%rbx        # bcb0 <NullGuid>
    335c:	48 8d 05 4d 89 00 00 	lea    0x894d(%rip),%rax        # bcb0 <NullGuid>
	for (size_t i = 0; i < __fini_array_length; i++) {
    3363:	31 ed                	xor    %ebp,%ebp
	size_t __fini_array_length = __fini_array_end - __fini_array_start;
    3365:	49 89 dd             	mov    %rbx,%r13
    3368:	49 29 c5             	sub    %rax,%r13
	for (size_t i = 0; i < __fini_array_length; i++) {
    336b:	49 c1 fd 03          	sar    $0x3,%r13
    336f:	74 1f                	je     3390 <_entry+0xf0>
    3371:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		funcp func = __fini_array_start[current];
    3378:	48 8b 43 f8          	mov    -0x8(%rbx),%rax
		if (func != NULL)
    337c:	48 85 c0             	test   %rax,%rax
    337f:	74 02                	je     3383 <_entry+0xe3>
			func();
    3381:	ff d0                	call   *%rax
	for (size_t i = 0; i < __fini_array_length; i++) {
    3383:	48 83 c5 01          	add    $0x1,%rbp
    3387:	48 83 eb 08          	sub    $0x8,%rbx
    338b:	49 39 ed             	cmp    %rbp,%r13
    338e:	75 e8                	jne    3378 <_entry+0xd8>
	dtors();

	return status;
}
    3390:	5b                   	pop    %rbx
    3391:	4c 89 e0             	mov    %r12,%rax
    3394:	5d                   	pop    %rbp
    3395:	41 5c                	pop    %r12
    3397:	41 5d                	pop    %r13
    3399:	41 5e                	pop    %r14
    339b:	c3                   	ret    
    339c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000033a0 <StatusToString>:
VOID
StatusToString (
    OUT CHAR16          *Buffer,
    IN EFI_STATUS       Status
    )
{
    33a0:	f3 0f 1e fa          	endbr64 
    33a4:	48 89 f1             	mov    %rsi,%rcx
    UINTN           Index;

    for (Index = 0; ErrorCodeTable[Index].Desc; Index +=1) {
    33a7:	48 8b 35 7a 81 00 00 	mov    0x817a(%rip),%rsi        # b528 <ErrorCodeTable+0x8>
    33ae:	48 85 f6             	test   %rsi,%rsi
    33b1:	74 2d                	je     33e0 <StatusToString+0x40>
    33b3:	48 8d 05 66 81 00 00 	lea    0x8166(%rip),%rax        # b520 <ErrorCodeTable>
    33ba:	eb 11                	jmp    33cd <StatusToString+0x2d>
    33bc:	0f 1f 40 00          	nopl   0x0(%rax)
    33c0:	48 8b 70 18          	mov    0x18(%rax),%rsi
    33c4:	48 83 c0 10          	add    $0x10,%rax
    33c8:	48 85 f6             	test   %rsi,%rsi
    33cb:	74 13                	je     33e0 <StatusToString+0x40>
        if (ErrorCodeTable[Index].Code == Status) {
    33cd:	48 39 08             	cmp    %rcx,(%rax)
    33d0:	75 ee                	jne    33c0 <StatusToString+0x20>
	    StrCpy (Buffer, ErrorCodeTable[Index].Desc);
    33d2:	e9 99 33 00 00       	jmp    6770 <StrCpy>
    33d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    33de:	00 00 
            return;
        }
    }

    UnicodeSPrint (Buffer, 0, L"%X", Status);
    33e0:	48 8d 15 c9 ac 00 00 	lea    0xacc9(%rip),%rdx        # e0b0 <_DYNAMIC+0x20b0>
    33e7:	31 f6                	xor    %esi,%esi
    33e9:	31 c0                	xor    %eax,%eax
    33eb:	e9 f0 28 00 00       	jmp    5ce0 <UnicodeSPrint>

00000000000033f0 <LibCreateProtocolNotifyEvent>:
    IN EFI_TPL              NotifyTpl,
    IN EFI_EVENT_NOTIFY     NotifyFunction,
    IN VOID                 *NotifyContext,
    OUT VOID                *Registration
    )
{
    33f0:	f3 0f 1e fa          	endbr64 
    33f4:	41 54                	push   %r12
    33f6:	49 89 c9             	mov    %rcx,%r9
    33f9:	49 89 fc             	mov    %rdi,%r12

    //
    // Create the event
    //

    Status = uefi_call_wrapper(
    33fc:	b9 00 02 00 00       	mov    $0x200,%ecx
{
    3401:	53                   	push   %rbx
    3402:	4c 89 c3             	mov    %r8,%rbx
    Status = uefi_call_wrapper(
    3405:	49 89 d0             	mov    %rdx,%r8
    3408:	48 89 f2             	mov    %rsi,%rdx
{
    340b:	48 83 ec 48          	sub    $0x48,%rsp
    Status = uefi_call_wrapper(
    340f:	48 8d 44 24 38       	lea    0x38(%rsp),%rax
    3414:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    3419:	48 8b 05 a0 88 00 00 	mov    0x88a0(%rip),%rax        # bcc0 <BS>
    3420:	ff 50 50             	call   *0x50(%rax)
		    NotifyTpl,
		    NotifyFunction,
		    NotifyContext,
		    &Event
		    );
    if ( EFI_ERROR( Status ) ) return NULL ;
    3423:	48 85 c0             	test   %rax,%rax
    3426:	78 40                	js     3468 <LibCreateProtocolNotifyEvent+0x78>

    //
    // Register for protocol notifactions on this event
    //

    Status = uefi_call_wrapper(
    3428:	48 8b 05 91 88 00 00 	mov    0x8891(%rip),%rax        # bcc0 <BS>
    342f:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    3434:	49 89 d8             	mov    %rbx,%r8
    3437:	4c 89 e1             	mov    %r12,%rcx
    343a:	ff 90 a8 00 00 00    	call   *0xa8(%rax)
			3,
                    ProtocolGuid,
                    Event,
                    Registration
                    );
    if ( EFI_ERROR( Status ) ) return NULL ;
    3440:	48 85 c0             	test   %rax,%rax
    3443:	78 23                	js     3468 <LibCreateProtocolNotifyEvent+0x78>
    //
    // Kick the event so we will perform an initial pass of
    // current installed drivers
    //

    uefi_call_wrapper(BS->SignalEvent, 1, Event);
    3445:	48 8b 05 74 88 00 00 	mov    0x8874(%rip),%rax        # bcc0 <BS>
    344c:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    3451:	ff 50 68             	call   *0x68(%rax)
    return Event;
    3454:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
}
    3459:	48 83 c4 48          	add    $0x48,%rsp
    345d:	5b                   	pop    %rbx
    345e:	41 5c                	pop    %r12
    3460:	c3                   	ret    
    3461:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    3468:	48 83 c4 48          	add    $0x48,%rsp
    if ( EFI_ERROR( Status ) ) return NULL ;
    346c:	31 c0                	xor    %eax,%eax
}
    346e:	5b                   	pop    %rbx
    346f:	41 5c                	pop    %r12
    3471:	c3                   	ret    
    3472:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3479:	00 00 00 00 
    347d:	0f 1f 00             	nopl   (%rax)

0000000000003480 <WaitForSingleEvent>:
EFI_STATUS
WaitForSingleEvent (
    IN EFI_EVENT        Event,
    IN UINT64           Timeout OPTIONAL
    )
{
    3480:	f3 0f 1e fa          	endbr64 
    3484:	41 54                	push   %r12
    3486:	53                   	push   %rbx
    3487:	48 83 ec 68          	sub    $0x68,%rsp
    if (Timeout) {
        //
        // Create a timer event
        //

        Status = uefi_call_wrapper(BS->CreateEvent, 5, EVT_TIMER, 0, NULL, NULL, &TimerEvent);
    348b:	48 8b 05 2e 88 00 00 	mov    0x882e(%rip),%rax        # bcc0 <BS>
{
    3492:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    if (Timeout) {
    3497:	48 85 f6             	test   %rsi,%rsi
    349a:	0f 84 a0 00 00 00    	je     3540 <WaitForSingleEvent+0xc0>
        Status = uefi_call_wrapper(BS->CreateEvent, 5, EVT_TIMER, 0, NULL, NULL, &TimerEvent);
    34a0:	48 8d 54 24 48       	lea    0x48(%rsp),%rdx
    34a5:	48 89 f3             	mov    %rsi,%rbx
    34a8:	45 31 c9             	xor    %r9d,%r9d
    34ab:	45 31 c0             	xor    %r8d,%r8d
    34ae:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    34b3:	b9 00 00 00 80       	mov    $0x80000000,%ecx
    34b8:	31 d2                	xor    %edx,%edx
    34ba:	ff 50 50             	call   *0x50(%rax)
    34bd:	49 89 c4             	mov    %rax,%r12
        if (!EFI_ERROR(Status)) {
    34c0:	48 85 c0             	test   %rax,%rax
    34c3:	78 6f                	js     3534 <WaitForSingleEvent+0xb4>

            //
            // Set the timer event
            //

            uefi_call_wrapper(BS->SetTimer, 3, TimerEvent, TimerRelative, Timeout);
    34c5:	48 8b 05 f4 87 00 00 	mov    0x87f4(%rip),%rax        # bcc0 <BS>
    34cc:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    34d1:	49 89 d8             	mov    %rbx,%r8
    34d4:	ba 02 00 00 00       	mov    $0x2,%edx
    34d9:	ff 50 58             	call   *0x58(%rax)

            //
            // Wait for the original event or the timer
            //

            WaitList[0] = Event;
    34dc:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
            WaitList[1] = TimerEvent;
            Status = uefi_call_wrapper(BS->WaitForEvent, 3, 2, WaitList, &Index);
    34e1:	b9 02 00 00 00       	mov    $0x2,%ecx
    34e6:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
    34eb:	4c 8d 44 24 40       	lea    0x40(%rsp),%r8
            WaitList[0] = Event;
    34f0:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
            WaitList[1] = TimerEvent;
    34f5:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    34fa:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
            Status = uefi_call_wrapper(BS->WaitForEvent, 3, 2, WaitList, &Index);
    34ff:	48 8b 05 ba 87 00 00 	mov    0x87ba(%rip),%rax        # bcc0 <BS>
    3506:	ff 50 60             	call   *0x60(%rax)
            uefi_call_wrapper(BS->CloseEvent, 1, TimerEvent);
    3509:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
            Status = uefi_call_wrapper(BS->WaitForEvent, 3, 2, WaitList, &Index);
    350e:	49 89 c4             	mov    %rax,%r12
            uefi_call_wrapper(BS->CloseEvent, 1, TimerEvent);
    3511:	48 8b 05 a8 87 00 00 	mov    0x87a8(%rip),%rax        # bcc0 <BS>
    3518:	ff 50 70             	call   *0x70(%rax)

            //
            // If the timer expired, change the return to timed out
            //

            if (!EFI_ERROR(Status)  &&  Index == 1) {
    351b:	4d 85 e4             	test   %r12,%r12
    351e:	78 14                	js     3534 <WaitForSingleEvent+0xb4>
                Status = EFI_TIMEOUT;
    3520:	48 b8 12 00 00 00 00 	movabs $0x8000000000000012,%rax
    3527:	00 00 80 
    352a:	48 83 7c 24 40 01    	cmpq   $0x1,0x40(%rsp)
    3530:	4c 0f 44 e0          	cmove  %rax,%r12
        ASSERT (!EFI_ERROR(Status));
        ASSERT (Index == 0);
    }

    return Status;
}
    3534:	48 83 c4 68          	add    $0x68,%rsp
    3538:	4c 89 e0             	mov    %r12,%rax
    353b:	5b                   	pop    %rbx
    353c:	41 5c                	pop    %r12
    353e:	c3                   	ret    
    353f:	90                   	nop
        Status = uefi_call_wrapper(BS->WaitForEvent, 3, 1, &Event, &Index);
    3540:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
    3545:	4c 8d 44 24 40       	lea    0x40(%rsp),%r8
    354a:	b9 01 00 00 00       	mov    $0x1,%ecx
    354f:	ff 50 60             	call   *0x60(%rax)
}
    3552:	48 83 c4 68          	add    $0x68,%rsp
        Status = uefi_call_wrapper(BS->WaitForEvent, 3, 1, &Event, &Index);
    3556:	49 89 c4             	mov    %rax,%r12
}
    3559:	5b                   	pop    %rbx
    355a:	4c 89 e0             	mov    %r12,%rax
    355d:	41 5c                	pop    %r12
    355f:	c3                   	ret    

0000000000003560 <WaitForEventWithTimeout>:
    IN  UINTN           Column,
    IN  CHAR16          *String,
    IN  EFI_INPUT_KEY   TimeoutKey,
    OUT EFI_INPUT_KEY   *Key
    )
{
    3560:	f3 0f 1e fa          	endbr64 
    3564:	41 57                	push   %r15
    3566:	41 56                	push   %r14
    3568:	49 89 fe             	mov    %rdi,%r14
    356b:	41 55                	push   %r13
    356d:	49 89 d5             	mov    %rdx,%r13
    3570:	41 54                	push   %r12
    3572:	49 89 cc             	mov    %rcx,%r12
    3575:	55                   	push   %rbp
    3576:	4c 89 c5             	mov    %r8,%rbp
    3579:	53                   	push   %rbx
    357a:	48 89 f3             	mov    %rsi,%rbx
    357d:	48 83 ec 38          	sub    $0x38,%rsp
    3581:	44 89 4c 24 2c       	mov    %r9d,0x2c(%rsp)
    3586:	4c 8b 7c 24 70       	mov    0x70(%rsp),%r15
    358b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    EFI_STATUS      Status;

    do {
        PrintAt (Column, Row, String, Timeout);
    3590:	4c 89 ee             	mov    %r13,%rsi
    3593:	4c 89 e7             	mov    %r12,%rdi
    3596:	31 c0                	xor    %eax,%eax
    3598:	48 89 d9             	mov    %rbx,%rcx
    359b:	48 89 ea             	mov    %rbp,%rdx
    359e:	e8 ad 2a 00 00       	call   6050 <PrintAt>
        Status = WaitForSingleEvent (Event, 10000000);
    35a3:	be 80 96 98 00       	mov    $0x989680,%esi
    35a8:	4c 89 f7             	mov    %r14,%rdi
    35ab:	e8 d0 fe ff ff       	call   3480 <WaitForSingleEvent>
        if (Status == EFI_SUCCESS) {
    35b0:	48 85 c0             	test   %rax,%rax
    35b3:	75 19                	jne    35ce <WaitForEventWithTimeout+0x6e>
            if (!EFI_ERROR(uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, Key))) {
    35b5:	48 8b 05 0c 87 00 00 	mov    0x870c(%rip),%rax        # bcc8 <ST>
    35bc:	4c 89 fa             	mov    %r15,%rdx
    35bf:	48 8b 40 30          	mov    0x30(%rax),%rax
    35c3:	48 89 c1             	mov    %rax,%rcx
    35c6:	ff 50 08             	call   *0x8(%rax)
    35c9:	48 85 c0             	test   %rax,%rax
    35cc:	79 18                	jns    35e6 <WaitForEventWithTimeout+0x86>
                return;
            }
        }
    } while (Timeout > 0);
    35ce:	48 85 db             	test   %rbx,%rbx
    35d1:	75 bd                	jne    3590 <WaitForEventWithTimeout+0x30>
    CopyMem(Key, &TimeoutKey, sizeof(EFI_INPUT_KEY));
    35d3:	48 8d 54 24 2c       	lea    0x2c(%rsp),%rdx
    35d8:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    35de:	4c 89 f9             	mov    %r15,%rcx
    35e1:	e8 ca 04 00 00       	call   3ab0 <CopyMem>
}
    35e6:	48 83 c4 38          	add    $0x38,%rsp
    35ea:	5b                   	pop    %rbx
    35eb:	5d                   	pop    %rbp
    35ec:	41 5c                	pop    %r12
    35ee:	41 5d                	pop    %r13
    35f0:	41 5e                	pop    %r14
    35f2:	41 5f                	pop    %r15
    35f4:	c3                   	ret    
    35f5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    35fc:	00 00 00 
    35ff:	90                   	nop

0000000000003600 <InitializeUnicodeSupport>:

VOID
InitializeUnicodeSupport (
    CHAR8 *LangCode
    )
{
    3600:	f3 0f 1e fa          	endbr64 
    3604:	41 57                	push   %r15

    //
    // If we don't know it, lookup the current language code
    //

    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    3606:	31 d2                	xor    %edx,%edx
{
    3608:	41 56                	push   %r14
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    360a:	4c 8d 35 9f 7d 00 00 	lea    0x7d9f(%rip),%r14        # b3b0 <gEfiUnicodeCollationProtocolGuid>
{
    3611:	41 55                	push   %r13
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    3613:	4c 89 f6             	mov    %r14,%rsi
{
    3616:	41 54                	push   %r12
    3618:	55                   	push   %rbp
    3619:	53                   	push   %rbx
    361a:	48 89 fb             	mov    %rdi,%rbx
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    361d:	bf 02 00 00 00       	mov    $0x2,%edi
{
    3622:	48 83 ec 58          	sub    $0x58,%rsp
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    3626:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
    362b:	4c 8d 44 24 48       	lea    0x48(%rsp),%r8
    3630:	e8 5b 53 00 00       	call   8990 <LibLocateHandle>
    if (!LangCode || !NoHandles) {
    3635:	48 85 db             	test   %rbx,%rbx
    3638:	74 46                	je     3680 <InitializeUnicodeSupport+0x80>
    363a:	48 83 7c 24 40 00    	cmpq   $0x0,0x40(%rsp)
    3640:	74 3e                	je     3680 <InitializeUnicodeSupport+0x80>
    3642:	48 8d 44 24 38       	lea    0x38(%rsp),%rax

    //
    // Check all driver's for a matching language code
    //

    for (Index=0; Index < NoHandles; Index++) {
    3647:	45 31 ed             	xor    %r13d,%r13d
    364a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
        Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handles[Index], &UnicodeCollationProtocol, (VOID*)&Ui);
    364f:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    3654:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
    3659:	4c 89 f2             	mov    %r14,%rdx
    365c:	4a 8b 0c e8          	mov    (%rax,%r13,8),%rcx
    3660:	48 8b 05 59 86 00 00 	mov    0x8659(%rip),%rax        # bcc0 <BS>
    3667:	ff 90 98 00 00 00    	call   *0x98(%rax)
        if (EFI_ERROR(Status)) {
    366d:	48 85 c0             	test   %rax,%rax
    3670:	79 2e                	jns    36a0 <InitializeUnicodeSupport+0xa0>
    for (Index=0; Index < NoHandles; Index++) {
    3672:	49 83 c5 01          	add    $0x1,%r13
    3676:	4c 39 6c 24 40       	cmp    %r13,0x40(%rsp)
    367b:	77 d2                	ja     364f <InitializeUnicodeSupport+0x4f>
    367d:	0f 1f 00             	nopl   (%rax)
Done:
    //
    // Cleanup
    //

    if (Handles) {
    3680:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    3685:	48 85 ff             	test   %rdi,%rdi
    3688:	74 05                	je     368f <InitializeUnicodeSupport+0x8f>
        FreePool (Handles);
    368a:	e8 41 03 00 00       	call   39d0 <FreePool>
    }
}
    368f:	48 83 c4 58          	add    $0x58,%rsp
    3693:	5b                   	pop    %rbx
    3694:	5d                   	pop    %rbp
    3695:	41 5c                	pop    %r12
    3697:	41 5d                	pop    %r13
    3699:	41 5e                	pop    %r14
    369b:	41 5f                	pop    %r15
    369d:	c3                   	ret    
    369e:	66 90                	xchg   %ax,%ax
        Languages = Ui->SupportedLanguages;
    36a0:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    36a5:	4c 8b 60 30          	mov    0x30(%rax),%r12
        Length = strlena(Languages);
    36a9:	4c 89 e7             	mov    %r12,%rdi
    36ac:	e8 9f 31 00 00       	call   6850 <strlena>
    36b1:	48 89 c5             	mov    %rax,%rbp
        for (Position=0; Position < Length; Position += ISO_639_2_ENTRY_SIZE) {
    36b4:	48 85 c0             	test   %rax,%rax
    36b7:	74 b9                	je     3672 <InitializeUnicodeSupport+0x72>
    36b9:	45 31 ff             	xor    %r15d,%r15d
    36bc:	eb 0b                	jmp    36c9 <InitializeUnicodeSupport+0xc9>
    36be:	66 90                	xchg   %ax,%ax
    36c0:	49 83 c7 03          	add    $0x3,%r15
    36c4:	4c 39 fd             	cmp    %r15,%rbp
    36c7:	76 a9                	jbe    3672 <InitializeUnicodeSupport+0x72>
            if (CompareMem (Languages+Position, LangCode, ISO_639_2_ENTRY_SIZE) == 0) {
    36c9:	4b 8d 3c 3c          	lea    (%r12,%r15,1),%rdi
    36cd:	ba 03 00 00 00       	mov    $0x3,%edx
    36d2:	48 89 de             	mov    %rbx,%rsi
    36d5:	e8 86 04 00 00       	call   3b60 <CompareMem>
    36da:	48 85 c0             	test   %rax,%rax
    36dd:	75 e1                	jne    36c0 <InitializeUnicodeSupport+0xc0>
                UnicodeInterface = Ui;
    36df:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    36e4:	48 89 05 d5 7d 00 00 	mov    %rax,0x7dd5(%rip)        # b4c0 <UnicodeInterface>
                goto Done;
    36eb:	eb 93                	jmp    3680 <InitializeUnicodeSupport+0x80>
    36ed:	0f 1f 00             	nopl   (%rax)

00000000000036f0 <EFIDebugVariable>:

VOID
EFIDebugVariable (
    VOID
    )
{
    36f0:	f3 0f 1e fa          	endbr64 
    36f4:	48 83 ec 58          	sub    $0x58,%rsp
    UINT32          Attributes;
    UINTN           DataSize;
    UINTN           NewEFIDebug;

    DataSize = sizeof(EFIDebug);
    Status = uefi_call_wrapper(RT->GetVariable, 5, L"EFIDebug", &EfiGlobalVariable, &Attributes, &DataSize, &NewEFIDebug);
    36f8:	48 8d 15 a1 7d 00 00 	lea    0x7da1(%rip),%rdx        # b4a0 <gEfiGlobalVariableGuid>
    36ff:	48 8d 0d c0 ae 00 00 	lea    0xaec0(%rip),%rcx        # e5c6 <_DYNAMIC+0x25c6>
    3706:	48 8d 44 24 48       	lea    0x48(%rsp),%rax
    370b:	4c 8d 4c 24 40       	lea    0x40(%rsp),%r9
    DataSize = sizeof(EFIDebug);
    3710:	48 c7 44 24 40 08 00 	movq   $0x8,0x40(%rsp)
    3717:	00 00 
    Status = uefi_call_wrapper(RT->GetVariable, 5, L"EFIDebug", &EfiGlobalVariable, &Attributes, &DataSize, &NewEFIDebug);
    3719:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    371e:	48 8b 05 db 85 00 00 	mov    0x85db(%rip),%rax        # bd00 <RT>
    3725:	4c 8d 44 24 3c       	lea    0x3c(%rsp),%r8
    372a:	ff 50 48             	call   *0x48(%rax)
    if (!EFI_ERROR(Status)) {
    372d:	48 85 c0             	test   %rax,%rax
    3730:	78 0c                	js     373e <EFIDebugVariable+0x4e>
        EFIDebug = NewEFIDebug;
    3732:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    3737:	48 89 05 92 80 00 00 	mov    %rax,0x8092(%rip)        # b7d0 <EFIDebug>
    }
}
    373e:	48 83 c4 58          	add    $0x58,%rsp
    3742:	c3                   	ret    
    3743:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    374a:	00 00 00 00 
    374e:	66 90                	xchg   %ax,%ax

0000000000003750 <InitializeLib>:
{
    3750:	f3 0f 1e fa          	endbr64 
    if (LibInitialized)
    3754:	80 3d 7d 85 00 00 00 	cmpb   $0x0,0x857d(%rip)        # bcd8 <LibInitialized>
    375b:	0f 85 9f 00 00 00    	jne    3800 <InitializeLib+0xb0>
{
    3761:	41 54                	push   %r12
    3763:	49 89 fc             	mov    %rdi,%r12
    3766:	55                   	push   %rbp
    3767:	48 89 f5             	mov    %rsi,%rbp
    376a:	48 83 ec 38          	sub    $0x38,%rsp
    BS = SystemTable->BootServices;
    376e:	48 8b 46 60          	mov    0x60(%rsi),%rax
    RT = SystemTable->RuntimeServices;
    3772:	48 8b 56 58          	mov    0x58(%rsi),%rdx
    LibInitialized = TRUE;
    3776:	c6 05 5b 85 00 00 01 	movb   $0x1,0x855b(%rip)        # bcd8 <LibInitialized>
    LibFwInstance = FALSE;
    377d:	c6 05 74 85 00 00 00 	movb   $0x0,0x8574(%rip)        # bcf8 <LibFwInstance>
    LibImageHandle = ImageHandle;
    3784:	48 89 3d 45 85 00 00 	mov    %rdi,0x8545(%rip)        # bcd0 <LibImageHandle>
    ST = SystemTable;
    378b:	48 89 35 36 85 00 00 	mov    %rsi,0x8536(%rip)        # bcc8 <ST>
    BS = SystemTable->BootServices;
    3792:	48 89 05 27 85 00 00 	mov    %rax,0x8527(%rip)        # bcc0 <BS>
    RT = SystemTable->RuntimeServices;
    3799:	48 89 15 60 85 00 00 	mov    %rdx,0x8560(%rip)        # bd00 <RT>
    if (ImageHandle) {
    37a0:	48 85 ff             	test   %rdi,%rdi
    37a3:	74 63                	je     3808 <InitializeLib+0xb8>
	Status = uefi_call_wrapper(
    37a5:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    37aa:	48 8d 15 9f 7c 00 00 	lea    0x7c9f(%rip),%rdx        # b450 <gEfiLoadedImageProtocolGuid>
    37b1:	48 89 f9             	mov    %rdi,%rcx
    37b4:	ff 90 98 00 00 00    	call   *0x98(%rax)
	if (!EFI_ERROR(Status)) {
    37ba:	48 85 c0             	test   %rax,%rax
    37bd:	78 0e                	js     37cd <InitializeLib+0x7d>
	    PoolAllocationType = LoadedImage->ImageDataType;
    37bf:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    37c4:	8b 40 54             	mov    0x54(%rax),%eax
    37c7:	89 05 ef 7c 00 00    	mov    %eax,0x7cef(%rip)        # b4bc <PoolAllocationType>
	EFIDebugVariable ();
    37cd:	e8 1e ff ff ff       	call   36f0 <EFIDebugVariable>
    InitializeGuid();
    37d2:	e8 a9 50 00 00       	call   8880 <InitializeGuid>
    InitializeLibPlatform(ImageHandle,SystemTable);
    37d7:	48 89 ee             	mov    %rbp,%rsi
    37da:	4c 89 e7             	mov    %r12,%rdi
    37dd:	e8 de 38 00 00       	call   70c0 <InitializeLibPlatform>
    if (ImageHandle && UnicodeInterface == &LibStubUnicodeInterface) {
    37e2:	48 8d 05 f7 7c 00 00 	lea    0x7cf7(%rip),%rax        # b4e0 <LibStubUnicodeInterface>
    37e9:	48 39 05 d0 7c 00 00 	cmp    %rax,0x7cd0(%rip)        # b4c0 <UnicodeInterface>
    37f0:	74 2e                	je     3820 <InitializeLib+0xd0>
}
    37f2:	48 83 c4 38          	add    $0x38,%rsp
    37f6:	5d                   	pop    %rbp
    37f7:	41 5c                	pop    %r12
    37f9:	c3                   	ret    
    37fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    3800:	c3                   	ret    
    3801:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    InitializeGuid();
    3808:	e8 73 50 00 00       	call   8880 <InitializeGuid>
}
    380d:	48 83 c4 38          	add    $0x38,%rsp
    InitializeLibPlatform(ImageHandle,SystemTable);
    3811:	48 89 ee             	mov    %rbp,%rsi
    3814:	31 ff                	xor    %edi,%edi
}
    3816:	5d                   	pop    %rbp
    3817:	41 5c                	pop    %r12
    InitializeLibPlatform(ImageHandle,SystemTable);
    3819:	e9 a2 38 00 00       	jmp    70c0 <InitializeLibPlatform>
    381e:	66 90                	xchg   %ax,%ax
        LangCode = LibGetVariable (VarLanguage, &EfiGlobalVariable);
    3820:	48 8d 3d b1 ad 00 00 	lea    0xadb1(%rip),%rdi        # e5d8 <_DYNAMIC+0x25d8>
    3827:	48 8d 35 72 7c 00 00 	lea    0x7c72(%rip),%rsi        # b4a0 <gEfiGlobalVariableGuid>
    382e:	e8 fd 05 00 00       	call   3e30 <LibGetVariable>
    3833:	48 89 c5             	mov    %rax,%rbp
        InitializeUnicodeSupport (LangCode);
    3836:	48 89 c7             	mov    %rax,%rdi
    3839:	e8 c2 fd ff ff       	call   3600 <InitializeUnicodeSupport>
        if (LangCode) {
    383e:	48 85 ed             	test   %rbp,%rbp
    3841:	74 af                	je     37f2 <InitializeLib+0xa2>
            FreePool (LangCode);
    3843:	48 89 ef             	mov    %rbp,%rdi
    3846:	e8 85 01 00 00       	call   39d0 <FreePool>
    384b:	eb a5                	jmp    37f2 <InitializeLib+0xa2>
    384d:	0f 1f 00             	nopl   (%rax)

0000000000003850 <memset>:
#ifndef __SIZE_TYPE__
#define __SIZE_TYPE__ UINTN
#endif

void *memset(void *s, int c, __SIZE_TYPE__ n)
{
    3850:	f3 0f 1e fa          	endbr64 
    3854:	48 89 f8             	mov    %rdi,%rax
    3857:	4c 8d 04 17          	lea    (%rdi,%rdx,1),%r8
    unsigned char *p = s;
    385b:	48 89 f9             	mov    %rdi,%rcx

    while (n--)
    385e:	48 85 d2             	test   %rdx,%rdx
    3861:	74 12                	je     3875 <memset+0x25>
    3863:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        *p++ = c;
    3868:	48 83 c1 01          	add    $0x1,%rcx
    386c:	40 88 71 ff          	mov    %sil,-0x1(%rcx)
    while (n--)
    3870:	4c 39 c1             	cmp    %r8,%rcx
    3873:	75 f3                	jne    3868 <memset+0x18>

    return s;
}
    3875:	c3                   	ret    
    3876:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    387d:	00 00 00 

0000000000003880 <memcpy>:

void *memcpy(void *dest, const void *src, __SIZE_TYPE__ n)
{
    3880:	f3 0f 1e fa          	endbr64 
    3884:	48 89 f8             	mov    %rdi,%rax
    const unsigned char *q = src;
    unsigned char *p = dest;

    while (n--)
    3887:	48 85 d2             	test   %rdx,%rdx
    388a:	74 16                	je     38a2 <memcpy+0x22>
    388c:	31 c9                	xor    %ecx,%ecx
    388e:	66 90                	xchg   %ax,%ax
        *p++ = *q++;
    3890:	44 0f b6 04 0e       	movzbl (%rsi,%rcx,1),%r8d
    3895:	44 88 04 08          	mov    %r8b,(%rax,%rcx,1)
    while (n--)
    3899:	48 83 c1 01          	add    $0x1,%rcx
    389d:	48 39 d1             	cmp    %rdx,%rcx
    38a0:	75 ee                	jne    3890 <memcpy+0x10>

    return dest;
}
    38a2:	c3                   	ret    
    38a3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    38aa:	00 00 00 
    38ad:	0f 1f 00             	nopl   (%rax)

00000000000038b0 <AllocatePool>:

VOID *
AllocatePool (
    IN UINTN                Size
    )
{
    38b0:	f3 0f 1e fa          	endbr64 
    38b4:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_STATUS              Status;
    VOID                    *p;

    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    38b8:	48 8b 05 01 84 00 00 	mov    0x8401(%rip),%rax        # bcc0 <BS>
    38bf:	8b 0d f7 7b 00 00    	mov    0x7bf7(%rip),%ecx        # b4bc <PoolAllocationType>
{
    38c5:	48 89 fa             	mov    %rdi,%rdx
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    38c8:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    38cd:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
        DEBUG((D_ERROR, "AllocatePool: out of pool  %x\n", Status));
        p = NULL;
    }
    return p;
    38d0:	48 85 c0             	test   %rax,%rax
    38d3:	b8 00 00 00 00       	mov    $0x0,%eax
    38d8:	48 0f 49 44 24 28    	cmovns 0x28(%rsp),%rax
}
    38de:	48 83 c4 38          	add    $0x38,%rsp
    38e2:	c3                   	ret    
    38e3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    38ea:	00 00 00 00 
    38ee:	66 90                	xchg   %ax,%ax

00000000000038f0 <AllocateZeroPool>:

VOID *
AllocateZeroPool (
    IN UINTN                Size
    )
{
    38f0:	f3 0f 1e fa          	endbr64 
    38f4:	41 54                	push   %r12
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    38f6:	48 89 fa             	mov    %rdi,%rdx
    return p;
    38f9:	45 31 e4             	xor    %r12d,%r12d
{
    38fc:	55                   	push   %rbp
    38fd:	48 89 fd             	mov    %rdi,%rbp
    3900:	48 83 ec 38          	sub    $0x38,%rsp
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3904:	48 8b 05 b5 83 00 00 	mov    0x83b5(%rip),%rax        # bcc0 <BS>
    390b:	8b 0d ab 7b 00 00    	mov    0x7bab(%rip),%ecx        # b4bc <PoolAllocationType>
    3911:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    3916:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    3919:	48 85 c0             	test   %rax,%rax
    391c:	78 15                	js     3933 <AllocateZeroPool+0x43>
    return p;
    391e:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
    VOID                    *p;

    p = AllocatePool (Size);
    if (p) {
    3923:	4d 85 e4             	test   %r12,%r12
    3926:	74 0b                	je     3933 <AllocateZeroPool+0x43>
ZeroMem (
    IN VOID     *Buffer,
    IN UINTN    Size
    )
{
    RtZeroMem (Buffer, Size);
    3928:	48 89 ee             	mov    %rbp,%rsi
    392b:	4c 89 e7             	mov    %r12,%rdi
    392e:	e8 dd 32 00 00       	call   6c10 <RtZeroMem>
}
    3933:	48 83 c4 38          	add    $0x38,%rsp
    3937:	4c 89 e0             	mov    %r12,%rax
    393a:	5d                   	pop    %rbp
    393b:	41 5c                	pop    %r12
    393d:	c3                   	ret    
    393e:	66 90                	xchg   %ax,%ax

0000000000003940 <ReallocatePool>:
{
    3940:	f3 0f 1e fa          	endbr64 
    3944:	41 55                	push   %r13
    3946:	41 54                	push   %r12
    3948:	49 89 fc             	mov    %rdi,%r12
    394b:	55                   	push   %rbp
    394c:	53                   	push   %rbx
    394d:	48 83 ec 38          	sub    $0x38,%rsp
    if (NewSize) {
    3951:	48 85 d2             	test   %rdx,%rdx
    3954:	74 62                	je     39b8 <ReallocatePool+0x78>
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3956:	48 8b 05 63 83 00 00 	mov    0x8363(%rip),%rax        # bcc0 <BS>
    395d:	8b 0d 59 7b 00 00    	mov    0x7b59(%rip),%ecx        # b4bc <PoolAllocationType>
    3963:	48 89 f5             	mov    %rsi,%rbp
    3966:	48 89 d3             	mov    %rdx,%rbx
    3969:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    396e:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    3971:	48 85 c0             	test   %rax,%rax
    3974:	78 42                	js     39b8 <ReallocatePool+0x78>
    return p;
    3976:	4c 8b 6c 24 28       	mov    0x28(%rsp),%r13
    if (OldPool) {
    397b:	4d 85 e4             	test   %r12,%r12
    397e:	74 27                	je     39a7 <ReallocatePool+0x67>
        if (NewPool) {
    3980:	4d 85 ed             	test   %r13,%r13
    3983:	74 15                	je     399a <ReallocatePool+0x5a>
            CopyMem (NewPool, OldPool, OldSize < NewSize ? OldSize : NewSize);
    3985:	48 39 eb             	cmp    %rbp,%rbx
    3988:	48 89 ea             	mov    %rbp,%rdx
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    )
{
    RtCopyMem (Dest, Src, len);
    398b:	4c 89 e6             	mov    %r12,%rsi
    398e:	4c 89 ef             	mov    %r13,%rdi
            CopyMem (NewPool, OldPool, OldSize < NewSize ? OldSize : NewSize);
    3991:	48 0f 46 d3          	cmovbe %rbx,%rdx
    RtCopyMem (Dest, Src, len);
    3995:	e8 b6 32 00 00       	call   6c50 <RtCopyMem>
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    399a:	48 8b 05 1f 83 00 00 	mov    0x831f(%rip),%rax        # bcc0 <BS>
    39a1:	4c 89 e1             	mov    %r12,%rcx
    39a4:	ff 50 48             	call   *0x48(%rax)
}
    39a7:	48 83 c4 38          	add    $0x38,%rsp
    39ab:	4c 89 e8             	mov    %r13,%rax
    39ae:	5b                   	pop    %rbx
    39af:	5d                   	pop    %rbp
    39b0:	41 5c                	pop    %r12
    39b2:	41 5d                	pop    %r13
    39b4:	c3                   	ret    
    39b5:	0f 1f 00             	nopl   (%rax)
    NewPool = NULL;
    39b8:	45 31 ed             	xor    %r13d,%r13d
    if (OldPool) {
    39bb:	4d 85 e4             	test   %r12,%r12
    39be:	75 da                	jne    399a <ReallocatePool+0x5a>
}
    39c0:	48 83 c4 38          	add    $0x38,%rsp
    39c4:	4c 89 e8             	mov    %r13,%rax
    39c7:	5b                   	pop    %rbx
    39c8:	5d                   	pop    %rbp
    39c9:	41 5c                	pop    %r12
    39cb:	41 5d                	pop    %r13
    39cd:	c3                   	ret    
    39ce:	66 90                	xchg   %ax,%ax

00000000000039d0 <FreePool>:
{
    39d0:	f3 0f 1e fa          	endbr64 
    39d4:	48 83 ec 28          	sub    $0x28,%rsp
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    39d8:	48 8b 05 e1 82 00 00 	mov    0x82e1(%rip),%rax        # bcc0 <BS>
{
    39df:	48 89 f9             	mov    %rdi,%rcx
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    39e2:	ff 50 48             	call   *0x48(%rax)
}
    39e5:	48 83 c4 28          	add    $0x28,%rsp
    39e9:	c3                   	ret    
    39ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000039f0 <ZeroMem>:
{
    39f0:	f3 0f 1e fa          	endbr64 
    RtZeroMem (Buffer, Size);
    39f4:	e9 17 32 00 00       	jmp    6c10 <RtZeroMem>
    39f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003a00 <SetMem>:
{
    3a00:	f3 0f 1e fa          	endbr64 
    3a04:	57                   	push   %rdi
    3a05:	48 89 cf             	mov    %rcx,%rdi
    3a08:	56                   	push   %rsi
    3a09:	48 89 d6             	mov    %rdx,%rsi
    RtSetMem (Buffer, Size, Value);
    3a0c:	41 0f b6 d0          	movzbl %r8b,%edx
{
    3a10:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    3a17:	0f 29 34 24          	movaps %xmm6,(%rsp)
    3a1b:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    3a20:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    3a26:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    3a2c:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    3a32:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    3a38:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    3a3e:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    3a44:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    3a4b:	00 00 
    3a4d:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    3a54:	00 00 
    RtSetMem (Buffer, Size, Value);
    3a56:	e8 d5 31 00 00       	call   6c30 <RtSetMem>
}
    3a5b:	0f 28 34 24          	movaps (%rsp),%xmm6
    3a5f:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    3a64:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    3a6a:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    3a70:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    3a76:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    3a7c:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    3a82:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    3a88:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    3a8f:	00 00 
    3a91:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    3a98:	00 00 
    3a9a:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    3aa1:	5e                   	pop    %rsi
    3aa2:	5f                   	pop    %rdi
    3aa3:	c3                   	ret    
    3aa4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3aab:	00 00 00 00 
    3aaf:	90                   	nop

0000000000003ab0 <CopyMem>:
{
    3ab0:	f3 0f 1e fa          	endbr64 
    3ab4:	57                   	push   %rdi
    3ab5:	48 89 cf             	mov    %rcx,%rdi
    3ab8:	56                   	push   %rsi
    3ab9:	48 89 d6             	mov    %rdx,%rsi
    3abc:	4c 89 c2             	mov    %r8,%rdx
    3abf:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    3ac6:	0f 29 34 24          	movaps %xmm6,(%rsp)
    3aca:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    3acf:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    3ad5:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    3adb:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    3ae1:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    3ae7:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    3aed:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    3af3:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    3afa:	00 00 
    3afc:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    3b03:	00 00 
    RtCopyMem (Dest, Src, len);
    3b05:	e8 46 31 00 00       	call   6c50 <RtCopyMem>
}
    3b0a:	0f 28 34 24          	movaps (%rsp),%xmm6
    3b0e:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    3b13:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    3b19:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    3b1f:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    3b25:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    3b2b:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    3b31:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    3b37:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    3b3e:	00 00 
    3b40:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    3b47:	00 00 
    3b49:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    3b50:	5e                   	pop    %rsi
    3b51:	5f                   	pop    %rdi
    3b52:	c3                   	ret    
    3b53:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3b5a:	00 00 00 00 
    3b5e:	66 90                	xchg   %ax,%ax

0000000000003b60 <CompareMem>:
CompareMem (
    IN CONST VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    )
{
    3b60:	f3 0f 1e fa          	endbr64 
    return RtCompareMem (Dest, Src, len);
    3b64:	e9 67 31 00 00       	jmp    6cd0 <RtCompareMem>
    3b69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003b70 <GrowBuffer>:
    
    TRUE - if the buffer was reallocated and the caller 
    should try the API again.

--*/
{
    3b70:	f3 0f 1e fa          	endbr64 
    3b74:	41 54                	push   %r12
    3b76:	49 89 d4             	mov    %rdx,%r12
    3b79:	55                   	push   %rbp
    3b7a:	48 89 fd             	mov    %rdi,%rbp
    3b7d:	53                   	push   %rbx
    3b7e:	48 89 f3             	mov    %rsi,%rbx
    3b81:	48 83 ec 30          	sub    $0x30,%rsp

    //
    // If this is an initial request, buffer will be null with a new buffer size
    //

    if (!*Buffer && BufferSize) {
    3b85:	48 8b 0e             	mov    (%rsi),%rcx
    3b88:	48 85 d2             	test   %rdx,%rdx
    3b8b:	74 05                	je     3b92 <GrowBuffer+0x22>
    3b8d:	48 85 c9             	test   %rcx,%rcx
    3b90:	74 5e                	je     3bf0 <GrowBuffer+0x80>
    //
    // If the status code is "buffer too small", resize the buffer
    //
        
    TryAgain = FALSE;
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    3b92:	48 ba 05 00 00 00 00 	movabs $0x8000000000000005,%rdx
    3b99:	00 00 80 
    3b9c:	48 8b 45 00          	mov    0x0(%rbp),%rax
    3ba0:	48 39 d0             	cmp    %rdx,%rax
    3ba3:	74 5b                	je     3c00 <GrowBuffer+0x90>

    //
    // If there's an error, free the buffer
    //

    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    3ba5:	48 85 c0             	test   %rax,%rax
    3ba8:	78 26                	js     3bd0 <GrowBuffer+0x60>
        FreePool (*Buffer);
        *Buffer = NULL;
    }

    return TryAgain;
}
    3baa:	48 83 c4 30          	add    $0x30,%rsp
        *Buffer = NULL;
    3bae:	31 c0                	xor    %eax,%eax
}
    3bb0:	5b                   	pop    %rbx
    3bb1:	5d                   	pop    %rbp
    3bb2:	41 5c                	pop    %r12
    3bb4:	c3                   	ret    
    3bb5:	0f 1f 00             	nopl   (%rax)
        *Buffer = AllocatePool (BufferSize);
    3bb8:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
            *Status = EFI_OUT_OF_RESOURCES;
    3bbf:	48 b8 09 00 00 00 00 	movabs $0x8000000000000009,%rax
    3bc6:	00 00 80 
    3bc9:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    3bcd:	48 8b 0b             	mov    (%rbx),%rcx
    3bd0:	48 85 c9             	test   %rcx,%rcx
    3bd3:	74 d5                	je     3baa <GrowBuffer+0x3a>
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3bd5:	48 8b 05 e4 80 00 00 	mov    0x80e4(%rip),%rax        # bcc0 <BS>
    3bdc:	ff 50 48             	call   *0x48(%rax)
        *Buffer = NULL;
    3bdf:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    3be6:	eb c2                	jmp    3baa <GrowBuffer+0x3a>
    3be8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    3bef:	00 
        *Status = EFI_BUFFER_TOO_SMALL;
    3bf0:	48 b8 05 00 00 00 00 	movabs $0x8000000000000005,%rax
    3bf7:	00 00 80 
    3bfa:	48 89 07             	mov    %rax,(%rdi)
        if (*Buffer) {
    3bfd:	48 8b 0e             	mov    (%rsi),%rcx
    3c00:	48 85 c9             	test   %rcx,%rcx
    3c03:	74 0a                	je     3c0f <GrowBuffer+0x9f>
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3c05:	48 8b 05 b4 80 00 00 	mov    0x80b4(%rip),%rax        # bcc0 <BS>
    3c0c:	ff 50 48             	call   *0x48(%rax)
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3c0f:	48 8b 05 aa 80 00 00 	mov    0x80aa(%rip),%rax        # bcc0 <BS>
    3c16:	8b 0d a0 78 00 00    	mov    0x78a0(%rip),%ecx        # b4bc <PoolAllocationType>
    3c1c:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    3c21:	4c 89 e2             	mov    %r12,%rdx
    3c24:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    3c27:	48 85 c0             	test   %rax,%rax
    3c2a:	78 8c                	js     3bb8 <GrowBuffer+0x48>
    return p;
    3c2c:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
        *Buffer = AllocatePool (BufferSize);
    3c31:	48 89 03             	mov    %rax,(%rbx)
        if (*Buffer) {
    3c34:	48 85 c0             	test   %rax,%rax
    3c37:	74 86                	je     3bbf <GrowBuffer+0x4f>
}
    3c39:	48 83 c4 30          	add    $0x30,%rsp
            TryAgain = TRUE;
    3c3d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3c42:	5b                   	pop    %rbx
    3c43:	5d                   	pop    %rbp
    3c44:	41 5c                	pop    %r12
    3c46:	c3                   	ret    
    3c47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3c4e:	00 00 

0000000000003c50 <LibMemoryMap>:
    OUT UINTN               *NoEntries,
    OUT UINTN               *MapKey,
    OUT UINTN               *DescriptorSize,
    OUT UINT32              *DescriptorVersion
    )
{
    3c50:	f3 0f 1e fa          	endbr64 
    3c54:	41 57                	push   %r15
    3c56:	41 56                	push   %r14
    3c58:	41 55                	push   %r13
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    3c5a:	49 bd 05 00 00 00 00 	movabs $0x8000000000000005,%r13
    3c61:	00 00 80 
{
    3c64:	41 54                	push   %r12
    3c66:	49 89 f4             	mov    %rsi,%r12
    3c69:	55                   	push   %rbp
    3c6a:	48 89 cd             	mov    %rcx,%rbp
    3c6d:	53                   	push   %rbx
    3c6e:	48 89 d3             	mov    %rdx,%rbx

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3c71:	ba 28 00 00 00       	mov    $0x28,%edx
{
    3c76:	48 83 ec 58          	sub    $0x58,%rsp
    3c7a:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    3c7f:	4c 8d 74 24 48       	lea    0x48(%rsp),%r14
    BufferSize = sizeof(EFI_MEMORY_DESCRIPTOR);
    3c84:	48 c7 44 24 40 28 00 	movq   $0x28,0x40(%rsp)
    3c8b:	00 00 
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3c8d:	48 8b 05 2c 80 00 00 	mov    0x802c(%rip),%rax        # bcc0 <BS>
    3c94:	8b 0d 22 78 00 00    	mov    0x7822(%rip),%ecx        # b4bc <PoolAllocationType>
    3c9a:	4d 89 f0             	mov    %r14,%r8
    3c9d:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    3ca0:	48 85 c0             	test   %rax,%rax
    3ca3:	0f 88 97 00 00 00    	js     3d40 <LibMemoryMap+0xf0>
    return p;
    3ca9:	4c 8b 7c 24 48       	mov    0x48(%rsp),%r15
        if (*Buffer) {
    3cae:	4d 85 ff             	test   %r15,%r15
    3cb1:	0f 84 89 00 00 00    	je     3d40 <LibMemoryMap+0xf0>
        Status = uefi_call_wrapper(BS->GetMemoryMap, 5, &BufferSize, Buffer, MapKey, DescriptorSize, DescriptorVersion);
    3cb7:	48 8b 05 02 80 00 00 	mov    0x8002(%rip),%rax        # bcc0 <BS>
    3cbe:	4c 89 fa             	mov    %r15,%rdx
    3cc1:	49 89 d9             	mov    %rbx,%r9
    3cc4:	4d 89 e0             	mov    %r12,%r8
    3cc7:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
    3ccc:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
    3cd1:	ff 50 38             	call   *0x38(%rax)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3cd4:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    3cd9:	4c 39 e8             	cmp    %r13,%rax
    3cdc:	74 2a                	je     3d08 <LibMemoryMap+0xb8>
    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    3cde:	48 85 c0             	test   %rax,%rax
    3ce1:	78 45                	js     3d28 <LibMemoryMap+0xd8>
    //
    // Convert buffer size to NoEntries
    //

    if (!EFI_ERROR(Status)) {
        *NoEntries = BufferSize / *DescriptorSize;
    3ce3:	48 89 d0             	mov    %rdx,%rax
    3ce6:	31 d2                	xor    %edx,%edx
    3ce8:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    3ced:	48 f7 33             	divq   (%rbx)
    3cf0:	48 89 06             	mov    %rax,(%rsi)
    }

    return Buffer;
}
    3cf3:	48 83 c4 58          	add    $0x58,%rsp
    3cf7:	4c 89 f8             	mov    %r15,%rax
    3cfa:	5b                   	pop    %rbx
    3cfb:	5d                   	pop    %rbp
    3cfc:	41 5c                	pop    %r12
    3cfe:	41 5d                	pop    %r13
    3d00:	41 5e                	pop    %r14
    3d02:	41 5f                	pop    %r15
    3d04:	c3                   	ret    
    3d05:	0f 1f 00             	nopl   (%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3d08:	48 8b 05 b1 7f 00 00 	mov    0x7fb1(%rip),%rax        # bcc0 <BS>
    3d0f:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    3d14:	4c 89 f9             	mov    %r15,%rcx
    3d17:	ff 50 48             	call   *0x48(%rax)
    3d1a:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    3d1f:	e9 69 ff ff ff       	jmp    3c8d <LibMemoryMap+0x3d>
    3d24:	0f 1f 40 00          	nopl   0x0(%rax)
    3d28:	48 8b 05 91 7f 00 00 	mov    0x7f91(%rip),%rax        # bcc0 <BS>
    3d2f:	4c 89 f9             	mov    %r15,%rcx
    3d32:	45 31 ff             	xor    %r15d,%r15d
    3d35:	ff 50 48             	call   *0x48(%rax)
    if (!EFI_ERROR(Status)) {
    3d38:	eb b9                	jmp    3cf3 <LibMemoryMap+0xa3>
    3d3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    3d40:	45 31 ff             	xor    %r15d,%r15d
    3d43:	eb ae                	jmp    3cf3 <LibMemoryMap+0xa3>
    3d45:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3d4c:	00 00 00 00 

0000000000003d50 <LibGetVariableAndSize>:
LibGetVariableAndSize (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid,
    OUT UINTN               *VarSize
    )
{
    3d50:	f3 0f 1e fa          	endbr64 
    3d54:	41 57                	push   %r15
    3d56:	41 56                	push   %r14

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, &Buffer, BufferSize)) {
    3d58:	41 be 64 00 00 00    	mov    $0x64,%r14d
{
    3d5e:	41 55                	push   %r13
    3d60:	41 54                	push   %r12
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    3d62:	49 bc 05 00 00 00 00 	movabs $0x8000000000000005,%r12
    3d69:	00 00 80 
{
    3d6c:	55                   	push   %rbp
    3d6d:	48 89 fd             	mov    %rdi,%rbp
    3d70:	53                   	push   %rbx
    3d71:	48 89 f3             	mov    %rsi,%rbx
    3d74:	48 83 ec 58          	sub    $0x58,%rsp
    3d78:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)
    3d7d:	4c 8d 6c 24 48       	lea    0x48(%rsp),%r13
    BufferSize = 100;
    3d82:	48 c7 44 24 40 64 00 	movq   $0x64,0x40(%rsp)
    3d89:	00 00 
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3d8b:	48 8b 05 2e 7f 00 00 	mov    0x7f2e(%rip),%rax        # bcc0 <BS>
    3d92:	8b 0d 24 77 00 00    	mov    0x7724(%rip),%ecx        # b4bc <PoolAllocationType>
    3d98:	4d 89 e8             	mov    %r13,%r8
    3d9b:	4c 89 f2             	mov    %r14,%rdx
    3d9e:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    3da1:	48 85 c0             	test   %rax,%rax
    3da4:	78 67                	js     3e0d <LibGetVariableAndSize+0xbd>
    return p;
    3da6:	4c 8b 7c 24 48       	mov    0x48(%rsp),%r15
        if (*Buffer) {
    3dab:	4d 85 ff             	test   %r15,%r15
    3dae:	74 7a                	je     3e2a <LibGetVariableAndSize+0xda>
        Status = uefi_call_wrapper(
    3db0:	48 8b 05 49 7f 00 00 	mov    0x7f49(%rip),%rax        # bd00 <RT>
    3db7:	45 31 c0             	xor    %r8d,%r8d
    3dba:	48 89 da             	mov    %rbx,%rdx
    3dbd:	48 89 e9             	mov    %rbp,%rcx
    3dc0:	4c 89 7c 24 20       	mov    %r15,0x20(%rsp)
    3dc5:	4c 8d 4c 24 40       	lea    0x40(%rsp),%r9
    3dca:	ff 50 48             	call   *0x48(%rax)
    while (GrowBuffer (&Status, &Buffer, BufferSize)) {
    3dcd:	4c 8b 74 24 40       	mov    0x40(%rsp),%r14
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    3dd2:	4c 39 e0             	cmp    %r12,%rax
    3dd5:	74 41                	je     3e18 <LibGetVariableAndSize+0xc8>
    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    3dd7:	48 85 c0             	test   %rax,%rax
    3dda:	78 24                	js     3e00 <LibGetVariableAndSize+0xb0>
    3ddc:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    3de1:	4c 89 30             	mov    %r14,(%rax)
        *VarSize = BufferSize;
    } else {
        *VarSize = 0;
    }
    return Buffer;
}
    3de4:	48 83 c4 58          	add    $0x58,%rsp
    3de8:	4c 89 f8             	mov    %r15,%rax
    3deb:	5b                   	pop    %rbx
    3dec:	5d                   	pop    %rbp
    3ded:	41 5c                	pop    %r12
    3def:	41 5d                	pop    %r13
    3df1:	41 5e                	pop    %r14
    3df3:	41 5f                	pop    %r15
    3df5:	c3                   	ret    
    3df6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    3dfd:	00 00 00 
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3e00:	48 8b 05 b9 7e 00 00 	mov    0x7eb9(%rip),%rax        # bcc0 <BS>
    3e07:	4c 89 f9             	mov    %r15,%rcx
    3e0a:	ff 50 48             	call   *0x48(%rax)
        *VarSize = 0;
    3e0d:	45 31 f6             	xor    %r14d,%r14d
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3e10:	45 31 ff             	xor    %r15d,%r15d
    3e13:	eb c7                	jmp    3ddc <LibGetVariableAndSize+0x8c>
    3e15:	0f 1f 00             	nopl   (%rax)
    3e18:	48 8b 05 a1 7e 00 00 	mov    0x7ea1(%rip),%rax        # bcc0 <BS>
    3e1f:	4c 89 f9             	mov    %r15,%rcx
    3e22:	ff 50 48             	call   *0x48(%rax)
    3e25:	e9 61 ff ff ff       	jmp    3d8b <LibGetVariableAndSize+0x3b>
        *VarSize = 0;
    3e2a:	45 31 f6             	xor    %r14d,%r14d
    3e2d:	eb ad                	jmp    3ddc <LibGetVariableAndSize+0x8c>
    3e2f:	90                   	nop

0000000000003e30 <LibGetVariable>:
VOID *
LibGetVariable (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid
    )
{
    3e30:	f3 0f 1e fa          	endbr64 
    3e34:	48 83 ec 18          	sub    $0x18,%rsp
    UINTN   VarSize;

    return LibGetVariableAndSize (Name, VendorGuid, &VarSize);
    3e38:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
    3e3d:	e8 0e ff ff ff       	call   3d50 <LibGetVariableAndSize>
}
    3e42:	48 83 c4 18          	add    $0x18,%rsp
    3e46:	c3                   	ret    
    3e47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3e4e:	00 00 

0000000000003e50 <LibDeleteVariable>:
EFI_STATUS
LibDeleteVariable (
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid
    )
{
    3e50:	f3 0f 1e fa          	endbr64 
    3e54:	41 57                	push   %r15
    3e56:	49 bf 0e 00 00 00 00 	movabs $0x800000000000000e,%r15
    3e5d:	00 00 80 
    3e60:	41 56                	push   %r14
    3e62:	49 89 f6             	mov    %rsi,%r14
    3e65:	41 55                	push   %r13
    3e67:	49 89 fd             	mov    %rdi,%r13
    3e6a:	41 54                	push   %r12
    3e6c:	48 83 ec 48          	sub    $0x48,%rsp
    return LibGetVariableAndSize (Name, VendorGuid, &VarSize);
    3e70:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
    3e75:	e8 d6 fe ff ff       	call   3d50 <LibGetVariableAndSize>

    VarBuf = LibGetVariable(VarName,VarGuid);

    Status = EFI_NOT_FOUND;

    if (VarBuf) {
    3e7a:	48 85 c0             	test   %rax,%rax
    3e7d:	74 35                	je     3eb4 <LibDeleteVariable+0x64>
    3e7f:	49 89 c4             	mov    %rax,%r12
        //
        // Delete variable from Storage
        //
        Status = uefi_call_wrapper(
    3e82:	48 8b 05 77 7e 00 00 	mov    0x7e77(%rip),%rax        # bd00 <RT>
    3e89:	4c 89 e9             	mov    %r13,%rcx
    3e8c:	45 31 c9             	xor    %r9d,%r9d
    3e8f:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
    3e96:	00 00 
    3e98:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    3e9e:	4c 89 f2             	mov    %r14,%rdx
    3ea1:	ff 50 58             	call   *0x58(%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3ea4:	4c 89 e1             	mov    %r12,%rcx
        Status = uefi_call_wrapper(
    3ea7:	49 89 c7             	mov    %rax,%r15
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    3eaa:	48 8b 05 0f 7e 00 00 	mov    0x7e0f(%rip),%rax        # bcc0 <BS>
    3eb1:	ff 50 48             	call   *0x48(%rax)
        ASSERT (!EFI_ERROR(Status));
        FreePool(VarBuf);
    }

    return (Status);
}
    3eb4:	48 83 c4 48          	add    $0x48,%rsp
    3eb8:	4c 89 f8             	mov    %r15,%rax
    3ebb:	41 5c                	pop    %r12
    3ebd:	41 5d                	pop    %r13
    3ebf:	41 5e                	pop    %r14
    3ec1:	41 5f                	pop    %r15
    3ec3:	c3                   	ret    
    3ec4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3ecb:	00 00 00 00 
    3ecf:	90                   	nop

0000000000003ed0 <LibSetNVVariable>:
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid,
    IN UINTN	 DataSize,
    IN VOID     *Data
    )
{
    3ed0:	f3 0f 1e fa          	endbr64 
    3ed4:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_STATUS  Status;

    Status = uefi_call_wrapper(
    3ed8:	48 8b 05 21 7e 00 00 	mov    0x7e21(%rip),%rax        # bd00 <RT>
{
    3edf:	49 89 d1             	mov    %rdx,%r9
    Status = uefi_call_wrapper(
    3ee2:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    3ee8:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    3eed:	48 89 f2             	mov    %rsi,%rdx
    3ef0:	48 89 f9             	mov    %rdi,%rcx
    3ef3:	ff 50 58             	call   *0x58(%rax)
	    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
	    DataSize, Data
	    );
    ASSERT (!EFI_ERROR(Status));
    return (Status);
}
    3ef6:	48 83 c4 38          	add    $0x38,%rsp
    3efa:	c3                   	ret    
    3efb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003f00 <LibSetVariable>:
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid,
    IN UINTN	 DataSize,
    IN VOID     *Data
    )
{
    3f00:	f3 0f 1e fa          	endbr64 
    3f04:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_STATUS  Status;

    Status = uefi_call_wrapper(
    3f08:	48 8b 05 f1 7d 00 00 	mov    0x7df1(%rip),%rax        # bd00 <RT>
{
    3f0f:	49 89 d1             	mov    %rdx,%r9
    Status = uefi_call_wrapper(
    3f12:	41 b8 06 00 00 00    	mov    $0x6,%r8d
    3f18:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    3f1d:	48 89 f2             	mov    %rsi,%rdx
    3f20:	48 89 f9             	mov    %rdi,%rcx
    3f23:	ff 50 58             	call   *0x58(%rax)
	    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
	    DataSize, Data
	    );
    ASSERT (!EFI_ERROR(Status));
    return (Status);
}
    3f26:	48 83 c4 38          	add    $0x38,%rsp
    3f2a:	c3                   	ret    
    3f2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003f30 <LibInsertToTailOfBootOrder>:
EFI_STATUS
LibInsertToTailOfBootOrder (
    IN  UINT16  BootOption,
    IN  BOOLEAN OnlyInsertIfEmpty
    )
{
    3f30:	f3 0f 1e fa          	endbr64 
    3f34:	41 57                	push   %r15
    3f36:	41 56                	push   %r14
    UINT16      *NewBootOptionArray;
    UINTN       VarSize;
    UINTN       Index;
    EFI_STATUS  Status;

    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    3f38:	4c 8d 35 61 75 00 00 	lea    0x7561(%rip),%r14        # b4a0 <gEfiGlobalVariableGuid>
{
    3f3f:	41 55                	push   %r13
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    3f41:	4c 8d 2d 9a a6 00 00 	lea    0xa69a(%rip),%r13        # e5e2 <_DYNAMIC+0x25e2>
{
    3f48:	41 54                	push   %r12
    3f4a:	41 89 f4             	mov    %esi,%r12d
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    3f4d:	4c 89 f6             	mov    %r14,%rsi
{
    3f50:	53                   	push   %rbx
    3f51:	89 fb                	mov    %edi,%ebx
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    3f53:	4c 89 ef             	mov    %r13,%rdi
{
    3f56:	48 83 ec 40          	sub    $0x40,%rsp
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    3f5a:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
    3f5f:	e8 ec fd ff ff       	call   3d50 <LibGetVariableAndSize>
    if (VarSize != 0 && OnlyInsertIfEmpty) {
    3f64:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    3f69:	49 89 c7             	mov    %rax,%r15
    if (VarSize != 0 && OnlyInsertIfEmpty) {
    3f6c:	48 85 d2             	test   %rdx,%rdx
    3f6f:	74 09                	je     3f7a <LibInsertToTailOfBootOrder+0x4a>
    3f71:	45 84 e4             	test   %r12b,%r12b
    3f74:	0f 85 16 01 00 00    	jne    4090 <LibInsertToTailOfBootOrder+0x160>
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3f7a:	48 8b 05 3f 7d 00 00 	mov    0x7d3f(%rip),%rax        # bcc0 <BS>
            FreePool (BootOptionArray);
        }
        return EFI_UNSUPPORTED;
    }

    VarSize += sizeof(UINT16);
    3f81:	48 83 c2 02          	add    $0x2,%rdx
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3f85:	8b 0d 31 75 00 00    	mov    0x7531(%rip),%ecx        # b4bc <PoolAllocationType>
    3f8b:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    VarSize += sizeof(UINT16);
    3f90:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    3f95:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    3f98:	48 85 c0             	test   %rax,%rax
    3f9b:	0f 88 9f 00 00 00    	js     4040 <LibInsertToTailOfBootOrder+0x110>
    return p;
    3fa1:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
    NewBootOptionArray = AllocatePool (VarSize);
    if (!NewBootOptionArray)
    3fa6:	4d 85 e4             	test   %r12,%r12
    3fa9:	0f 84 91 00 00 00    	je     4040 <LibInsertToTailOfBootOrder+0x110>
        return EFI_OUT_OF_RESOURCES;

    for (Index = 0; Index < ((VarSize/sizeof(UINT16)) - 1); Index++) {
    3faf:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    3fb4:	48 d1 e8             	shr    %rax
    3fb7:	48 83 f8 01          	cmp    $0x1,%rax
    3fbb:	0f 84 8f 00 00 00    	je     4050 <LibInsertToTailOfBootOrder+0x120>
    3fc1:	31 d2                	xor    %edx,%edx
    3fc3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        NewBootOptionArray[Index] = BootOptionArray[Index];
    3fc8:	41 0f b7 04 57       	movzwl (%r15,%rdx,2),%eax
    3fcd:	66 41 89 04 54       	mov    %ax,(%r12,%rdx,2)
    for (Index = 0; Index < ((VarSize/sizeof(UINT16)) - 1); Index++) {
    3fd2:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    3fd7:	48 83 c2 01          	add    $0x1,%rdx
    3fdb:	48 d1 e8             	shr    %rax
    3fde:	48 83 e8 01          	sub    $0x1,%rax
    3fe2:	48 39 d0             	cmp    %rdx,%rax
    3fe5:	77 e1                	ja     3fc8 <LibInsertToTailOfBootOrder+0x98>
    }
    //
    // Insert in the tail of the array
    //
    NewBootOptionArray[Index] = BootOption;
    3fe7:	66 41 89 1c 54       	mov    %bx,(%r12,%rdx,2)

    Status = uefi_call_wrapper(
    3fec:	4c 89 e9             	mov    %r13,%rcx
    3fef:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    3ff4:	4c 89 f2             	mov    %r14,%rdx
    3ff7:	48 8b 05 02 7d 00 00 	mov    0x7d02(%rip),%rax        # bd00 <RT>
    3ffe:	4c 89 64 24 20       	mov    %r12,0x20(%rsp)
    4003:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    4009:	ff 50 58             	call   *0x58(%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    400c:	4c 89 e1             	mov    %r12,%rcx
    Status = uefi_call_wrapper(
    400f:	49 89 c5             	mov    %rax,%r13
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4012:	48 8b 05 a7 7c 00 00 	mov    0x7ca7(%rip),%rax        # bcc0 <BS>
    4019:	ff 50 48             	call   *0x48(%rax)
    401c:	48 8b 05 9d 7c 00 00 	mov    0x7c9d(%rip),%rax        # bcc0 <BS>
    4023:	4c 89 f9             	mov    %r15,%rcx
    4026:	ff 50 48             	call   *0x48(%rax)
    FreePool (NewBootOptionArray);
    if (BootOptionArray) {
        FreePool (BootOptionArray);
    }
    return Status;
}
    4029:	48 83 c4 40          	add    $0x40,%rsp
    402d:	4c 89 e8             	mov    %r13,%rax
    4030:	5b                   	pop    %rbx
    4031:	41 5c                	pop    %r12
    4033:	41 5d                	pop    %r13
    4035:	41 5e                	pop    %r14
    4037:	41 5f                	pop    %r15
    4039:	c3                   	ret    
    403a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return EFI_OUT_OF_RESOURCES;
    4040:	49 bd 09 00 00 00 00 	movabs $0x8000000000000009,%r13
    4047:	00 00 80 
    404a:	eb dd                	jmp    4029 <LibInsertToTailOfBootOrder+0xf9>
    404c:	0f 1f 40 00          	nopl   0x0(%rax)
    NewBootOptionArray[Index] = BootOption;
    4050:	66 41 89 1c 24       	mov    %bx,(%r12)
    Status = uefi_call_wrapper(
    4055:	48 8b 05 a4 7c 00 00 	mov    0x7ca4(%rip),%rax        # bd00 <RT>
    405c:	4c 89 e9             	mov    %r13,%rcx
    405f:	4c 89 f2             	mov    %r14,%rdx
    4062:	4c 89 64 24 20       	mov    %r12,0x20(%rsp)
    4067:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    406c:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    4072:	ff 50 58             	call   *0x58(%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4075:	4c 89 e1             	mov    %r12,%rcx
    Status = uefi_call_wrapper(
    4078:	49 89 c5             	mov    %rax,%r13
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    407b:	48 8b 05 3e 7c 00 00 	mov    0x7c3e(%rip),%rax        # bcc0 <BS>
    4082:	ff 50 48             	call   *0x48(%rax)
    if (BootOptionArray) {
    4085:	4d 85 ff             	test   %r15,%r15
    4088:	74 9f                	je     4029 <LibInsertToTailOfBootOrder+0xf9>
    408a:	eb 90                	jmp    401c <LibInsertToTailOfBootOrder+0xec>
    408c:	0f 1f 40 00          	nopl   0x0(%rax)
        return EFI_UNSUPPORTED;
    4090:	49 bd 03 00 00 00 00 	movabs $0x8000000000000003,%r13
    4097:	00 00 80 
        if (BootOptionArray) {
    409a:	48 85 c0             	test   %rax,%rax
    409d:	0f 85 79 ff ff ff    	jne    401c <LibInsertToTailOfBootOrder+0xec>
    40a3:	eb 84                	jmp    4029 <LibInsertToTailOfBootOrder+0xf9>
    40a5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    40ac:	00 00 00 00 

00000000000040b0 <ValidMBR>:
BOOLEAN
ValidMBR(
    IN  MASTER_BOOT_RECORD  *Mbr,
    IN  EFI_BLOCK_IO        *BlkIo
    )
{
    40b0:	f3 0f 1e fa          	endbr64 
    40b4:	55                   	push   %rbp

    if (Mbr->Signature != MBR_SIGNATURE) {
        //
        // The BPB also has this signature, so it can not be used alone.
        //
        return FALSE;
    40b5:	31 ed                	xor    %ebp,%ebp
    if (Mbr->Signature != MBR_SIGNATURE) {
    40b7:	66 81 bf fe 01 00 00 	cmpw   $0xaa55,0x1fe(%rdi)
    40be:	55 aa 
{
    40c0:	53                   	push   %rbx
    if (Mbr->Signature != MBR_SIGNATURE) {
    40c1:	0f 85 6c 01 00 00    	jne    4233 <ValidMBR+0x183>
    } 

    ValidMbr = FALSE;
    for (i=0; i<MAX_MBR_PARTITIONS; i++) {
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
    40c7:	80 bf c2 01 00 00 00 	cmpb   $0x0,0x1c2(%rdi)
    40ce:	49 89 f2             	mov    %rsi,%r10
    if (Mbr->Signature != MBR_SIGNATURE) {
    40d1:	41 bb 01 00 00 00    	mov    $0x1,%r11d
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
    40d7:	0f 84 50 01 00 00    	je     422d <ValidMBR+0x17d>
    40dd:	0f b6 87 cb 01 00 00 	movzbl 0x1cb(%rdi),%eax
    40e4:	0f b6 97 cc 01 00 00 	movzbl 0x1cc(%rdi),%edx
    40eb:	c1 e0 08             	shl    $0x8,%eax
    40ee:	c1 e2 10             	shl    $0x10,%edx
    40f1:	09 d0                	or     %edx,%eax
    40f3:	0f b6 97 ca 01 00 00 	movzbl 0x1ca(%rdi),%edx
    40fa:	09 d0                	or     %edx,%eax
    40fc:	0f b6 97 cd 01 00 00 	movzbl 0x1cd(%rdi),%edx
    4103:	c1 e2 18             	shl    $0x18,%edx
    4106:	09 d0                	or     %edx,%eax
    4108:	0f 84 1f 01 00 00    	je     422d <ValidMBR+0x17d>
            continue;
        }
        ValidMbr = TRUE;
        StartingLBA = EXTRACT_UINT32(Mbr->Partition[i].StartingLBA);
    410e:	44 0f b6 87 c7 01 00 	movzbl 0x1c7(%rdi),%r8d
    4115:	00 
    4116:	0f b6 97 c8 01 00 00 	movzbl 0x1c8(%rdi),%edx
    411d:	41 c1 e0 08          	shl    $0x8,%r8d
    4121:	c1 e2 10             	shl    $0x10,%edx
    4124:	41 09 d0             	or     %edx,%r8d
    4127:	0f b6 97 c6 01 00 00 	movzbl 0x1c6(%rdi),%edx
    412e:	41 09 d0             	or     %edx,%r8d
    4131:	0f b6 97 c9 01 00 00 	movzbl 0x1c9(%rdi),%edx
    4138:	c1 e2 18             	shl    $0x18,%edx
    413b:	41 09 d0             	or     %edx,%r8d
        EndingLBA = StartingLBA + EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) - 1;
    413e:	42 8d 54 00 ff       	lea    -0x1(%rax,%r8,1),%edx
        if (EndingLBA > BlkIo->Media->LastBlock) {
    4143:	49 8b 42 08          	mov    0x8(%r10),%rax
        EndingLBA = StartingLBA + EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) - 1;
    4147:	49 89 d1             	mov    %rdx,%r9
        if (EndingLBA > BlkIo->Media->LastBlock) {
    414a:	48 8b 40 18          	mov    0x18(%rax),%rax
    414e:	48 39 c2             	cmp    %rax,%rdx
    4151:	76 1b                	jbe    416e <ValidMBR+0xbe>
            //  that gets created from DOS is smaller than the MBR created from 
            //  a real OS (NT & Win98). This leads to BlkIo->LastBlock being 
            //  wrong on some systems FDISKed by the OS.
            //
            //
            if (BlkIo->Media->LastBlock < MIN_MBR_DEVICE_SIZE) {
    4153:	48 3d ff ff 07 00    	cmp    $0x7ffff,%rax
    4159:	0f 86 d9 00 00 00    	jbe    4238 <ValidMBR+0x188>
                // If this is a very small device then trust the BlkIo->LastBlock
                //
                return FALSE;
            }

            if (EndingLBA > (BlkIo->Media->LastBlock + MBR_ERRATA_PAD)) {
    415f:	48 05 00 00 04 00    	add    $0x40000,%rax
    4165:	48 39 c2             	cmp    %rax,%rdx
    4168:	0f 87 ca 00 00 00    	ja     4238 <ValidMBR+0x188>
                return FALSE;
            }

        }
        for (j=i+1; j<MAX_MBR_PARTITIONS; j++) {
    416e:	4c 89 de             	mov    %r11,%rsi
    4171:	49 83 fb 04          	cmp    $0x4,%r11
    4175:	0f 84 c1 00 00 00    	je     423c <ValidMBR+0x18c>
    417b:	48 89 f8             	mov    %rdi,%rax
    417e:	66 90                	xchg   %ax,%ax
            if (Mbr->Partition[j].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[j].SizeInLBA) == 0) {
    4180:	80 b8 d2 01 00 00 00 	cmpb   $0x0,0x1d2(%rax)
    4187:	74 78                	je     4201 <ValidMBR+0x151>
    4189:	0f b6 90 db 01 00 00 	movzbl 0x1db(%rax),%edx
    4190:	0f b6 88 dc 01 00 00 	movzbl 0x1dc(%rax),%ecx
    4197:	c1 e2 08             	shl    $0x8,%edx
    419a:	c1 e1 10             	shl    $0x10,%ecx
    419d:	09 ca                	or     %ecx,%edx
    419f:	0f b6 88 da 01 00 00 	movzbl 0x1da(%rax),%ecx
    41a6:	09 ca                	or     %ecx,%edx
    41a8:	0f b6 88 dd 01 00 00 	movzbl 0x1dd(%rax),%ecx
    41af:	c1 e1 18             	shl    $0x18,%ecx
    41b2:	09 ca                	or     %ecx,%edx
    41b4:	74 4b                	je     4201 <ValidMBR+0x151>
                continue;
            }
            if (   EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) >= StartingLBA && 
    41b6:	0f b6 88 d7 01 00 00 	movzbl 0x1d7(%rax),%ecx
    41bd:	0f b6 98 d8 01 00 00 	movzbl 0x1d8(%rax),%ebx
    41c4:	c1 e1 08             	shl    $0x8,%ecx
    41c7:	c1 e3 10             	shl    $0x10,%ebx
    41ca:	09 d9                	or     %ebx,%ecx
    41cc:	0f b6 98 d6 01 00 00 	movzbl 0x1d6(%rax),%ebx
    41d3:	09 d9                	or     %ebx,%ecx
    41d5:	0f b6 98 d9 01 00 00 	movzbl 0x1d9(%rax),%ebx
    41dc:	c1 e3 18             	shl    $0x18,%ebx
    41df:	09 d9                	or     %ebx,%ecx
    41e1:	44 39 c9             	cmp    %r9d,%ecx
    41e4:	40 0f 96 c5          	setbe  %bpl
    41e8:	44 39 c1             	cmp    %r8d,%ecx
    41eb:	0f 93 c3             	setae  %bl
    41ee:	40 20 dd             	and    %bl,%bpl
    41f1:	75 45                	jne    4238 <ValidMBR+0x188>
                //
                // The Start of this region overlaps with the i'th region
                //
                return FALSE;
            } 
            NewEndingLBA = EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) + EXTRACT_UINT32(Mbr->Partition[j].SizeInLBA) - 1;
    41f3:	8d 54 0a ff          	lea    -0x1(%rdx,%rcx,1),%edx
            if ( NewEndingLBA >= StartingLBA && NewEndingLBA <= EndingLBA ) {
    41f7:	41 39 d0             	cmp    %edx,%r8d
    41fa:	77 05                	ja     4201 <ValidMBR+0x151>
    41fc:	41 39 d1             	cmp    %edx,%r9d
    41ff:	73 32                	jae    4233 <ValidMBR+0x183>
        for (j=i+1; j<MAX_MBR_PARTITIONS; j++) {
    4201:	48 83 c6 01          	add    $0x1,%rsi
    4205:	48 83 c0 10          	add    $0x10,%rax
    4209:	48 83 fe 04          	cmp    $0x4,%rsi
    420d:	0f 85 6d ff ff ff    	jne    4180 <ValidMBR+0xd0>
        ValidMbr = TRUE;
    4213:	bd 01 00 00 00       	mov    $0x1,%ebp
    4218:	48 83 c7 10          	add    $0x10,%rdi
    421c:	49 83 c3 01          	add    $0x1,%r11
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
    4220:	80 bf c2 01 00 00 00 	cmpb   $0x0,0x1c2(%rdi)
    4227:	0f 85 b0 fe ff ff    	jne    40dd <ValidMBR+0x2d>
    for (i=0; i<MAX_MBR_PARTITIONS; i++) {
    422d:	49 83 fb 04          	cmp    $0x4,%r11
    4231:	75 e5                	jne    4218 <ValidMBR+0x168>
    }
    //
    // Non of the regions overlapped so MBR is O.K.
    //
    return ValidMbr;
} 
    4233:	89 e8                	mov    %ebp,%eax
    4235:	5b                   	pop    %rbx
    4236:	5d                   	pop    %rbp
    4237:	c3                   	ret    
        return FALSE;
    4238:	31 ed                	xor    %ebp,%ebp
    423a:	eb f7                	jmp    4233 <ValidMBR+0x183>
        ValidMbr = TRUE;
    423c:	bd 01 00 00 00       	mov    $0x1,%ebp
    4241:	eb f0                	jmp    4233 <ValidMBR+0x183>
    4243:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    424a:	00 00 00 00 
    424e:	66 90                	xchg   %ax,%ax

0000000000004250 <DecimaltoBCD>:

UINT8
DecimaltoBCD(
    IN  UINT8 DecValue
    )
{
    4250:	f3 0f 1e fa          	endbr64 
    return RtDecimaltoBCD (DecValue);
    4254:	40 0f b6 ff          	movzbl %dil,%edi
    4258:	e9 33 2e 00 00       	jmp    7090 <RtDecimaltoBCD>
    425d:	0f 1f 00             	nopl   (%rax)

0000000000004260 <BCDtoDecimal>:

UINT8
BCDtoDecimal(
    IN  UINT8 BcdValue
    )
{
    4260:	f3 0f 1e fa          	endbr64 
    return RtBCDtoDecimal (BcdValue);
    4264:	40 0f b6 ff          	movzbl %dil,%edi
    4268:	e9 03 2e 00 00       	jmp    7070 <RtBCDtoDecimal>
    426d:	0f 1f 00             	nopl   (%rax)

0000000000004270 <LibGetSystemConfigurationTable>:
LibGetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    )

{
    4270:	f3 0f 1e fa          	endbr64 
    UINTN Index;

    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
    4274:	48 8b 05 4d 7a 00 00 	mov    0x7a4d(%rip),%rax        # bcc8 <ST>
    427b:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
    4280:	0f 84 7f 00 00 00    	je     4305 <LibGetSystemConfigurationTable+0x95>
{
    4286:	41 55                	push   %r13
    4288:	49 89 f5             	mov    %rsi,%r13
    428b:	41 54                	push   %r12
    428d:	49 89 fc             	mov    %rdi,%r12
    4290:	55                   	push   %rbp
    4291:	53                   	push   %rbx
    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
    4292:	31 db                	xor    %ebx,%ebx
{
    4294:	48 83 ec 08          	sub    $0x8,%rsp
    4298:	eb 17                	jmp    42b1 <LibGetSystemConfigurationTable+0x41>
    429a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
    42a0:	48 8b 05 21 7a 00 00 	mov    0x7a21(%rip),%rax        # bcc8 <ST>
    42a7:	48 83 c3 01          	add    $0x1,%rbx
    42ab:	48 39 58 68          	cmp    %rbx,0x68(%rax)
    42af:	76 3f                	jbe    42f0 <LibGetSystemConfigurationTable+0x80>
        if (CompareGuid(TableGuid,&(ST->ConfigurationTable[Index].VendorGuid))==0) {
    42b1:	48 8b 70 70          	mov    0x70(%rax),%rsi
    42b5:	48 8d 2c 5b          	lea    (%rbx,%rbx,2),%rbp
    42b9:	4c 89 e7             	mov    %r12,%rdi
    42bc:	48 c1 e5 03          	shl    $0x3,%rbp
    42c0:	48 01 ee             	add    %rbp,%rsi
    42c3:	e8 c8 45 00 00       	call   8890 <CompareGuid>
    42c8:	48 85 c0             	test   %rax,%rax
    42cb:	75 d3                	jne    42a0 <LibGetSystemConfigurationTable+0x30>
            *Table = ST->ConfigurationTable[Index].VendorTable;
    42cd:	48 8b 05 f4 79 00 00 	mov    0x79f4(%rip),%rax        # bcc8 <ST>
    42d4:	48 8b 40 70          	mov    0x70(%rax),%rax
    42d8:	48 8b 44 28 10       	mov    0x10(%rax,%rbp,1),%rax
    42dd:	49 89 45 00          	mov    %rax,0x0(%r13)
            return EFI_SUCCESS;
        }
    }
    return EFI_NOT_FOUND;
}
    42e1:	48 83 c4 08          	add    $0x8,%rsp
            return EFI_SUCCESS;
    42e5:	31 c0                	xor    %eax,%eax
}
    42e7:	5b                   	pop    %rbx
    42e8:	5d                   	pop    %rbp
    42e9:	41 5c                	pop    %r12
    42eb:	41 5d                	pop    %r13
    42ed:	c3                   	ret    
    42ee:	66 90                	xchg   %ax,%ax
    return EFI_NOT_FOUND;
    42f0:	48 b8 0e 00 00 00 00 	movabs $0x800000000000000e,%rax
    42f7:	00 00 80 
}
    42fa:	48 83 c4 08          	add    $0x8,%rsp
    42fe:	5b                   	pop    %rbx
    42ff:	5d                   	pop    %rbp
    4300:	41 5c                	pop    %r12
    4302:	41 5d                	pop    %r13
    4304:	c3                   	ret    
    return EFI_NOT_FOUND;
    4305:	48 b8 0e 00 00 00 00 	movabs $0x800000000000000e,%rax
    430c:	00 00 80 
}
    430f:	c3                   	ret    

0000000000004310 <LibGetUiString>:
    IN  EFI_HANDLE      Handle,
    IN  UI_STRING_TYPE  StringType,
    IN  ISO_639_2       *LangCode,
    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
    )
{
    4310:	f3 0f 1e fa          	endbr64 
    4314:	41 56                	push   %r14
    4316:	41 89 f6             	mov    %esi,%r14d
    4319:	41 55                	push   %r13
    431b:	41 89 cd             	mov    %ecx,%r13d
    UI_INTERFACE    *Ui;
    UI_STRING_TYPE  Index;
    UI_STRING_ENTRY *Array;
    EFI_STATUS      Status;
    
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &UiProtocol, (VOID *)&Ui);
    431e:	48 89 f9             	mov    %rdi,%rcx
{
    4321:	41 54                	push   %r12
    4323:	49 89 fc             	mov    %rdi,%r12
    4326:	55                   	push   %rbp
    4327:	48 89 d5             	mov    %rdx,%rbp
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &UiProtocol, (VOID *)&Ui);
    432a:	48 8d 15 1f 70 00 00 	lea    0x701f(%rip),%rdx        # b350 <gEFiUiInterfaceProtocolGuid>
{
    4331:	53                   	push   %rbx
    4332:	48 83 ec 30          	sub    $0x30,%rsp
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &UiProtocol, (VOID *)&Ui);
    4336:	48 8b 05 83 79 00 00 	mov    0x7983(%rip),%rax        # bcc0 <BS>
    433d:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    4342:	ff 90 98 00 00 00    	call   *0x98(%rax)
    if (EFI_ERROR(Status)) {
    4348:	48 85 c0             	test   %rax,%rax
    434b:	78 48                	js     4395 <LibGetUiString+0x85>
    }

    //
    // Skip the first strings
    //
    for (Index = UiDeviceString, Array = Ui->Entry; Index < StringType; Index++, Array++) {
    434d:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    4352:	48 8b 58 08          	mov    0x8(%rax),%rbx
    4356:	31 c0                	xor    %eax,%eax
    4358:	45 85 f6             	test   %r14d,%r14d
    435b:	75 07                	jne    4364 <LibGetUiString+0x54>
    435d:	eb 2e                	jmp    438d <LibGetUiString+0x7d>
    435f:	90                   	nop
        while (Array->LangCode) {
            Array++;
    4360:	48 83 c3 10          	add    $0x10,%rbx
        while (Array->LangCode) {
    4364:	48 83 3b 00          	cmpq   $0x0,(%rbx)
    4368:	75 f6                	jne    4360 <LibGetUiString+0x50>
    for (Index = UiDeviceString, Array = Ui->Entry; Index < StringType; Index++, Array++) {
    436a:	83 c0 01             	add    $0x1,%eax
    436d:	48 83 c3 10          	add    $0x10,%rbx
    4371:	41 39 c6             	cmp    %eax,%r14d
    4374:	77 ee                	ja     4364 <LibGetUiString+0x54>
    }

    //
    // Search for the match
    //
    while (Array->LangCode) {
    4376:	48 8b 3b             	mov    (%rbx),%rdi
    4379:	48 85 ff             	test   %rdi,%rdi
    437c:	74 17                	je     4395 <LibGetUiString+0x85>
    437e:	66 90                	xchg   %ax,%ax
        if (strcmpa (Array->LangCode, LangCode) == 0) {
    4380:	48 89 ee             	mov    %rbp,%rsi
    4383:	e8 f8 24 00 00       	call   6880 <strcmpa>
    4388:	48 85 c0             	test   %rax,%rax
    438b:	74 39                	je     43c6 <LibGetUiString+0xb6>
    while (Array->LangCode) {
    438d:	48 8b 3b             	mov    (%rbx),%rdi
    4390:	48 85 ff             	test   %rdi,%rdi
    4393:	75 eb                	jne    4380 <LibGetUiString+0x70>
        return (ReturnDevicePathStrOnMismatch) ? DevicePathToStr(DevicePathFromHandle(Handle)) : NULL;
    4395:	31 c0                	xor    %eax,%eax
    4397:	45 84 ed             	test   %r13b,%r13b
    439a:	75 0d                	jne    43a9 <LibGetUiString+0x99>
            return Array->UiString; 
        }
    }
    return (ReturnDevicePathStrOnMismatch) ? DevicePathToStr(DevicePathFromHandle(Handle)) : NULL;
}
    439c:	48 83 c4 30          	add    $0x30,%rsp
    43a0:	5b                   	pop    %rbx
    43a1:	5d                   	pop    %rbp
    43a2:	41 5c                	pop    %r12
    43a4:	41 5d                	pop    %r13
    43a6:	41 5e                	pop    %r14
    43a8:	c3                   	ret    
    return (ReturnDevicePathStrOnMismatch) ? DevicePathToStr(DevicePathFromHandle(Handle)) : NULL;
    43a9:	4c 89 e7             	mov    %r12,%rdi
    43ac:	e8 8f 3b 00 00       	call   7f40 <DevicePathFromHandle>
    43b1:	48 89 c7             	mov    %rax,%rdi
    43b4:	e8 67 42 00 00       	call   8620 <DevicePathToStr>
}
    43b9:	48 83 c4 30          	add    $0x30,%rsp
    43bd:	5b                   	pop    %rbx
    43be:	5d                   	pop    %rbp
    43bf:	41 5c                	pop    %r12
    43c1:	41 5d                	pop    %r13
    43c3:	41 5e                	pop    %r14
    43c5:	c3                   	ret    
            return Array->UiString; 
    43c6:	48 8b 43 08          	mov    0x8(%rbx),%rax
}
    43ca:	48 83 c4 30          	add    $0x30,%rsp
    43ce:	5b                   	pop    %rbx
    43cf:	5d                   	pop    %rbp
    43d0:	41 5c                	pop    %r12
    43d2:	41 5d                	pop    %r13
    43d4:	41 5e                	pop    %r14
    43d6:	c3                   	ret    
    43d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    43de:	00 00 

00000000000043e0 <_DbgOut>:
_DbgOut (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
// Append string worker for DbgPrint
{
    43e0:	f3 0f 1e fa          	endbr64 
    DbgOut = Context;
//    if (!DbgOut && ST && ST->ConOut) {
//        DbgOut = ST->ConOut;
//    }

    if (DbgOut) {
    43e4:	48 85 c9             	test   %rcx,%rcx
    43e7:	74 17                	je     4400 <_DbgOut+0x20>
{
    43e9:	48 83 ec 28          	sub    $0x28,%rsp
	if (IsLocalPrint(DbgOut->OutputString))
		DbgOut->OutputString(DbgOut, Buffer);
    43ed:	ff 51 08             	call   *0x8(%rcx)
        else
		uefi_call_wrapper(DbgOut->OutputString, 2, DbgOut, Buffer);
    }

    return 0;
}
    43f0:	31 c0                	xor    %eax,%eax
    43f2:	48 83 c4 28          	add    $0x28,%rsp
    43f6:	c3                   	ret    
    43f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    43fe:	00 00 
    4400:	31 c0                	xor    %eax,%eax
    4402:	c3                   	ret    
    4403:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    440a:	00 00 00 00 
    440e:	66 90                	xchg   %ax,%ax

0000000000004410 <_SPrint>:
_SPrint (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
// Append string worker for UnicodeSPrint, PoolPrint and CatPrint
{
    4410:	f3 0f 1e fa          	endbr64 
    4414:	41 54                	push   %r12
    4416:	49 89 d4             	mov    %rdx,%r12
    4419:	55                   	push   %rbp
    441a:	48 89 cd             	mov    %rcx,%rbp
    441d:	57                   	push   %rdi
    UINTN           len;
    POOL_PRINT      *spc;

    spc = Context;
    len = StrLen(Buffer);
    441e:	48 89 d7             	mov    %rdx,%rdi
{
    4421:	56                   	push   %rsi
    4422:	53                   	push   %rbx
    4423:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    442a:	0f 29 74 24 20       	movaps %xmm6,0x20(%rsp)
    442f:	0f 29 7c 24 30       	movaps %xmm7,0x30(%rsp)
    4434:	44 0f 29 44 24 40    	movaps %xmm8,0x40(%rsp)
    443a:	44 0f 29 4c 24 50    	movaps %xmm9,0x50(%rsp)
    4440:	44 0f 29 54 24 60    	movaps %xmm10,0x60(%rsp)
    4446:	44 0f 29 5c 24 70    	movaps %xmm11,0x70(%rsp)
    444c:	44 0f 29 a4 24 80 00 	movaps %xmm12,0x80(%rsp)
    4453:	00 00 
    4455:	44 0f 29 ac 24 90 00 	movaps %xmm13,0x90(%rsp)
    445c:	00 00 
    445e:	44 0f 29 b4 24 a0 00 	movaps %xmm14,0xa0(%rsp)
    4465:	00 00 
    4467:	44 0f 29 bc 24 b0 00 	movaps %xmm15,0xb0(%rsp)
    446e:	00 00 
    len = StrLen(Buffer);
    4470:	e8 6b 23 00 00       	call   67e0 <StrLen>

    //
    // Is the string is over the max truncate it
    //

    if (spc->len + len > spc->maxlen) {
    4475:	48 8b 55 10          	mov    0x10(%rbp),%rdx
    len = StrLen(Buffer);
    4479:	48 89 c3             	mov    %rax,%rbx
    if (spc->len + len > spc->maxlen) {
    447c:	48 8b 45 08          	mov    0x8(%rbp),%rax
        len = spc->maxlen - spc->len;
    4480:	48 89 d1             	mov    %rdx,%rcx
    if (spc->len + len > spc->maxlen) {
    4483:	4c 8d 04 18          	lea    (%rax,%rbx,1),%r8
        len = spc->maxlen - spc->len;
    4487:	48 29 c1             	sub    %rax,%rcx
    448a:	49 39 d0             	cmp    %rdx,%r8

    //
    // Append the new text
    //

    CopyMem (spc->str + spc->len, Buffer, len * sizeof(CHAR16));
    448d:	48 8b 55 00          	mov    0x0(%rbp),%rdx
        len = spc->maxlen - spc->len;
    4491:	48 0f 47 d9          	cmova  %rcx,%rbx
    CopyMem (spc->str + spc->len, Buffer, len * sizeof(CHAR16));
    4495:	48 8d 0c 42          	lea    (%rdx,%rax,2),%rcx
    4499:	4c 89 e2             	mov    %r12,%rdx
    449c:	4c 8d 04 1b          	lea    (%rbx,%rbx,1),%r8
    44a0:	e8 0b f6 ff ff       	call   3ab0 <CopyMem>

    //
    // Null terminate it
    //

    if (spc->len < spc->maxlen) {
    44a5:	48 8b 45 10          	mov    0x10(%rbp),%rax
    spc->len += len;
    44a9:	48 03 5d 08          	add    0x8(%rbp),%rbx
    44ad:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
    if (spc->len < spc->maxlen) {
    44b1:	48 39 c3             	cmp    %rax,%rbx
    44b4:	73 6a                	jae    4520 <_SPrint+0x110>
        spc->str[spc->len] = 0;
    44b6:	48 8b 45 00          	mov    0x0(%rbp),%rax
    44ba:	45 31 c0             	xor    %r8d,%r8d
    44bd:	66 44 89 04 58       	mov    %r8w,(%rax,%rbx,2)
    } else if (spc->maxlen) {
        spc->str[spc->maxlen] = 0;
    }

    return 0;
}
    44c2:	0f 28 74 24 20       	movaps 0x20(%rsp),%xmm6
    44c7:	0f 28 7c 24 30       	movaps 0x30(%rsp),%xmm7
    44cc:	31 c0                	xor    %eax,%eax
    44ce:	44 0f 28 44 24 40    	movaps 0x40(%rsp),%xmm8
    44d4:	44 0f 28 4c 24 50    	movaps 0x50(%rsp),%xmm9
    44da:	44 0f 28 54 24 60    	movaps 0x60(%rsp),%xmm10
    44e0:	44 0f 28 5c 24 70    	movaps 0x70(%rsp),%xmm11
    44e6:	44 0f 28 a4 24 80 00 	movaps 0x80(%rsp),%xmm12
    44ed:	00 00 
    44ef:	44 0f 28 ac 24 90 00 	movaps 0x90(%rsp),%xmm13
    44f6:	00 00 
    44f8:	44 0f 28 b4 24 a0 00 	movaps 0xa0(%rsp),%xmm14
    44ff:	00 00 
    4501:	44 0f 28 bc 24 b0 00 	movaps 0xb0(%rsp),%xmm15
    4508:	00 00 
    450a:	48 81 c4 c0 00 00 00 	add    $0xc0,%rsp
    4511:	5b                   	pop    %rbx
    4512:	5e                   	pop    %rsi
    4513:	5f                   	pop    %rdi
    4514:	5d                   	pop    %rbp
    4515:	41 5c                	pop    %r12
    4517:	c3                   	ret    
    4518:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    451f:	00 
    } else if (spc->maxlen) {
    4520:	48 85 c0             	test   %rax,%rax
    4523:	74 9d                	je     44c2 <_SPrint+0xb2>
        spc->str[spc->maxlen] = 0;
    4525:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    4529:	31 c9                	xor    %ecx,%ecx
    452b:	66 89 0c 42          	mov    %cx,(%rdx,%rax,2)
    452f:	eb 91                	jmp    44c2 <_SPrint+0xb2>
    4531:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4538:	00 00 00 00 
    453c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004540 <_PoolPrint>:
_PoolPrint (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
// Append string worker for PoolPrint and CatPrint
{
    4540:	f3 0f 1e fa          	endbr64 
    4544:	41 55                	push   %r13
    4546:	49 89 d5             	mov    %rdx,%r13
    4549:	41 54                	push   %r12
    454b:	49 89 cc             	mov    %rcx,%r12
    454e:	57                   	push   %rdi
    UINTN           newlen;
    POOL_PRINT      *spc;

    spc = Context;
    newlen = spc->len + StrLen(Buffer) + 1;
    454f:	48 89 d7             	mov    %rdx,%rdi
{
    4552:	56                   	push   %rsi
    4553:	53                   	push   %rbx
    4554:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    455b:	0f 29 34 24          	movaps %xmm6,(%rsp)
    455f:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    4564:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    456a:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    4570:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    4576:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    457c:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    4582:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    4588:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    458f:	00 00 
    4591:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    4598:	00 00 
    newlen = spc->len + StrLen(Buffer) + 1;
    459a:	48 8b 59 08          	mov    0x8(%rcx),%rbx
    459e:	e8 3d 22 00 00       	call   67e0 <StrLen>
    45a3:	48 01 d8             	add    %rbx,%rax
    45a6:	48 8d 50 01          	lea    0x1(%rax),%rdx

    //
    // Is the string is over the max, grow the buffer
    //

    if (newlen > spc->maxlen) {
    45aa:	49 39 54 24 10       	cmp    %rdx,0x10(%r12)
    45af:	72 5f                	jb     4610 <_PoolPrint+0xd0>
    //
    // Append the new text
    //

    return _SPrint (Context, Buffer);
}
    45b1:	0f 28 34 24          	movaps (%rsp),%xmm6
    45b5:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    return _SPrint (Context, Buffer);
    45ba:	4c 89 ea             	mov    %r13,%rdx
    45bd:	4c 89 e1             	mov    %r12,%rcx
}
    45c0:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    45c6:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    45cc:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    45d2:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    45d8:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    45de:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    45e4:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    45eb:	00 00 
    45ed:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    45f4:	00 00 
    45f6:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    45fd:	5b                   	pop    %rbx
    45fe:	5e                   	pop    %rsi
    45ff:	5f                   	pop    %rdi
    4600:	41 5c                	pop    %r12
    4602:	41 5d                	pop    %r13
    return _SPrint (Context, Buffer);
    4604:	e9 07 fe ff ff       	jmp    4410 <_SPrint>
    4609:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        newlen += PRINT_STRING_LEN;
    4610:	48 05 c9 00 00 00    	add    $0xc9,%rax
        spc->str = ReallocatePool (
    4616:	49 8b 3c 24          	mov    (%r12),%rdi
        spc->maxlen = newlen;
    461a:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        spc->str = ReallocatePool (
    461f:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
    4623:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4628:	48 8d 34 00          	lea    (%rax,%rax,1),%rsi
    462c:	e8 0f f3 ff ff       	call   3940 <ReallocatePool>
    4631:	49 89 04 24          	mov    %rax,(%r12)
        if (!spc->str) {
    4635:	48 85 c0             	test   %rax,%rax
    4638:	0f 85 73 ff ff ff    	jne    45b1 <_PoolPrint+0x71>
            spc->len = 0;
    463e:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
    4645:	00 00 
            spc->maxlen = 0;
    4647:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
    464e:	00 00 
    4650:	e9 5c ff ff ff       	jmp    45b1 <_PoolPrint+0x71>
    4655:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    465c:	00 00 00 00 

0000000000004660 <ValueToHex.part.0>:

STATIC CHAR8 Hex[] = {'0','1','2','3','4','5','6','7',
                      '8','9','A','B','C','D','E','F'};

VOID
ValueToHex (
    4660:	41 56                	push   %r14
    4662:	41 55                	push   %r13
    4664:	41 54                	push   %r12
    4666:	55                   	push   %rbp
    4667:	48 89 fd             	mov    %rdi,%rbp
    466a:	53                   	push   %rbx
    466b:	48 83 ec 20          	sub    $0x20,%rsp
    }

    p1 = str;
    p2 = Buffer;

    while (v) {
    466f:	48 85 f6             	test   %rsi,%rsi
    4672:	74 69                	je     46dd <ValueToHex.part.0+0x7d>
    p1 = str;
    4674:	49 89 e4             	mov    %rsp,%r12
    4677:	48 89 f7             	mov    %rsi,%rdi
    467a:	4c 8d 2d 3f 71 00 00 	lea    0x713f(%rip),%r13        # b7c0 <Hex>
    4681:	4d 89 e6             	mov    %r12,%r14
    4684:	0f 1f 40 00          	nopl   0x0(%rax)
        // Without the cast, the MSVC compiler may insert a reference to __allmull
        *(p1++) = Hex[(UINTN)(v & 0xf)];
    4688:	48 89 f8             	mov    %rdi,%rax
    468b:	49 83 c6 01          	add    $0x1,%r14
        v = RShiftU64 (v, 4);
    468f:	be 04 00 00 00       	mov    $0x4,%esi
        *(p1++) = Hex[(UINTN)(v & 0xf)];
    4694:	83 e0 0f             	and    $0xf,%eax
    4697:	41 0f b6 5c 05 00    	movzbl 0x0(%r13,%rax,1),%ebx
    469d:	41 88 5e ff          	mov    %bl,-0x1(%r14)
        v = RShiftU64 (v, 4);
    46a1:	e8 3a 2a 00 00       	call   70e0 <RShiftU64>
    46a6:	48 89 c7             	mov    %rax,%rdi
    while (v) {
    46a9:	48 85 c0             	test   %rax,%rax
    46ac:	75 da                	jne    4688 <ValueToHex.part.0+0x28>
    }

    while (p1 != str) {
    46ae:	4d 39 e6             	cmp    %r12,%r14
    46b1:	74 2a                	je     46dd <ValueToHex.part.0+0x7d>
    p2 = Buffer;
    46b3:	48 89 ea             	mov    %rbp,%rdx
    while (p1 != str) {
    46b6:	4c 89 f0             	mov    %r14,%rax
    46b9:	eb 09                	jmp    46c4 <ValueToHex.part.0+0x64>
    46bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        *(p2++) = *(--p1);
    46c0:	0f b6 58 ff          	movzbl -0x1(%rax),%ebx
    46c4:	48 83 e8 01          	sub    $0x1,%rax
    46c8:	48 83 c2 02          	add    $0x2,%rdx
    46cc:	66 89 5a fe          	mov    %bx,-0x2(%rdx)
    while (p1 != str) {
    46d0:	4c 39 e0             	cmp    %r12,%rax
    46d3:	75 eb                	jne    46c0 <ValueToHex.part.0+0x60>
        *(p2++) = *(--p1);
    46d5:	49 29 c6             	sub    %rax,%r14
    46d8:	4a 8d 6c 75 00       	lea    0x0(%rbp,%r14,2),%rbp
    }
    *p2 = 0;
    46dd:	31 c0                	xor    %eax,%eax
    46df:	66 89 45 00          	mov    %ax,0x0(%rbp)
}
    46e3:	48 83 c4 20          	add    $0x20,%rsp
    46e7:	5b                   	pop    %rbx
    46e8:	5d                   	pop    %rbp
    46e9:	41 5c                	pop    %r12
    46eb:	41 5d                	pop    %r13
    46ed:	41 5e                	pop    %r14
    46ef:	c3                   	ret    

00000000000046f0 <IsLocalPrint>:
{
    46f0:	f3 0f 1e fa          	endbr64 
	if (func == _DbgOut || func == _SPrint || func == _PoolPrint)
    46f4:	48 8d 05 e5 fc ff ff 	lea    -0x31b(%rip),%rax        # 43e0 <_DbgOut>
    46fb:	48 8d 15 0e fd ff ff 	lea    -0x2f2(%rip),%rdx        # 4410 <_SPrint>
    4702:	48 39 c7             	cmp    %rax,%rdi
    4705:	0f 94 c0             	sete   %al
    4708:	48 39 d7             	cmp    %rdx,%rdi
    470b:	0f 94 c2             	sete   %dl
		return 1;
    470e:	09 d0                	or     %edx,%eax
	if (func == _DbgOut || func == _SPrint || func == _PoolPrint)
    4710:	48 8d 15 29 fe ff ff 	lea    -0x1d7(%rip),%rdx        # 4540 <_PoolPrint>
    4717:	48 39 d7             	cmp    %rdx,%rdi
    471a:	0f 94 c2             	sete   %dl
		return 1;
    471d:	09 d0                	or     %edx,%eax
    471f:	0f b6 c0             	movzbl %al,%eax
}
    4722:	c3                   	ret    
    4723:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    472a:	00 00 00 00 
    472e:	66 90                	xchg   %ax,%ax

0000000000004730 <PFLUSH>:
{
    4730:	f3 0f 1e fa          	endbr64 
    4734:	53                   	push   %rbx
    *ps->Pos = 0;
    4735:	31 d2                	xor    %edx,%edx
{
    4737:	48 89 fb             	mov    %rdi,%rbx
    473a:	48 83 ec 20          	sub    $0x20,%rsp
    *ps->Pos = 0;
    473e:	48 8b 47 40          	mov    0x40(%rdi),%rax
    4742:	66 89 10             	mov    %dx,(%rax)
	ps->Output(ps->Context, ps->Buffer);
    4745:	48 8b 57 30          	mov    0x30(%rdi),%rdx
    4749:	48 8b 8f 88 00 00 00 	mov    0x88(%rdi),%rcx
    4750:	ff 57 78             	call   *0x78(%rdi)
    ps->Pos = ps->Buffer;
    4753:	48 8b 43 30          	mov    0x30(%rbx),%rax
    4757:	48 89 43 40          	mov    %rax,0x40(%rbx)
}
    475b:	48 83 c4 20          	add    $0x20,%rsp
    475f:	5b                   	pop    %rbx
    4760:	c3                   	ret    
    4761:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4768:	00 00 00 00 
    476c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004770 <PSETATTR>:
{
    4770:	f3 0f 1e fa          	endbr64 
    4774:	55                   	push   %rbp
    4775:	48 89 f5             	mov    %rsi,%rbp
    4778:	53                   	push   %rbx
    4779:	48 89 fb             	mov    %rdi,%rbx
    477c:	48 83 ec 28          	sub    $0x28,%rsp
   PFLUSH (ps);
    4780:	e8 ab ff ff ff       	call   4730 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    4785:	48 8b 43 50          	mov    0x50(%rbx),%rax
    4789:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    478d:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    4794:	48 85 c0             	test   %rax,%rax
    4797:	74 0c                	je     47a5 <PSETATTR+0x35>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    4799:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    47a0:	48 89 ea             	mov    %rbp,%rdx
    47a3:	ff d0                	call   *%rax
   ps->Attr = Attr;
    47a5:	48 89 6b 50          	mov    %rbp,0x50(%rbx)
}
    47a9:	48 83 c4 28          	add    $0x28,%rsp
    47ad:	5b                   	pop    %rbx
    47ae:	5d                   	pop    %rbp
    47af:	c3                   	ret    

00000000000047b0 <PPUTC>:
{
    47b0:	f3 0f 1e fa          	endbr64 
    47b4:	48 83 ec 18          	sub    $0x18,%rsp
    *ps->Pos = c;
    47b8:	48 8b 47 40          	mov    0x40(%rdi),%rax
    if (c == '\n') {
    47bc:	66 83 fe 0a          	cmp    $0xa,%si
    47c0:	74 36                	je     47f8 <PPUTC+0x48>
    *ps->Pos = c;
    47c2:	66 89 30             	mov    %si,(%rax)
    ps->Pos += 1;
    47c5:	48 8b 47 40          	mov    0x40(%rdi),%rax
    ps->Len += 1;
    47c9:	48 83 47 48 01       	addq   $0x1,0x48(%rdi)
    ps->Pos += 1;
    47ce:	48 83 c0 02          	add    $0x2,%rax
    47d2:	48 89 47 40          	mov    %rax,0x40(%rdi)
    if (ps->Pos >= ps->End) {
    47d6:	48 3b 47 38          	cmp    0x38(%rdi),%rax
    47da:	73 0c                	jae    47e8 <PPUTC+0x38>
}
    47dc:	48 83 c4 18          	add    $0x18,%rsp
    47e0:	c3                   	ret    
    47e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    47e8:	48 83 c4 18          	add    $0x18,%rsp
        PFLUSH(ps);
    47ec:	e9 3f ff ff ff       	jmp    4730 <PFLUSH>
    47f1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    *ps->Pos = c;
    47f8:	ba 0d 00 00 00       	mov    $0xd,%edx
    47fd:	66 89 10             	mov    %dx,(%rax)
    ps->Pos += 1;
    4800:	48 8b 47 40          	mov    0x40(%rdi),%rax
    ps->Len += 1;
    4804:	48 83 47 48 01       	addq   $0x1,0x48(%rdi)
    ps->Pos += 1;
    4809:	48 83 c0 02          	add    $0x2,%rax
    480d:	48 89 47 40          	mov    %rax,0x40(%rdi)
    if (ps->Pos >= ps->End) {
    4811:	48 3b 47 38          	cmp    0x38(%rdi),%rax
    4815:	72 ab                	jb     47c2 <PPUTC+0x12>
    4817:	89 74 24 0c          	mov    %esi,0xc(%rsp)
        PFLUSH(ps);
    481b:	48 89 3c 24          	mov    %rdi,(%rsp)
    481f:	e8 0c ff ff ff       	call   4730 <PFLUSH>
    *ps->Pos = c;
    4824:	48 8b 3c 24          	mov    (%rsp),%rdi
    4828:	8b 74 24 0c          	mov    0xc(%rsp),%esi
    482c:	48 8b 47 40          	mov    0x40(%rdi),%rax
    4830:	eb 90                	jmp    47c2 <PPUTC+0x12>
    4832:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4839:	00 00 00 00 
    483d:	0f 1f 00             	nopl   (%rax)

0000000000004840 <PGETC>:
{
    4840:	f3 0f 1e fa          	endbr64 
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    4844:	80 3f 00             	cmpb   $0x0,(%rdi)
    4847:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    484b:	48 8b 47 08          	mov    0x8(%rdi),%rax
    484f:	74 17                	je     4868 <PGETC+0x28>
    4851:	44 0f b6 04 02       	movzbl (%rdx,%rax,1),%r8d
    p->Index += 1;
    4856:	48 83 c0 01          	add    $0x1,%rax
    485a:	48 89 47 08          	mov    %rax,0x8(%rdi)
}
    485e:	44 89 c0             	mov    %r8d,%eax
    4861:	c3                   	ret    
    4862:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    4868:	44 0f b7 04 42       	movzwl (%rdx,%rax,2),%r8d
    p->Index += 1;
    486d:	48 83 c0 01          	add    $0x1,%rax
    4871:	48 89 47 08          	mov    %rax,0x8(%rdi)
}
    4875:	44 89 c0             	mov    %r8d,%eax
    4878:	c3                   	ret    
    4879:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000004880 <PITEM>:
{
    4880:	f3 0f 1e fa          	endbr64 
    4884:	41 56                	push   %r14
    4886:	41 55                	push   %r13
    4888:	41 54                	push   %r12
    while (Item->Item.Index < Item->FieldWidth) {
    488a:	45 31 e4             	xor    %r12d,%r12d
{
    488d:	55                   	push   %rbp
    488e:	53                   	push   %rbx
    Item = ps->Item;
    488f:	48 8b af 90 00 00 00 	mov    0x90(%rdi),%rbp
{
    4896:	48 89 fb             	mov    %rdi,%rbx
    Item->Item.Index = 0;
    4899:	48 c7 45 08 00 00 00 	movq   $0x0,0x8(%rbp)
    48a0:	00 
    while (Item->Item.Index < Item->FieldWidth) {
    48a1:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx
    48a8:	eb 1c                	jmp    48c6 <PITEM+0x46>
    48aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    48b0:	42 0f b6 14 20       	movzbl (%rax,%r12,1),%edx
    p->Index += 1;
    48b5:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    48ba:	48 89 45 08          	mov    %rax,0x8(%rbp)
        if (!c) {
    48be:	66 85 d2             	test   %dx,%dx
    48c1:	74 25                	je     48e8 <PITEM+0x68>
    48c3:	49 89 c4             	mov    %rax,%r12
    while (Item->Item.Index < Item->FieldWidth) {
    48c6:	4c 39 e1             	cmp    %r12,%rcx
    48c9:	74 21                	je     48ec <PITEM+0x6c>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    48cb:	80 7d 00 00          	cmpb   $0x0,0x0(%rbp)
    48cf:	48 8b 45 10          	mov    0x10(%rbp),%rax
    48d3:	75 db                	jne    48b0 <PITEM+0x30>
    48d5:	42 0f b7 14 60       	movzwl (%rax,%r12,2),%edx
    p->Index += 1;
    48da:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    48df:	48 89 45 08          	mov    %rax,0x8(%rbp)
        if (!c) {
    48e3:	66 85 d2             	test   %dx,%dx
    48e6:	75 db                	jne    48c3 <PITEM+0x43>
            Item->Item.Index -= 1;
    48e8:	4c 89 65 08          	mov    %r12,0x8(%rbp)
    if (Item->FieldWidth == (UINTN) -1) {
    48ec:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
    48f0:	75 07                	jne    48f9 <PITEM+0x79>
        Item->FieldWidth = Len;
    48f2:	4c 89 a5 e8 00 00 00 	mov    %r12,0xe8(%rbp)
    if (Len > Item->Width) {
    48f9:	4c 8b ad e0 00 00 00 	mov    0xe0(%rbp),%r13
    if (Item->PadBefore) {
    4900:	0f b6 85 fa 00 00 00 	movzbl 0xfa(%rbp),%eax
    if (Len > Item->Width) {
    4907:	4d 39 e5             	cmp    %r12,%r13
    490a:	0f 83 d8 01 00 00    	jae    4ae8 <PITEM+0x268>
        Item->Width = Len;
    4910:	4c 89 a5 e0 00 00 00 	mov    %r12,0xe0(%rbp)
    if (Item->PadBefore) {
    4917:	84 c0                	test   %al,%al
    4919:	0f 84 c5 00 00 00    	je     49e4 <PITEM+0x164>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    491f:	4c 3b a5 e8 00 00 00 	cmp    0xe8(%rbp),%r12
    4926:	0f 83 b8 00 00 00    	jae    49e4 <PITEM+0x164>
    492c:	4d 89 e5             	mov    %r12,%r13
    492f:	eb 14                	jmp    4945 <PITEM+0xc5>
    4931:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    4938:	49 83 c5 01          	add    $0x1,%r13
    493c:	4c 39 ad e8 00 00 00 	cmp    %r13,0xe8(%rbp)
    4943:	76 38                	jbe    497d <PITEM+0xfd>
    *ps->Pos = c;
    4945:	48 8b 43 40          	mov    0x40(%rbx),%rax
    4949:	bf 20 00 00 00       	mov    $0x20,%edi
    494e:	66 89 38             	mov    %di,(%rax)
    ps->Pos += 1;
    4951:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    4955:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    495a:	48 83 c0 02          	add    $0x2,%rax
    495e:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    4962:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    4966:	72 d0                	jb     4938 <PITEM+0xb8>
        PFLUSH(ps);
    4968:	48 89 df             	mov    %rbx,%rdi
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    496b:	49 83 c5 01          	add    $0x1,%r13
        PFLUSH(ps);
    496f:	e8 bc fd ff ff       	call   4730 <PFLUSH>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    4974:	4c 39 ad e8 00 00 00 	cmp    %r13,0xe8(%rbp)
    497b:	77 c8                	ja     4945 <PITEM+0xc5>
    for (i=Len; i < Item->Width; i++) {
    497d:	4c 8b ad e0 00 00 00 	mov    0xe0(%rbp),%r13
    4984:	4d 39 ec             	cmp    %r13,%r12
    4987:	73 5b                	jae    49e4 <PITEM+0x164>
    4989:	4d 89 e5             	mov    %r12,%r13
    498c:	eb 0f                	jmp    499d <PITEM+0x11d>
    498e:	66 90                	xchg   %ax,%ax
    4990:	49 83 c5 01          	add    $0x1,%r13
    4994:	4c 39 ad e0 00 00 00 	cmp    %r13,0xe0(%rbp)
    499b:	76 47                	jbe    49e4 <PITEM+0x164>
        PPUTC (ps, Item->Pad);
    499d:	44 0f b7 b5 f8 00 00 	movzwl 0xf8(%rbp),%r14d
    49a4:	00 
    *ps->Pos = c;
    49a5:	48 8b 43 40          	mov    0x40(%rbx),%rax
    if (c == '\n') {
    49a9:	66 41 83 fe 0a       	cmp    $0xa,%r14w
    49ae:	0f 84 54 01 00 00    	je     4b08 <PITEM+0x288>
    *ps->Pos = c;
    49b4:	66 44 89 30          	mov    %r14w,(%rax)
    ps->Pos += 1;
    49b8:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    49bc:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    49c1:	48 83 c0 02          	add    $0x2,%rax
    49c5:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    49c9:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    49cd:	72 c1                	jb     4990 <PITEM+0x110>
        PFLUSH(ps);
    49cf:	48 89 df             	mov    %rbx,%rdi
    for (i=Len; i < Item->Width; i++) {
    49d2:	49 83 c5 01          	add    $0x1,%r13
        PFLUSH(ps);
    49d6:	e8 55 fd ff ff       	call   4730 <PFLUSH>
    for (i=Len; i < Item->Width; i++) {
    49db:	4c 39 ad e0 00 00 00 	cmp    %r13,0xe0(%rbp)
    49e2:	77 b9                	ja     499d <PITEM+0x11d>
    Item->Item.Index=0;
    49e4:	48 c7 45 08 00 00 00 	movq   $0x0,0x8(%rbp)
    49eb:	00 
    while (Item->Item.Index < Len) {
    49ec:	31 c0                	xor    %eax,%eax
    49ee:	eb 37                	jmp    4a27 <PITEM+0x1a7>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    49f0:	44 0f b6 2c 02       	movzbl (%rdx,%rax,1),%r13d
    p->Index += 1;
    49f5:	48 83 c0 01          	add    $0x1,%rax
    49f9:	48 89 45 08          	mov    %rax,0x8(%rbp)
    *ps->Pos = c;
    49fd:	48 8b 43 40          	mov    0x40(%rbx),%rax
    if (c == '\n') {
    4a01:	66 41 83 fd 0a       	cmp    $0xa,%r13w
    4a06:	74 48                	je     4a50 <PITEM+0x1d0>
    *ps->Pos = c;
    4a08:	66 44 89 28          	mov    %r13w,(%rax)
    ps->Pos += 1;
    4a0c:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    4a10:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    4a15:	48 83 c0 02          	add    $0x2,%rax
    4a19:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    4a1d:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    4a21:	73 1d                	jae    4a40 <PITEM+0x1c0>
    while (Item->Item.Index < Len) {
    4a23:	48 8b 45 08          	mov    0x8(%rbp),%rax
    4a27:	4c 39 e0             	cmp    %r12,%rax
    4a2a:	73 54                	jae    4a80 <PITEM+0x200>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    4a2c:	80 7d 00 00          	cmpb   $0x0,0x0(%rbp)
    4a30:	48 8b 55 10          	mov    0x10(%rbp),%rdx
    4a34:	75 ba                	jne    49f0 <PITEM+0x170>
    4a36:	44 0f b7 2c 42       	movzwl (%rdx,%rax,2),%r13d
    4a3b:	eb b8                	jmp    49f5 <PITEM+0x175>
    4a3d:	0f 1f 00             	nopl   (%rax)
        PFLUSH(ps);
    4a40:	48 89 df             	mov    %rbx,%rdi
    4a43:	e8 e8 fc ff ff       	call   4730 <PFLUSH>
    4a48:	eb d9                	jmp    4a23 <PITEM+0x1a3>
    4a4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    *ps->Pos = c;
    4a50:	b9 0d 00 00 00       	mov    $0xd,%ecx
    4a55:	66 89 08             	mov    %cx,(%rax)
    ps->Pos += 1;
    4a58:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    4a5c:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    4a61:	48 83 c0 02          	add    $0x2,%rax
    4a65:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    4a69:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    4a6d:	72 99                	jb     4a08 <PITEM+0x188>
        PFLUSH(ps);
    4a6f:	48 89 df             	mov    %rbx,%rdi
    4a72:	e8 b9 fc ff ff       	call   4730 <PFLUSH>
    *ps->Pos = c;
    4a77:	48 8b 43 40          	mov    0x40(%rbx),%rax
    4a7b:	eb 8b                	jmp    4a08 <PITEM+0x188>
    4a7d:	0f 1f 00             	nopl   (%rax)
    if (!Item->PadBefore) {
    4a80:	80 bd fa 00 00 00 00 	cmpb   $0x0,0xfa(%rbp)
    4a87:	75 10                	jne    4a99 <PITEM+0x219>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    4a89:	4c 8b a5 e0 00 00 00 	mov    0xe0(%rbp),%r12
    4a90:	4c 3b a5 e8 00 00 00 	cmp    0xe8(%rbp),%r12
    4a97:	72 24                	jb     4abd <PITEM+0x23d>
}
    4a99:	5b                   	pop    %rbx
    4a9a:	5d                   	pop    %rbp
    4a9b:	41 5c                	pop    %r12
    4a9d:	41 5d                	pop    %r13
    4a9f:	41 5e                	pop    %r14
    4aa1:	c3                   	ret    
    4aa2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        PFLUSH(ps);
    4aa8:	48 89 df             	mov    %rbx,%rdi
    4aab:	e8 80 fc ff ff       	call   4730 <PFLUSH>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    4ab0:	49 83 c4 01          	add    $0x1,%r12
    4ab4:	4c 39 a5 e8 00 00 00 	cmp    %r12,0xe8(%rbp)
    4abb:	76 dc                	jbe    4a99 <PITEM+0x219>
    *ps->Pos = c;
    4abd:	48 8b 43 40          	mov    0x40(%rbx),%rax
    4ac1:	ba 20 00 00 00       	mov    $0x20,%edx
    4ac6:	66 89 10             	mov    %dx,(%rax)
    ps->Pos += 1;
    4ac9:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    4acd:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    4ad2:	48 83 c0 02          	add    $0x2,%rax
    4ad6:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    4ada:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    4ade:	72 d0                	jb     4ab0 <PITEM+0x230>
    4ae0:	eb c6                	jmp    4aa8 <PITEM+0x228>
    4ae2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (Item->PadBefore) {
    4ae8:	84 c0                	test   %al,%al
    4aea:	0f 84 94 fe ff ff    	je     4984 <PITEM+0x104>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    4af0:	4c 39 ad e8 00 00 00 	cmp    %r13,0xe8(%rbp)
    4af7:	0f 86 87 fe ff ff    	jbe    4984 <PITEM+0x104>
    4afd:	e9 43 fe ff ff       	jmp    4945 <PITEM+0xc5>
    4b02:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    *ps->Pos = c;
    4b08:	be 0d 00 00 00       	mov    $0xd,%esi
    4b0d:	66 89 30             	mov    %si,(%rax)
    ps->Pos += 1;
    4b10:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    4b14:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    4b19:	48 83 c0 02          	add    $0x2,%rax
    4b1d:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    4b21:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    4b25:	0f 82 89 fe ff ff    	jb     49b4 <PITEM+0x134>
        PFLUSH(ps);
    4b2b:	48 89 df             	mov    %rbx,%rdi
    4b2e:	e8 fd fb ff ff       	call   4730 <PFLUSH>
    *ps->Pos = c;
    4b33:	48 8b 43 40          	mov    0x40(%rbx),%rax
    4b37:	e9 78 fe ff ff       	jmp    49b4 <PITEM+0x134>
    4b3c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004b40 <ValueToHex>:
{
    4b40:	f3 0f 1e fa          	endbr64 
    if (!v) {
    4b44:	48 85 f6             	test   %rsi,%rsi
    4b47:	74 07                	je     4b50 <ValueToHex+0x10>
    4b49:	e9 12 fb ff ff       	jmp    4660 <ValueToHex.part.0>
    4b4e:	66 90                	xchg   %ax,%ax
        Buffer[0] = '0';
    4b50:	c7 07 30 00 00 00    	movl   $0x30,(%rdi)
}
    4b56:	c3                   	ret    
    4b57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    4b5e:	00 00 

0000000000004b60 <ValueToString>:
ValueToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN INT64    v
    )
{
    4b60:	f3 0f 1e fa          	endbr64 
    4b64:	41 56                	push   %r14
    4b66:	49 89 fe             	mov    %rdi,%r14
    STATIC CHAR8 ca[] = {  3, 1, 2 };
    4b69:	bf 03 01 00 00       	mov    $0x103,%edi
{
    4b6e:	41 55                	push   %r13
    4b70:	41 54                	push   %r12
    4b72:	55                   	push   %rbp
    4b73:	53                   	push   %rbx
    4b74:	48 83 ec 40          	sub    $0x40,%rsp
    STATIC CHAR8 ca[] = {  3, 1, 2 };
    4b78:	66 89 7c 24 05       	mov    %di,0x5(%rsp)
    4b7d:	c6 44 24 07 02       	movb   $0x2,0x7(%rsp)
    CHAR8        str[40], *p1;
    CHAR16       *p2;
    UINTN        c, r;

    if (!v) {
    4b82:	48 85 d2             	test   %rdx,%rdx
    4b85:	0f 84 f5 00 00 00    	je     4c80 <ValueToString+0x120>
    4b8b:	41 89 f5             	mov    %esi,%r13d
    4b8e:	48 89 d7             	mov    %rdx,%rdi
    }

    p1 = str;
    p2 = Buffer;

    if (v < 0) {
    4b91:	0f 88 d1 00 00 00    	js     4c68 <ValueToString+0x108>
{
    4b97:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
    4b9c:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
    4ba1:	48 89 eb             	mov    %rbp,%rbx
    4ba4:	0f 1f 40 00          	nopl   0x0(%rax)
        *(p2++) = '-';
        v = -v;
    }

    while (v) {
        v = (INT64)DivU64x32 ((UINT64)v, 10, &r);
    4ba8:	4c 89 e2             	mov    %r12,%rdx
    4bab:	be 0a 00 00 00       	mov    $0xa,%esi
        *(p1++) = (CHAR8)r + '0';
    4bb0:	48 83 c3 01          	add    $0x1,%rbx
        v = (INT64)DivU64x32 ((UINT64)v, 10, &r);
    4bb4:	e8 47 25 00 00       	call   7100 <DivU64x32>
    4bb9:	48 89 c7             	mov    %rax,%rdi
        *(p1++) = (CHAR8)r + '0';
    4bbc:	0f b6 44 24 08       	movzbl 0x8(%rsp),%eax
    4bc1:	8d 48 30             	lea    0x30(%rax),%ecx
    4bc4:	88 4b ff             	mov    %cl,-0x1(%rbx)
    while (v) {
    4bc7:	48 85 ff             	test   %rdi,%rdi
    4bca:	75 dc                	jne    4ba8 <ValueToString+0x48>
    }

    c = (UINTN) (Comma ? ca[(p1 - str) % 3] : 999) + 1;
    4bcc:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    4bd1:	45 84 ed             	test   %r13b,%r13b
    4bd4:	75 5a                	jne    4c30 <ValueToString+0xd0>
    while (p1 != str) {
    4bd6:	48 39 eb             	cmp    %rbp,%rbx
    4bd9:	75 0c                	jne    4be7 <ValueToString+0x87>
    4bdb:	e9 b8 00 00 00       	jmp    4c98 <ValueToString+0x138>
        if (!c) {
            *(p2++) = ',';
            c = 3;
        }

        *(p2++) = *(--p1);
    4be0:	0f b6 4b ff          	movzbl -0x1(%rbx),%ecx
    4be4:	49 89 d6             	mov    %rdx,%r14
        if (!c) {
    4be7:	48 83 e8 01          	sub    $0x1,%rax
    4beb:	75 13                	jne    4c00 <ValueToString+0xa0>
            *(p2++) = ',';
    4bed:	ba 2c 00 00 00       	mov    $0x2c,%edx
    4bf2:	49 83 c6 02          	add    $0x2,%r14
            c = 3;
    4bf6:	b8 03 00 00 00       	mov    $0x3,%eax
            *(p2++) = ',';
    4bfb:	66 41 89 56 fe       	mov    %dx,-0x2(%r14)
        *(p2++) = *(--p1);
    4c00:	0f b6 c9             	movzbl %cl,%ecx
    4c03:	48 83 eb 01          	sub    $0x1,%rbx
    4c07:	49 8d 56 02          	lea    0x2(%r14),%rdx
    4c0b:	66 41 89 0e          	mov    %cx,(%r14)
    while (p1 != str) {
    4c0f:	48 39 eb             	cmp    %rbp,%rbx
    4c12:	75 cc                	jne    4be0 <ValueToString+0x80>
    }
    *p2 = 0;
    4c14:	31 c0                	xor    %eax,%eax
    4c16:	66 89 02             	mov    %ax,(%rdx)
}
    4c19:	48 83 c4 40          	add    $0x40,%rsp
    4c1d:	5b                   	pop    %rbx
    4c1e:	5d                   	pop    %rbp
    4c1f:	41 5c                	pop    %r12
    4c21:	41 5d                	pop    %r13
    4c23:	41 5e                	pop    %r14
    4c25:	c3                   	ret    
    4c26:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    4c2d:	00 00 00 
    c = (UINTN) (Comma ? ca[(p1 - str) % 3] : 999) + 1;
    4c30:	48 ba 56 55 55 55 55 	movabs $0x5555555555555556,%rdx
    4c37:	55 55 55 
    4c3a:	48 89 de             	mov    %rbx,%rsi
    4c3d:	48 29 ee             	sub    %rbp,%rsi
    4c40:	48 89 f0             	mov    %rsi,%rax
    4c43:	48 f7 ea             	imul   %rdx
    4c46:	48 89 f0             	mov    %rsi,%rax
    4c49:	48 c1 f8 3f          	sar    $0x3f,%rax
    4c4d:	48 29 c2             	sub    %rax,%rdx
    4c50:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax
    4c54:	48 29 c6             	sub    %rax,%rsi
    4c57:	0f b6 44 34 05       	movzbl 0x5(%rsp,%rsi,1),%eax
    4c5c:	48 83 c0 01          	add    $0x1,%rax
    4c60:	e9 71 ff ff ff       	jmp    4bd6 <ValueToString+0x76>
    4c65:	0f 1f 00             	nopl   (%rax)
        *(p2++) = '-';
    4c68:	b9 2d 00 00 00       	mov    $0x2d,%ecx
        v = -v;
    4c6d:	48 f7 df             	neg    %rdi
        *(p2++) = '-';
    4c70:	49 83 c6 02          	add    $0x2,%r14
    4c74:	66 41 89 4e fe       	mov    %cx,-0x2(%r14)
        v = -v;
    4c79:	e9 19 ff ff ff       	jmp    4b97 <ValueToString+0x37>
    4c7e:	66 90                	xchg   %ax,%ax
        Buffer[0] = '0';
    4c80:	41 c7 06 30 00 00 00 	movl   $0x30,(%r14)
}
    4c87:	48 83 c4 40          	add    $0x40,%rsp
    4c8b:	5b                   	pop    %rbx
    4c8c:	5d                   	pop    %rbp
    4c8d:	41 5c                	pop    %r12
    4c8f:	41 5d                	pop    %r13
    4c91:	41 5e                	pop    %r14
    4c93:	c3                   	ret    
    4c94:	0f 1f 40 00          	nopl   0x0(%rax)
    while (p1 != str) {
    4c98:	4c 89 f2             	mov    %r14,%rdx
    4c9b:	e9 74 ff ff ff       	jmp    4c14 <ValueToString+0xb4>

0000000000004ca0 <FloatToString>:
FloatToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN double   v
    )
{
    4ca0:	f3 0f 1e fa          	endbr64 
    4ca4:	55                   	push   %rbp
    /*
     * Integer part.
     */
    INTN i = (INTN)v;
    4ca5:	f2 48 0f 2c e8       	cvttsd2si %xmm0,%rbp
    ValueToString(Buffer, Comma, i);
    4caa:	40 0f b6 f6          	movzbl %sil,%esi
{
    4cae:	53                   	push   %rbx
    4caf:	48 89 fb             	mov    %rdi,%rbx
    4cb2:	48 83 ec 18          	sub    $0x18,%rsp
    ValueToString(Buffer, Comma, i);
    4cb6:	48 89 ea             	mov    %rbp,%rdx
    INTN i = (INTN)v;
    4cb9:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
    ValueToString(Buffer, Comma, i);
    4cbf:	e8 9c fe ff ff       	call   4b60 <ValueToString>


    /*
     * Decimal point.
     */
    UINTN x = StrLen(Buffer);
    4cc4:	48 89 df             	mov    %rbx,%rdi
    4cc7:	e8 14 1b 00 00       	call   67e0 <StrLen>


    /*
     * Keep fractional part.
     */
    float f = (float)(v - i);
    4ccc:	66 0f ef c9          	pxor   %xmm1,%xmm1
    4cd0:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
    Buffer[x] = L'.';
    4cd6:	b9 2e 00 00 00       	mov    $0x2e,%ecx
    float f = (float)(v - i);
    4cdb:	f2 48 0f 2a cd       	cvtsi2sd %rbp,%xmm1
    if (f < 0) f = -f;
    4ce0:	66 0f ef d2          	pxor   %xmm2,%xmm2
    Buffer[x] = L'.';
    4ce4:	66 89 0c 43          	mov    %cx,(%rbx,%rax,2)
    x++;
    4ce8:	48 83 c0 01          	add    $0x1,%rax
    float f = (float)(v - i);
    4cec:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    4cf0:	f2 0f 5a c0          	cvtsd2ss %xmm0,%xmm0
    if (f < 0) f = -f;
    4cf4:	0f 2f d0             	comiss %xmm0,%xmm2
    4cf7:	76 07                	jbe    4d00 <FloatToString+0x60>
    4cf9:	0f 57 05 50 9b 00 00 	xorps  0x9b50(%rip),%xmm0        # e850 <_DYNAMIC+0x2850>


    /*
     * Leading fractional zeroes.
     */
    f *= 10.0;
    4d00:	f3 0f 10 0d 58 9b 00 	movss  0x9b58(%rip),%xmm1        # e860 <_DYNAMIC+0x2860>
    4d07:	00 
    4d08:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
    while (   (f != 0)
           && ((INTN)f == 0))
    4d0c:	0f 2e c2             	ucomiss %xmm2,%xmm0
    4d0f:	7a 07                	jp     4d18 <FloatToString+0x78>
    4d11:	74 27                	je     4d3a <FloatToString+0x9a>
    4d13:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4d18:	f3 48 0f 2c d0       	cvttss2si %xmm0,%rdx
    4d1d:	48 85 d2             	test   %rdx,%rdx
    4d20:	75 1d                	jne    4d3f <FloatToString+0x9f>
    {
      Buffer[x] = L'0';
      x++;
      f *= 10.0;
    4d22:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
      Buffer[x] = L'0';
    4d26:	ba 30 00 00 00       	mov    $0x30,%edx
    4d2b:	66 89 14 43          	mov    %dx,(%rbx,%rax,2)
      x++;
    4d2f:	48 83 c0 01          	add    $0x1,%rax
           && ((INTN)f == 0))
    4d33:	0f 2e c2             	ucomiss %xmm2,%xmm0
    4d36:	7a e0                	jp     4d18 <FloatToString+0x78>
    4d38:	75 de                	jne    4d18 <FloatToString+0x78>


    /*
     * Fractional digits.
     */
    while ((float)(INTN)f != f)
    4d3a:	f3 48 0f 2c d0       	cvttss2si %xmm0,%rdx
    4d3f:	66 0f ef d2          	pxor   %xmm2,%xmm2
    4d43:	f3 48 0f 2a d2       	cvtsi2ss %rdx,%xmm2
    4d48:	0f 2e c2             	ucomiss %xmm2,%xmm0
    4d4b:	7a 03                	jp     4d50 <FloatToString+0xb0>
    4d4d:	74 1a                	je     4d69 <FloatToString+0xc9>
    4d4f:	90                   	nop
    {
      f *= 10;
    4d50:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
    while ((float)(INTN)f != f)
    4d54:	66 0f ef d2          	pxor   %xmm2,%xmm2
    4d58:	f3 48 0f 2c d0       	cvttss2si %xmm0,%rdx
    4d5d:	f3 48 0f 2a d2       	cvtsi2ss %rdx,%xmm2
    4d62:	0f 2e d0             	ucomiss %xmm0,%xmm2
    4d65:	7a e9                	jp     4d50 <FloatToString+0xb0>
    4d67:	75 e7                	jne    4d50 <FloatToString+0xb0>
    }
    ValueToString(Buffer + x, FALSE, (INTN)f);
    return;
}
    4d69:	48 83 c4 18          	add    $0x18,%rsp
    ValueToString(Buffer + x, FALSE, (INTN)f);
    4d6d:	48 8d 3c 43          	lea    (%rbx,%rax,2),%rdi
    4d71:	31 f6                	xor    %esi,%esi
}
    4d73:	5b                   	pop    %rbx
    4d74:	5d                   	pop    %rbp
    ValueToString(Buffer + x, FALSE, (INTN)f);
    4d75:	e9 e6 fd ff ff       	jmp    4b60 <ValueToString>
    4d7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000004d80 <TimeToString>:
VOID
TimeToString (
    OUT CHAR16      *Buffer,
    IN EFI_TIME     *Time
    )
{
    4d80:	f3 0f 1e fa          	endbr64 
    4d84:	48 83 ec 28          	sub    $0x28,%rsp
    UINTN       Hour, Year;
    CHAR16      AmPm;

    AmPm = 'a';
    Hour = Time->Hour;
    4d88:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
{
    4d8c:	48 89 f2             	mov    %rsi,%rdx
    if (Time->Hour == 0) {
    4d8f:	84 c0                	test   %al,%al
    4d91:	74 75                	je     4e08 <TimeToString+0x88>
    Hour = Time->Hour;
    4d93:	0f b6 c8             	movzbl %al,%ecx
        Hour = 12;
    } else if (Time->Hour >= 12) {
    4d96:	be 61 00 00 00       	mov    $0x61,%esi
    4d9b:	3c 0b                	cmp    $0xb,%al
    4d9d:	76 0d                	jbe    4dac <TimeToString+0x2c>
        AmPm = 'p';
        if (Time->Hour >= 13) {
    4d9f:	3c 0c                	cmp    $0xc,%al
    4da1:	74 75                	je     4e18 <TimeToString+0x98>
            Hour -= 12;
    4da3:	48 83 e9 0c          	sub    $0xc,%rcx
    4da7:	be 70 00 00 00       	mov    $0x70,%esi
        }
    }

    Year = Time->Year % 100;
    4dac:	44 0f b7 0a          	movzwl (%rdx),%r9d

    // bugbug: for now just print it any old way
    UnicodeSPrint (Buffer, 0, L"%02d/%02d/%02d  %02d:%02d%c",
    4db0:	44 0f b6 52 02       	movzbl 0x2(%rdx),%r10d
    4db5:	44 0f b6 42 03       	movzbl 0x3(%rdx),%r8d
    4dba:	89 74 24 10          	mov    %esi,0x10(%rsp)
    4dbe:	31 f6                	xor    %esi,%esi
    Year = Time->Year % 100;
    4dc0:	44 89 c8             	mov    %r9d,%eax
    4dc3:	66 c1 e8 02          	shr    $0x2,%ax
    4dc7:	0f b7 c0             	movzwl %ax,%eax
    4dca:	69 c0 7b 14 00 00    	imul   $0x147b,%eax,%eax
    4dd0:	c1 e8 11             	shr    $0x11,%eax
    4dd3:	8d 04 80             	lea    (%rax,%rax,4),%eax
    4dd6:	8d 04 80             	lea    (%rax,%rax,4),%eax
    4dd9:	c1 e0 02             	shl    $0x2,%eax
    4ddc:	41 29 c1             	sub    %eax,%r9d
    UnicodeSPrint (Buffer, 0, L"%02d/%02d/%02d  %02d:%02d%c",
    4ddf:	0f b6 42 05          	movzbl 0x5(%rdx),%eax
    4de3:	48 89 0c 24          	mov    %rcx,(%rsp)
    4de7:	48 8d 15 12 98 00 00 	lea    0x9812(%rip),%rdx        # e600 <_DYNAMIC+0x2600>
    4dee:	45 0f b7 c9          	movzwl %r9w,%r9d
    4df2:	44 89 d1             	mov    %r10d,%ecx
    4df5:	89 44 24 08          	mov    %eax,0x8(%rsp)
    4df9:	31 c0                	xor    %eax,%eax
    4dfb:	e8 e0 0e 00 00       	call   5ce0 <UnicodeSPrint>
        Year,
        Hour,
        Time->Minute,
        AmPm
        );
}
    4e00:	48 83 c4 28          	add    $0x28,%rsp
    4e04:	c3                   	ret    
    4e05:	0f 1f 00             	nopl   (%rax)
    4e08:	be 61 00 00 00       	mov    $0x61,%esi
        Hour = 12;
    4e0d:	b9 0c 00 00 00       	mov    $0xc,%ecx
    4e12:	eb 98                	jmp    4dac <TimeToString+0x2c>
    4e14:	0f 1f 40 00          	nopl   0x0(%rax)
    4e18:	be 70 00 00 00       	mov    $0x70,%esi
    4e1d:	b9 0c 00 00 00       	mov    $0xc,%ecx
    4e22:	eb 88                	jmp    4dac <TimeToString+0x2c>
    4e24:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4e2b:	00 00 00 00 
    4e2f:	90                   	nop

0000000000004e30 <_Print>:
{
    4e30:	f3 0f 1e fa          	endbr64 
    4e34:	41 56                	push   %r14
    4e36:	41 55                	push   %r13
            switch (c) {
    4e38:	4c 8d 2d 11 98 00 00 	lea    0x9811(%rip),%r13        # e650 <_DYNAMIC+0x2650>
{
    4e3f:	41 54                	push   %r12
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
    4e41:	4c 8d 25 f8 97 00 00 	lea    0x97f8(%rip),%r12        # e640 <_DYNAMIC+0x2640>
{
    4e48:	55                   	push   %rbp
    4e49:	53                   	push   %rbx
    4e4a:	48 89 fb             	mov    %rdi,%rbx
    4e4d:	48 81 ec b0 02 00 00 	sub    $0x2b0,%rsp
    ps->Len = 0;
    4e54:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
    4e5b:	00 
    ps->Buffer = Buffer;
    4e5c:	48 8d 84 24 20 01 00 	lea    0x120(%rsp),%rax
    4e63:	00 
    ps->fmt.Index = 0;
    4e64:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    4e6b:	00 
    ps->Buffer = Buffer;
    4e6c:	48 89 47 30          	mov    %rax,0x30(%rdi)
    ps->Pos = Buffer;
    4e70:	48 89 47 40          	mov    %rax,0x40(%rdi)
    ps->End = Buffer + PRINT_STRING_LEN - 1;
    4e74:	48 8d 84 24 ae 02 00 	lea    0x2ae(%rsp),%rax
    4e7b:	00 
    4e7c:	48 89 47 38          	mov    %rax,0x38(%rdi)
    ps->Item = &Item;
    4e80:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    4e85:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
    while ((c = PGETC(&ps->fmt))) {
    4e8c:	31 c0                	xor    %eax,%eax
    4e8e:	eb 48                	jmp    4ed8 <_Print+0xa8>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    4e90:	41 0f b6 2c 00       	movzbl (%r8,%rax,1),%ebp
    p->Index += 1;
    4e95:	48 8d 48 01          	lea    0x1(%rax),%rcx
    4e99:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    while ((c = PGETC(&ps->fmt))) {
    4e9d:	66 85 ed             	test   %bp,%bp
    4ea0:	74 54                	je     4ef6 <_Print+0xc6>
        if (c != '%') {
    4ea2:	66 83 fd 25          	cmp    $0x25,%bp
    4ea6:	74 70                	je     4f18 <_Print+0xe8>
    *ps->Pos = c;
    4ea8:	48 8b 43 40          	mov    0x40(%rbx),%rax
    if (c == '\n') {
    4eac:	66 83 fd 0a          	cmp    $0xa,%bp
    4eb0:	0f 84 aa 07 00 00    	je     5660 <_Print+0x830>
    *ps->Pos = c;
    4eb6:	66 89 28             	mov    %bp,(%rax)
    ps->Pos += 1;
    4eb9:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    4ebd:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    4ec2:	48 83 c0 02          	add    $0x2,%rax
    4ec6:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    4eca:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    4ece:	0f 83 1c 07 00 00    	jae    55f0 <_Print+0x7c0>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    4ed4:	48 8b 43 08          	mov    0x8(%rbx),%rax
    4ed8:	0f b6 3b             	movzbl (%rbx),%edi
    4edb:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    4edf:	40 84 ff             	test   %dil,%dil
    4ee2:	75 ac                	jne    4e90 <_Print+0x60>
    4ee4:	41 0f b7 2c 40       	movzwl (%r8,%rax,2),%ebp
    p->Index += 1;
    4ee9:	48 8d 48 01          	lea    0x1(%rax),%rcx
    4eed:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    while ((c = PGETC(&ps->fmt))) {
    4ef1:	66 85 ed             	test   %bp,%bp
    4ef4:	75 ac                	jne    4ea2 <_Print+0x72>
    PFLUSH (ps);
    4ef6:	48 89 df             	mov    %rbx,%rdi
    4ef9:	e8 32 f8 ff ff       	call   4730 <PFLUSH>
    return ps->Len;
    4efe:	48 8b 43 48          	mov    0x48(%rbx),%rax
}
    4f02:	48 81 c4 b0 02 00 00 	add    $0x2b0,%rsp
    4f09:	5b                   	pop    %rbx
    4f0a:	5d                   	pop    %rbp
    4f0b:	41 5c                	pop    %r12
    4f0d:	41 5d                	pop    %r13
    4f0f:	41 5e                	pop    %r14
    4f11:	c3                   	ret    
    4f12:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        Item.WidthParse = &Item.Width;
    4f18:	48 8d 94 24 00 01 00 	lea    0x100(%rsp),%rdx
    4f1f:	00 
        Item.Item.Ascii = FALSE;
    4f20:	c6 44 24 20 00       	movb   $0x0,0x20(%rsp)
    4f25:	48 8d 70 02          	lea    0x2(%rax),%rsi
        Item.WidthParse = &Item.Width;
    4f29:	48 89 94 24 10 01 00 	mov    %rdx,0x110(%rsp)
    4f30:	00 
                Item.WidthParse = &Item.FieldWidth;
    4f31:	48 8d ac 24 08 01 00 	lea    0x108(%rsp),%rbp
    4f38:	00 
        Item.FieldWidth = (UINTN) -1;
    4f39:	48 c7 84 24 08 01 00 	movq   $0xffffffffffffffff,0x108(%rsp)
    4f40:	00 ff ff ff ff 
        Item.Width = 0;
    4f45:	48 c7 84 24 00 01 00 	movq   $0x0,0x100(%rsp)
    4f4c:	00 00 00 00 00 
        Item.Pad = ' ';
    4f51:	c7 84 24 18 01 00 00 	movl   $0x10020,0x118(%rsp)
    4f58:	20 00 01 00 
        Item.Long = FALSE;
    4f5c:	c6 84 24 1c 01 00 00 	movb   $0x0,0x11c(%rsp)
    4f63:	00 
        Item.Item.pw = NULL;
    4f64:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    4f6b:	00 00 
        ps->RestoreAttr = 0;
    4f6d:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    4f74:	00 
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    4f75:	40 84 ff             	test   %dil,%dil
    4f78:	0f 84 ff 01 00 00    	je     517d <_Print+0x34d>
    4f7e:	41 0f b6 04 08       	movzbl (%r8,%rcx,1),%eax
    p->Index += 1;
    4f83:	48 89 73 08          	mov    %rsi,0x8(%rbx)
    4f87:	48 89 f1             	mov    %rsi,%rcx
        while ((c = PGETC(&ps->fmt))) {
    4f8a:	66 85 c0             	test   %ax,%ax
    4f8d:	74 41                	je     4fd0 <_Print+0x1a0>
            switch (c) {
    4f8f:	8d 50 db             	lea    -0x25(%rax),%edx
    4f92:	66 83 fa 53          	cmp    $0x53,%dx
    4f96:	77 18                	ja     4fb0 <_Print+0x180>
    4f98:	0f b7 d2             	movzwl %dx,%edx
    4f9b:	49 63 54 95 00       	movslq 0x0(%r13,%rdx,4),%rdx
    4fa0:	4c 01 ea             	add    %r13,%rdx
    4fa3:	3e ff e2             	notrack jmp *%rdx
    4fa6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    4fad:	00 00 00 
                Item.Scratch[0] = '?';
    4fb0:	c7 44 24 38 3f 00 00 	movl   $0x3f,0x38(%rsp)
    4fb7:	00 
                Item.Item.pw = Item.Scratch;
    4fb8:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    4fbd:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    4fc2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                PITEM (ps);
    4fc8:	48 89 df             	mov    %rbx,%rdi
    4fcb:	e8 b0 f8 ff ff       	call   4880 <PITEM>
        if (ps->RestoreAttr) {
    4fd0:	48 8b 6b 58          	mov    0x58(%rbx),%rbp
    4fd4:	48 85 ed             	test   %rbp,%rbp
    4fd7:	0f 84 f7 fe ff ff    	je     4ed4 <_Print+0xa4>
   PFLUSH (ps);
    4fdd:	48 89 df             	mov    %rbx,%rdi
    4fe0:	e8 4b f7 ff ff       	call   4730 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    4fe5:	48 8b 43 50          	mov    0x50(%rbx),%rax
    4fe9:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    4fed:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    4ff4:	48 85 c0             	test   %rax,%rax
    4ff7:	74 0c                	je     5005 <_Print+0x1d5>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    4ff9:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    5000:	48 89 ea             	mov    %rbp,%rdx
    5003:	ff d0                	call   *%rax
   ps->Attr = Attr;
    5005:	48 89 6b 50          	mov    %rbp,0x50(%rbx)
}
    5009:	e9 c6 fe ff ff       	jmp    4ed4 <_Print+0xa4>
    500e:	66 90                	xchg   %ax,%ax
                *Item.WidthParse = 0;
    5010:	48 8b 94 24 10 01 00 	mov    0x110(%rsp),%rdx
    5017:	00 
    5018:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    501f:	eb 24                	jmp    5045 <_Print+0x215>
    5021:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5028:	48 8b 43 10          	mov    0x10(%rbx),%rax
    502c:	0f b6 04 08          	movzbl (%rax,%rcx,1),%eax
    p->Index += 1;
    5030:	48 8d 71 01          	lea    0x1(%rcx),%rsi
                } while (c >= '0'  &&  c <= '9') ;
    5034:	8d 50 d0             	lea    -0x30(%rax),%edx
    p->Index += 1;
    5037:	48 89 73 08          	mov    %rsi,0x8(%rbx)
                } while (c >= '0'  &&  c <= '9') ;
    503b:	66 83 fa 09          	cmp    $0x9,%dx
    503f:	0f 87 fb 05 00 00    	ja     5640 <_Print+0x810>
                    *Item.WidthParse = *Item.WidthParse * 10 + c - '0';
    5045:	48 8b 94 24 10 01 00 	mov    0x110(%rsp),%rdx
    504c:	00 
    504d:	48 8b 0a             	mov    (%rdx),%rcx
    5050:	48 8d 0c 89          	lea    (%rcx,%rcx,4),%rcx
    5054:	48 8d 44 48 d0       	lea    -0x30(%rax,%rcx,2),%rax
    5059:	48 89 02             	mov    %rax,(%rdx)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    505c:	0f b6 3b             	movzbl (%rbx),%edi
    505f:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    5063:	40 84 ff             	test   %dil,%dil
    5066:	75 c0                	jne    5028 <_Print+0x1f8>
    5068:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    506c:	41 0f b7 04 48       	movzwl (%r8,%rcx,2),%eax
    5071:	eb bd                	jmp    5030 <_Print+0x200>
    5073:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                    Item.Long ? va_arg(ps->args, INT64) : va_arg(ps->args, INT32)
    5078:	0f b6 94 24 1c 01 00 	movzbl 0x11c(%rsp),%edx
    507f:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    5080:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToHex (
    5083:	84 d2                	test   %dl,%dl
    5085:	0f 84 13 04 00 00    	je     549e <_Print+0x66e>
    508b:	83 f8 2f             	cmp    $0x2f,%eax
    508e:	0f 87 e4 06 00 00    	ja     5778 <_Print+0x948>
    5094:	89 c2                	mov    %eax,%edx
    5096:	83 c0 08             	add    $0x8,%eax
    5099:	48 03 53 28          	add    0x28(%rbx),%rdx
    509d:	89 43 18             	mov    %eax,0x18(%rbx)
    50a0:	48 8b 32             	mov    (%rdx),%rsi
    if (!v) {
    50a3:	48 85 f6             	test   %rsi,%rsi
    50a6:	0f 84 12 04 00 00    	je     54be <_Print+0x68e>
    50ac:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    50b1:	48 89 ef             	mov    %rbp,%rdi
    50b4:	e8 a7 f5 ff ff       	call   4660 <ValueToHex.part.0>
                Item.Item.pw = Item.Scratch;
    50b9:	e9 ff fe ff ff       	jmp    4fbd <_Print+0x18d>
    50be:	66 90                	xchg   %ax,%ax
                ValueToString (
    50c0:	80 bc 24 1c 01 00 00 	cmpb   $0x0,0x11c(%rsp)
    50c7:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    50c8:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToString (
    50cb:	0f 85 2f 05 00 00    	jne    5600 <_Print+0x7d0>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    50d1:	83 f8 2f             	cmp    $0x2f,%eax
    50d4:	0f 86 31 07 00 00    	jbe    580b <_Print+0x9db>
    50da:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    50de:	48 8d 42 08          	lea    0x8(%rdx),%rax
    50e2:	48 89 43 20          	mov    %rax,0x20(%rbx)
                ValueToString (
    50e6:	8b 12                	mov    (%rdx),%edx
    50e8:	e9 2b 05 00 00       	jmp    5618 <_Print+0x7e8>
    50ed:	0f 1f 00             	nopl   (%rax)
                TimeToString (Item.Scratch, va_arg(ps->args, EFI_TIME *));
    50f0:	8b 43 18             	mov    0x18(%rbx),%eax
    50f3:	83 f8 2f             	cmp    $0x2f,%eax
    50f6:	0f 87 34 06 00 00    	ja     5730 <_Print+0x900>
    50fc:	89 c2                	mov    %eax,%edx
    50fe:	83 c0 08             	add    $0x8,%eax
    5101:	48 03 53 28          	add    0x28(%rbx),%rdx
    5105:	89 43 18             	mov    %eax,0x18(%rbx)
    5108:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    510d:	48 8b 32             	mov    (%rdx),%rsi
    5110:	48 89 ef             	mov    %rbp,%rdi
    5113:	e8 68 fc ff ff       	call   4d80 <TimeToString>
                Item.Item.pw = Item.Scratch;
    5118:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    511d:	e9 a6 fe ff ff       	jmp    4fc8 <_Print+0x198>
    5122:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
    5128:	8b 43 18             	mov    0x18(%rbx),%eax
    512b:	83 f8 2f             	cmp    $0x2f,%eax
    512e:	0f 87 b4 05 00 00    	ja     56e8 <_Print+0x8b8>
    5134:	89 c2                	mov    %eax,%edx
    5136:	83 c0 08             	add    $0x8,%eax
    5139:	48 03 53 28          	add    0x28(%rbx),%rdx
    513d:	89 43 18             	mov    %eax,0x18(%rbx)
    5140:	48 8b 02             	mov    (%rdx),%rax
    5143:	48 85 c0             	test   %rax,%rax
    5146:	49 0f 44 c4          	cmove  %r12,%rax
    514a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    514f:	e9 74 fe ff ff       	jmp    4fc8 <_Print+0x198>
    5154:	0f 1f 40 00          	nopl   0x0(%rax)
            if (Item.Item.pw) {
    5158:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.Long = TRUE;
    515e:	c6 84 24 1c 01 00 00 	movb   $0x1,0x11c(%rsp)
    5165:	01 
            if (Item.Item.pw) {
    5166:	0f 85 5c fe ff ff    	jne    4fc8 <_Print+0x198>
    516c:	0f 1f 40 00          	nopl   0x0(%rax)
    5170:	48 83 c6 01          	add    $0x1,%rsi
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5174:	40 84 ff             	test   %dil,%dil
    5177:	0f 85 01 fe ff ff    	jne    4f7e <_Print+0x14e>
    517d:	41 0f b7 04 48       	movzwl (%r8,%rcx,2),%eax
    5182:	e9 fc fd ff ff       	jmp    4f83 <_Print+0x153>
    5187:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    518e:	00 00 
                Item.Pad = '0';
    5190:	ba 30 00 00 00       	mov    $0x30,%edx
                ValueToHex (
    5195:	80 bc 24 1c 01 00 00 	cmpb   $0x0,0x11c(%rsp)
    519c:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    519d:	8b 43 18             	mov    0x18(%rbx),%eax
                Item.Width = sizeof(void *) == (8 ? 16 : 8) + 2;
    51a0:	48 c7 84 24 00 01 00 	movq   $0x0,0x100(%rsp)
    51a7:	00 00 00 00 00 
                Item.Pad = '0';
    51ac:	66 89 94 24 18 01 00 	mov    %dx,0x118(%rsp)
    51b3:	00 
                Item.Scratch[0] = ' ';
    51b4:	c7 44 24 38 20 00 20 	movl   $0x200020,0x38(%rsp)
    51bb:	00 
                ValueToHex (
    51bc:	0f 84 86 05 00 00    	je     5748 <_Print+0x918>
    51c2:	83 f8 2f             	cmp    $0x2f,%eax
    51c5:	0f 87 2f 06 00 00    	ja     57fa <_Print+0x9ca>
    51cb:	89 c2                	mov    %eax,%edx
    51cd:	83 c0 08             	add    $0x8,%eax
    51d0:	48 03 53 28          	add    0x28(%rbx),%rdx
    51d4:	89 43 18             	mov    %eax,0x18(%rbx)
    51d7:	48 8b 32             	mov    (%rdx),%rsi
    if (!v) {
    51da:	48 85 f6             	test   %rsi,%rsi
    51dd:	0f 84 85 05 00 00    	je     5768 <_Print+0x938>
    51e3:	48 8d 7c 24 3c       	lea    0x3c(%rsp),%rdi
    51e8:	e8 73 f4 ff ff       	call   4660 <ValueToHex.part.0>
                Item.Item.pw = Item.Scratch;
    51ed:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                Item.Scratch[0] = '0';
    51f2:	c7 44 24 38 30 00 78 	movl   $0x780030,0x38(%rsp)
    51f9:	00 
                Item.Item.pw = Item.Scratch;
    51fa:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    51ff:	e9 c4 fd ff ff       	jmp    4fc8 <_Print+0x198>
    5204:	0f 1f 40 00          	nopl   0x0(%rax)
                PSETATTR(ps, ps->AttrNorm);
    5208:	4c 8b 73 60          	mov    0x60(%rbx),%r14
   PFLUSH (ps);
    520c:	48 89 df             	mov    %rbx,%rdi
    520f:	e8 1c f5 ff ff       	call   4730 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    5214:	48 8b 43 50          	mov    0x50(%rbx),%rax
    5218:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    521c:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    5223:	48 85 c0             	test   %rax,%rax
    5226:	74 0c                	je     5234 <_Print+0x404>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    5228:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    522f:	4c 89 f2             	mov    %r14,%rdx
    5232:	ff d0                	call   *%rax
            if (Item.Item.pw) {
    5234:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
   ps->Attr = Attr;
    523a:	4c 89 73 50          	mov    %r14,0x50(%rbx)
            if (Item.Item.pw) {
    523e:	0f 85 84 fd ff ff    	jne    4fc8 <_Print+0x198>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5244:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    5248:	0f b6 3b             	movzbl (%rbx),%edi
    524b:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    524f:	48 8d 71 01          	lea    0x1(%rcx),%rsi
    5253:	e9 1d fd ff ff       	jmp    4f75 <_Print+0x145>
    5258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    525f:	00 
                GuidToString (Item.Scratch, va_arg(ps->args, EFI_GUID *));
    5260:	8b 43 18             	mov    0x18(%rbx),%eax
    5263:	83 f8 2f             	cmp    $0x2f,%eax
    5266:	0f 87 ac 04 00 00    	ja     5718 <_Print+0x8e8>
    526c:	89 c2                	mov    %eax,%edx
    526e:	83 c0 08             	add    $0x8,%eax
    5271:	48 03 53 28          	add    0x28(%rbx),%rdx
    5275:	89 43 18             	mov    %eax,0x18(%rbx)
    5278:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    527d:	48 8b 32             	mov    (%rdx),%rsi
    5280:	48 89 ef             	mov    %rbp,%rdi
    5283:	e8 18 36 00 00       	call   88a0 <GuidToString>
                Item.Item.pw = Item.Scratch;
    5288:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    528d:	e9 36 fd ff ff       	jmp    4fc8 <_Print+0x198>
    5292:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                FloatToString (
    5298:	8b 43 1c             	mov    0x1c(%rbx),%eax
    529b:	3d af 00 00 00       	cmp    $0xaf,%eax
    52a0:	0f 87 5a 04 00 00    	ja     5700 <_Print+0x8d0>
    52a6:	89 c2                	mov    %eax,%edx
    52a8:	83 c0 10             	add    $0x10,%eax
    52ab:	48 03 53 28          	add    0x28(%rbx),%rdx
    52af:	89 43 1c             	mov    %eax,0x1c(%rbx)
    52b2:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    52b7:	0f b6 b4 24 1b 01 00 	movzbl 0x11b(%rsp),%esi
    52be:	00 
    52bf:	f2 0f 10 02          	movsd  (%rdx),%xmm0
    52c3:	48 89 ef             	mov    %rbp,%rdi
    52c6:	e8 d5 f9 ff ff       	call   4ca0 <FloatToString>
                Item.Item.pw = Item.Scratch;
    52cb:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    52d0:	e9 f3 fc ff ff       	jmp    4fc8 <_Print+0x198>
    52d5:	0f 1f 00             	nopl   (%rax)
                PSETATTR(ps, ps->AttrHighlight);
    52d8:	4c 8b 73 68          	mov    0x68(%rbx),%r14
   PFLUSH (ps);
    52dc:	e9 2b ff ff ff       	jmp    520c <_Print+0x3dc>
    52e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                StatusToString (Item.Scratch, va_arg(ps->args, EFI_STATUS));
    52e8:	8b 43 18             	mov    0x18(%rbx),%eax
    52eb:	83 f8 2f             	cmp    $0x2f,%eax
    52ee:	0f 87 9c 04 00 00    	ja     5790 <_Print+0x960>
    52f4:	89 c2                	mov    %eax,%edx
    52f6:	83 c0 08             	add    $0x8,%eax
    52f9:	48 03 53 28          	add    0x28(%rbx),%rdx
    52fd:	89 43 18             	mov    %eax,0x18(%rbx)
    5300:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    5305:	48 8b 32             	mov    (%rdx),%rsi
    5308:	48 89 ef             	mov    %rbp,%rdi
    530b:	e8 90 e0 ff ff       	call   33a0 <StatusToString>
                Item.Item.pw = Item.Scratch;
    5310:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    5315:	e9 ae fc ff ff       	jmp    4fc8 <_Print+0x198>
    531a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                PSETATTR(ps, ps->AttrError);
    5320:	4c 8b 73 70          	mov    0x70(%rbx),%r14
   PFLUSH (ps);
    5324:	e9 e3 fe ff ff       	jmp    520c <_Print+0x3dc>
    5329:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            if (Item.Item.pw) {
    5330:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.PadBefore = FALSE;
    5336:	c6 84 24 1a 01 00 00 	movb   $0x0,0x11a(%rsp)
    533d:	00 
            if (Item.Item.pw) {
    533e:	0f 84 2c fe ff ff    	je     5170 <_Print+0x340>
    5344:	e9 7f fc ff ff       	jmp    4fc8 <_Print+0x198>
    5349:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    5350:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.Comma = TRUE;
    5356:	c6 84 24 1b 01 00 00 	movb   $0x1,0x11b(%rsp)
    535d:	01 
            if (Item.Item.pw) {
    535e:	0f 84 0c fe ff ff    	je     5170 <_Print+0x340>
    5364:	e9 5f fc ff ff       	jmp    4fc8 <_Print+0x198>
    5369:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                *Item.WidthParse = va_arg(ps->args, UINTN);
    5370:	8b 43 18             	mov    0x18(%rbx),%eax
    5373:	48 8b 8c 24 10 01 00 	mov    0x110(%rsp),%rcx
    537a:	00 
    537b:	83 f8 2f             	cmp    $0x2f,%eax
    537e:	0f 87 3c 04 00 00    	ja     57c0 <_Print+0x990>
    5384:	89 c2                	mov    %eax,%edx
    5386:	83 c0 08             	add    $0x8,%eax
    5389:	48 03 53 28          	add    0x28(%rbx),%rdx
    538d:	89 43 18             	mov    %eax,0x18(%rbx)
    5390:	48 8b 02             	mov    (%rdx),%rax
    5393:	48 89 01             	mov    %rax,(%rcx)
            if (Item.Item.pw) {
    5396:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
    539c:	0f 84 a2 fe ff ff    	je     5244 <_Print+0x414>
    53a2:	e9 21 fc ff ff       	jmp    4fc8 <_Print+0x198>
    53a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    53ae:	00 00 
                Item.Item.pw = Item.Scratch;
    53b0:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                Item.Scratch[0] = '%';
    53b5:	c7 44 24 38 25 00 00 	movl   $0x25,0x38(%rsp)
    53bc:	00 
                Item.Item.pw = Item.Scratch;
    53bd:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    53c2:	e9 01 fc ff ff       	jmp    4fc8 <_Print+0x198>
    53c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    53ce:	00 00 
                Item.Pad = '0';
    53d0:	41 b9 30 00 00 00    	mov    $0x30,%r9d
            if (Item.Item.pw) {
    53d6:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.Pad = '0';
    53dc:	66 44 89 8c 24 18 01 	mov    %r9w,0x118(%rsp)
    53e3:	00 00 
            if (Item.Item.pw) {
    53e5:	0f 84 85 fd ff ff    	je     5170 <_Print+0x340>
    53eb:	e9 d8 fb ff ff       	jmp    4fc8 <_Print+0x198>
    53f0:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.WidthParse = &Item.FieldWidth;
    53f6:	48 89 ac 24 10 01 00 	mov    %rbp,0x110(%rsp)
    53fd:	00 
            if (Item.Item.pw) {
    53fe:	0f 84 6c fd ff ff    	je     5170 <_Print+0x340>
    5404:	e9 bf fb ff ff       	jmp    4fc8 <_Print+0x198>
    5409:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                EFI_DEVICE_PATH *dp = va_arg(ps->args, EFI_DEVICE_PATH *);
    5410:	8b 43 18             	mov    0x18(%rbx),%eax
    5413:	83 f8 2f             	cmp    $0x2f,%eax
    5416:	0f 87 b4 02 00 00    	ja     56d0 <_Print+0x8a0>
    541c:	89 c2                	mov    %eax,%edx
    541e:	83 c0 08             	add    $0x8,%eax
    5421:	48 03 53 28          	add    0x28(%rbx),%rdx
    5425:	89 43 18             	mov    %eax,0x18(%rbx)
                CHAR16 *dpstr = DevicePathToStr(dp);
    5428:	48 8b 3a             	mov    (%rdx),%rdi
                StrnCpy(Item.Scratch, dpstr, PRINT_ITEM_BUFFER_LEN);
    542b:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                CHAR16 *dpstr = DevicePathToStr(dp);
    5430:	e8 eb 31 00 00       	call   8620 <DevicePathToStr>
                StrnCpy(Item.Scratch, dpstr, PRINT_ITEM_BUFFER_LEN);
    5435:	ba 64 00 00 00       	mov    $0x64,%edx
    543a:	48 89 ef             	mov    %rbp,%rdi
                CHAR16 *dpstr = DevicePathToStr(dp);
    543d:	49 89 c6             	mov    %rax,%r14
                StrnCpy(Item.Scratch, dpstr, PRINT_ITEM_BUFFER_LEN);
    5440:	48 89 c6             	mov    %rax,%rsi
    5443:	e8 38 13 00 00       	call   6780 <StrnCpy>
                Item.Scratch[PRINT_ITEM_BUFFER_LEN-1] = L'\0';
    5448:	31 c9                	xor    %ecx,%ecx
                FreePool(dpstr);
    544a:	4c 89 f7             	mov    %r14,%rdi
                Item.Scratch[PRINT_ITEM_BUFFER_LEN-1] = L'\0';
    544d:	66 89 8c 24 fe 00 00 	mov    %cx,0xfe(%rsp)
    5454:	00 
                FreePool(dpstr);
    5455:	e8 76 e5 ff ff       	call   39d0 <FreePool>
                Item.Item.pw = Item.Scratch;
    545a:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    545f:	e9 64 fb ff ff       	jmp    4fc8 <_Print+0x198>
    5464:	0f 1f 40 00          	nopl   0x0(%rax)
                Item.Width = Item.Long ? 16 : 8;
    5468:	0f b6 94 24 1c 01 00 	movzbl 0x11c(%rsp),%edx
    546f:	00 
    5470:	80 fa 01             	cmp    $0x1,%dl
    5473:	48 19 c0             	sbb    %rax,%rax
    5476:	48 83 e0 f8          	and    $0xfffffffffffffff8,%rax
    547a:	48 83 c0 10          	add    $0x10,%rax
    547e:	48 89 84 24 00 01 00 	mov    %rax,0x100(%rsp)
    5485:	00 
                Item.Pad = '0';
    5486:	b8 30 00 00 00       	mov    $0x30,%eax
    548b:	66 89 84 24 18 01 00 	mov    %ax,0x118(%rsp)
    5492:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    5493:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToHex (
    5496:	84 d2                	test   %dl,%dl
    5498:	0f 85 ed fb ff ff    	jne    508b <_Print+0x25b>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    549e:	83 f8 2f             	cmp    $0x2f,%eax
    54a1:	0f 87 f9 01 00 00    	ja     56a0 <_Print+0x870>
    54a7:	89 c2                	mov    %eax,%edx
    54a9:	83 c0 08             	add    $0x8,%eax
    54ac:	48 03 53 28          	add    0x28(%rbx),%rdx
    54b0:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToHex (
    54b3:	8b 32                	mov    (%rdx),%esi
    if (!v) {
    54b5:	48 85 f6             	test   %rsi,%rsi
    54b8:	0f 85 ee fb ff ff    	jne    50ac <_Print+0x27c>
        Buffer[0] = '0';
    54be:	c7 44 24 38 30 00 00 	movl   $0x30,0x38(%rsp)
    54c5:	00 
        return ;
    54c6:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    54cb:	e9 ed fa ff ff       	jmp    4fbd <_Print+0x18d>
                Item.Scratch[0] = (CHAR16) va_arg(ps->args, UINTN);
    54d0:	8b 43 18             	mov    0x18(%rbx),%eax
    54d3:	83 f8 2f             	cmp    $0x2f,%eax
    54d6:	0f 87 dc 01 00 00    	ja     56b8 <_Print+0x888>
    54dc:	89 c2                	mov    %eax,%edx
    54de:	83 c0 08             	add    $0x8,%eax
    54e1:	48 03 53 28          	add    0x28(%rbx),%rdx
    54e5:	89 43 18             	mov    %eax,0x18(%rbx)
    54e8:	48 8b 02             	mov    (%rdx),%rax
                Item.Scratch[1] = 0;
    54eb:	31 f6                	xor    %esi,%esi
                Item.Item.pw = Item.Scratch;
    54ed:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                Item.Scratch[1] = 0;
    54f2:	66 89 74 24 3a       	mov    %si,0x3a(%rsp)
                Item.Scratch[0] = (CHAR16) va_arg(ps->args, UINTN);
    54f7:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
                Item.Item.pw = Item.Scratch;
    54fc:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    5501:	e9 c2 fa ff ff       	jmp    4fc8 <_Print+0x198>
    5506:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    550d:	00 00 00 
                Item.Item.pc = va_arg(ps->args, CHAR8 *);
    5510:	8b 43 18             	mov    0x18(%rbx),%eax
    5513:	83 f8 2f             	cmp    $0x2f,%eax
    5516:	0f 87 8c 02 00 00    	ja     57a8 <_Print+0x978>
    551c:	89 c2                	mov    %eax,%edx
    551e:	83 c0 08             	add    $0x8,%eax
    5521:	48 03 53 28          	add    0x28(%rbx),%rdx
    5525:	89 43 18             	mov    %eax,0x18(%rbx)
    5528:	48 8b 12             	mov    (%rdx),%rdx
                    Item.Item.pc = (CHAR8 *)"(null)";
    552b:	48 8d 05 06 91 00 00 	lea    0x9106(%rip),%rax        # e638 <_DYNAMIC+0x2638>
                Item.Item.Ascii = TRUE;
    5532:	c6 44 24 20 01       	movb   $0x1,0x20(%rsp)
                    Item.Item.pc = (CHAR8 *)"(null)";
    5537:	48 85 d2             	test   %rdx,%rdx
    553a:	48 0f 45 c2          	cmovne %rdx,%rax
    553e:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    5543:	e9 80 fa ff ff       	jmp    4fc8 <_Print+0x198>
    5548:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    554f:	00 
                ValueToString (
    5550:	80 bc 24 1c 01 00 00 	cmpb   $0x0,0x11c(%rsp)
    5557:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    5558:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToString (
    555b:	0f 85 9f 00 00 00    	jne    5600 <_Print+0x7d0>
                    Item.Long ? va_arg(ps->args, INT64) : va_arg(ps->args, INT32)
    5561:	83 f8 2f             	cmp    $0x2f,%eax
    5564:	0f 87 7f 02 00 00    	ja     57e9 <_Print+0x9b9>
    556a:	89 c2                	mov    %eax,%edx
    556c:	83 c0 08             	add    $0x8,%eax
    556f:	48 03 53 28          	add    0x28(%rbx),%rdx
    5573:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToString (
    5576:	48 63 12             	movslq (%rdx),%rdx
    5579:	e9 9a 00 00 00       	jmp    5618 <_Print+0x7e8>
    557e:	66 90                	xchg   %ax,%ax
                Attr = ps->AttrHighlight;
    5580:	4c 8b 73 68          	mov    0x68(%rbx),%r14
            if (Item.Item.pw) {
    5584:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
    558a:	0f 85 38 fa ff ff    	jne    4fc8 <_Print+0x198>
            if (Attr) {
    5590:	4d 85 f6             	test   %r14,%r14
    5593:	0f 84 d7 fb ff ff    	je     5170 <_Print+0x340>
   PFLUSH (ps);
    5599:	48 89 df             	mov    %rbx,%rdi
    559c:	e8 8f f1 ff ff       	call   4730 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    55a1:	48 8b 43 50          	mov    0x50(%rbx),%rax
    55a5:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    55a9:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    55b0:	48 85 c0             	test   %rax,%rax
    55b3:	74 0c                	je     55c1 <_Print+0x791>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    55b5:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    55bc:	4c 89 f2             	mov    %r14,%rdx
    55bf:	ff d0                	call   *%rax
   ps->Attr = Attr;
    55c1:	4c 89 73 50          	mov    %r14,0x50(%rbx)
                ps->RestoreAttr = 0;
    55c5:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    55cc:	00 
        if (ps->RestoreAttr) {
    55cd:	e9 02 f9 ff ff       	jmp    4ed4 <_Print+0xa4>
    55d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                Attr = ps->AttrError;
    55d8:	4c 8b 73 70          	mov    0x70(%rbx),%r14
                break;
    55dc:	eb a6                	jmp    5584 <_Print+0x754>
    55de:	66 90                	xchg   %ax,%ax
                Attr = ps->AttrNorm;
    55e0:	4c 8b 73 60          	mov    0x60(%rbx),%r14
                break;
    55e4:	eb 9e                	jmp    5584 <_Print+0x754>
    55e6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    55ed:	00 00 00 
        PFLUSH(ps);
    55f0:	48 89 df             	mov    %rbx,%rdi
    55f3:	e8 38 f1 ff ff       	call   4730 <PFLUSH>
    55f8:	e9 d7 f8 ff ff       	jmp    4ed4 <_Print+0xa4>
    55fd:	0f 1f 00             	nopl   (%rax)
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    5600:	83 f8 2f             	cmp    $0x2f,%eax
    5603:	0f 87 cf 01 00 00    	ja     57d8 <_Print+0x9a8>
    5609:	89 c2                	mov    %eax,%edx
    560b:	83 c0 08             	add    $0x8,%eax
    560e:	48 03 53 28          	add    0x28(%rbx),%rdx
    5612:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToString (
    5615:	48 8b 12             	mov    (%rdx),%rdx
    5618:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    561d:	0f b6 b4 24 1b 01 00 	movzbl 0x11b(%rsp),%esi
    5624:	00 
    5625:	48 89 ef             	mov    %rbp,%rdi
    5628:	e8 33 f5 ff ff       	call   4b60 <ValueToString>
                Item.Item.pw = Item.Scratch;
    562d:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    5632:	e9 91 f9 ff ff       	jmp    4fc8 <_Print+0x198>
    5637:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    563e:	00 00 
    5640:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                ps->fmt.Index -= 1;
    5646:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
            if (Item.Item.pw) {
    564a:	0f 85 78 f9 ff ff    	jne    4fc8 <_Print+0x198>
    5650:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    5654:	e9 1c f9 ff ff       	jmp    4f75 <_Print+0x145>
    5659:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    *ps->Pos = c;
    5660:	41 ba 0d 00 00 00    	mov    $0xd,%r10d
    5666:	66 44 89 10          	mov    %r10w,(%rax)
    ps->Pos += 1;
    566a:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    566e:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    5673:	48 83 c0 02          	add    $0x2,%rax
    5677:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    567b:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    567f:	0f 82 31 f8 ff ff    	jb     4eb6 <_Print+0x86>
        PFLUSH(ps);
    5685:	48 89 df             	mov    %rbx,%rdi
    5688:	e8 a3 f0 ff ff       	call   4730 <PFLUSH>
    *ps->Pos = c;
    568d:	48 8b 43 40          	mov    0x40(%rbx),%rax
    5691:	e9 20 f8 ff ff       	jmp    4eb6 <_Print+0x86>
    5696:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    569d:	00 00 00 
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    56a0:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    56a4:	48 8d 42 08          	lea    0x8(%rdx),%rax
    56a8:	48 89 43 20          	mov    %rax,0x20(%rbx)
                ValueToHex (
    56ac:	8b 32                	mov    (%rdx),%esi
    56ae:	e9 02 fe ff ff       	jmp    54b5 <_Print+0x685>
    56b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                Item.Scratch[0] = (CHAR16) va_arg(ps->args, UINTN);
    56b8:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    56bc:	48 8d 42 08          	lea    0x8(%rdx),%rax
    56c0:	48 89 43 20          	mov    %rax,0x20(%rbx)
    56c4:	e9 1f fe ff ff       	jmp    54e8 <_Print+0x6b8>
    56c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                EFI_DEVICE_PATH *dp = va_arg(ps->args, EFI_DEVICE_PATH *);
    56d0:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    56d4:	48 8d 42 08          	lea    0x8(%rdx),%rax
    56d8:	48 89 43 20          	mov    %rax,0x20(%rbx)
    56dc:	e9 47 fd ff ff       	jmp    5428 <_Print+0x5f8>
    56e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
    56e8:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    56ec:	48 8d 42 08          	lea    0x8(%rdx),%rax
    56f0:	48 89 43 20          	mov    %rax,0x20(%rbx)
    56f4:	e9 47 fa ff ff       	jmp    5140 <_Print+0x310>
    56f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                FloatToString (
    5700:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    5704:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5708:	48 89 43 20          	mov    %rax,0x20(%rbx)
    570c:	e9 a1 fb ff ff       	jmp    52b2 <_Print+0x482>
    5711:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                GuidToString (Item.Scratch, va_arg(ps->args, EFI_GUID *));
    5718:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    571c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5720:	48 89 43 20          	mov    %rax,0x20(%rbx)
    5724:	e9 4f fb ff ff       	jmp    5278 <_Print+0x448>
    5729:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                TimeToString (Item.Scratch, va_arg(ps->args, EFI_TIME *));
    5730:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    5734:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5738:	48 89 43 20          	mov    %rax,0x20(%rbx)
    573c:	e9 c7 f9 ff ff       	jmp    5108 <_Print+0x2d8>
    5741:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    5748:	83 f8 2f             	cmp    $0x2f,%eax
    574b:	0f 86 cd 00 00 00    	jbe    581e <_Print+0x9ee>
    5751:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    5755:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5759:	48 89 43 20          	mov    %rax,0x20(%rbx)
                ValueToHex (
    575d:	8b 32                	mov    (%rdx),%esi
    if (!v) {
    575f:	48 85 f6             	test   %rsi,%rsi
    5762:	0f 85 7b fa ff ff    	jne    51e3 <_Print+0x3b3>
        Buffer[0] = '0';
    5768:	c7 44 24 3c 30 00 00 	movl   $0x30,0x3c(%rsp)
    576f:	00 
        return ;
    5770:	e9 78 fa ff ff       	jmp    51ed <_Print+0x3bd>
    5775:	0f 1f 00             	nopl   (%rax)
                ValueToHex (
    5778:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    577c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5780:	48 89 43 20          	mov    %rax,0x20(%rbx)
    5784:	e9 17 f9 ff ff       	jmp    50a0 <_Print+0x270>
    5789:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                StatusToString (Item.Scratch, va_arg(ps->args, EFI_STATUS));
    5790:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    5794:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5798:	48 89 43 20          	mov    %rax,0x20(%rbx)
    579c:	e9 5f fb ff ff       	jmp    5300 <_Print+0x4d0>
    57a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                Item.Item.pc = va_arg(ps->args, CHAR8 *);
    57a8:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    57ac:	48 8d 42 08          	lea    0x8(%rdx),%rax
    57b0:	48 89 43 20          	mov    %rax,0x20(%rbx)
    57b4:	e9 6f fd ff ff       	jmp    5528 <_Print+0x6f8>
    57b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                *Item.WidthParse = va_arg(ps->args, UINTN);
    57c0:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    57c4:	48 8d 42 08          	lea    0x8(%rdx),%rax
    57c8:	48 89 43 20          	mov    %rax,0x20(%rbx)
    57cc:	e9 bf fb ff ff       	jmp    5390 <_Print+0x560>
    57d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    57d8:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    57dc:	48 8d 42 08          	lea    0x8(%rdx),%rax
    57e0:	48 89 43 20          	mov    %rax,0x20(%rbx)
    57e4:	e9 2c fe ff ff       	jmp    5615 <_Print+0x7e5>
                    Item.Long ? va_arg(ps->args, INT64) : va_arg(ps->args, INT32)
    57e9:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    57ed:	48 8d 42 08          	lea    0x8(%rdx),%rax
    57f1:	48 89 43 20          	mov    %rax,0x20(%rbx)
    57f5:	e9 7c fd ff ff       	jmp    5576 <_Print+0x746>
                ValueToHex (
    57fa:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    57fe:	48 8d 42 08          	lea    0x8(%rdx),%rax
    5802:	48 89 43 20          	mov    %rax,0x20(%rbx)
    5806:	e9 cc f9 ff ff       	jmp    51d7 <_Print+0x3a7>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    580b:	89 c2                	mov    %eax,%edx
    580d:	83 c0 08             	add    $0x8,%eax
    5810:	48 03 53 28          	add    0x28(%rbx),%rdx
    5814:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToString (
    5817:	8b 12                	mov    (%rdx),%edx
    5819:	e9 fa fd ff ff       	jmp    5618 <_Print+0x7e8>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    581e:	89 c2                	mov    %eax,%edx
    5820:	83 c0 08             	add    $0x8,%eax
    5823:	48 03 53 28          	add    0x28(%rbx),%rdx
    5827:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToHex (
    582a:	8b 32                	mov    (%rdx),%esi
    582c:	e9 2e ff ff ff       	jmp    575f <_Print+0x92f>
    5831:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    5838:	00 00 00 00 
    583c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000005840 <DbgPrint>:
{
    5840:	f3 0f 1e fa          	endbr64 
    5844:	41 55                	push   %r13
    5846:	41 54                	push   %r12
    5848:	55                   	push   %rbp
    5849:	48 89 f5             	mov    %rsi,%rbp
    584c:	53                   	push   %rbx
    584d:	48 89 fb             	mov    %rdi,%rbx
    5850:	48 81 ec 98 01 00 00 	sub    $0x198,%rsp
    5857:	48 89 94 24 f0 00 00 	mov    %rdx,0xf0(%rsp)
    585e:	00 
    585f:	48 89 8c 24 f8 00 00 	mov    %rcx,0xf8(%rsp)
    5866:	00 
    5867:	4c 89 84 24 00 01 00 	mov    %r8,0x100(%rsp)
    586e:	00 
    586f:	4c 89 8c 24 08 01 00 	mov    %r9,0x108(%rsp)
    5876:	00 
    5877:	84 c0                	test   %al,%al
    5879:	74 40                	je     58bb <DbgPrint+0x7b>
    587b:	0f 29 84 24 10 01 00 	movaps %xmm0,0x110(%rsp)
    5882:	00 
    5883:	0f 29 8c 24 20 01 00 	movaps %xmm1,0x120(%rsp)
    588a:	00 
    588b:	0f 29 94 24 30 01 00 	movaps %xmm2,0x130(%rsp)
    5892:	00 
    5893:	0f 29 9c 24 40 01 00 	movaps %xmm3,0x140(%rsp)
    589a:	00 
    589b:	0f 29 a4 24 50 01 00 	movaps %xmm4,0x150(%rsp)
    58a2:	00 
    58a3:	0f 29 ac 24 60 01 00 	movaps %xmm5,0x160(%rsp)
    58aa:	00 
    58ab:	0f 29 b4 24 70 01 00 	movaps %xmm6,0x170(%rsp)
    58b2:	00 
    58b3:	0f 29 bc 24 80 01 00 	movaps %xmm7,0x180(%rsp)
    58ba:	00 
    if (!(EFIDebug & mask)) {
    58bb:	48 89 d8             	mov    %rbx,%rax
    58be:	48 23 05 0b 5f 00 00 	and    0x5f0b(%rip),%rax        # b7d0 <EFIDebug>
    58c5:	75 19                	jne    58e0 <DbgPrint+0xa0>
}
    58c7:	48 81 c4 98 01 00 00 	add    $0x198,%rsp
    58ce:	31 c0                	xor    %eax,%eax
    58d0:	5b                   	pop    %rbx
    58d1:	5d                   	pop    %rbp
    58d2:	41 5c                	pop    %r12
    58d4:	41 5d                	pop    %r13
    58d6:	c3                   	ret    
    58d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    58de:	00 00 
    va_start (args, fmt);
    58e0:	48 8d 84 24 c0 01 00 	lea    0x1c0(%rsp),%rax
    58e7:	00 
    ZeroMem (&ps, sizeof(ps));
    58e8:	4c 8d 6c 24 40       	lea    0x40(%rsp),%r13
    58ed:	be 98 00 00 00       	mov    $0x98,%esi
    va_start (args, fmt);
    58f2:	c7 44 24 28 10 00 00 	movl   $0x10,0x28(%rsp)
    58f9:	00 
    58fa:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    ZeroMem (&ps, sizeof(ps));
    58ff:	4c 89 ef             	mov    %r13,%rdi
    va_start (args, fmt);
    5902:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    5909:	00 
    590a:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    590f:	c7 44 24 2c 30 00 00 	movl   $0x30,0x2c(%rsp)
    5916:	00 
    ZeroMem (&ps, sizeof(ps));
    5917:	e8 d4 e0 ff ff       	call   39f0 <ZeroMem>
    va_copy(ps.args, args);
    591c:	f3 0f 6f 44 24 28    	movdqu 0x28(%rsp),%xmm0
    ps.fmt.Ascii = TRUE;
    5922:	c6 44 24 40 01       	movb   $0x1,0x40(%rsp)
    ps.Output = _DbgOut;
    5927:	48 8d 05 b2 ea ff ff 	lea    -0x154e(%rip),%rax        # 43e0 <_DbgOut>
    592e:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
    5935:	00 
    DbgOut = LibRuntimeDebugOut;
    5936:	48 8b 15 b3 63 00 00 	mov    0x63b3(%rip),%rdx        # bcf0 <LibRuntimeDebugOut>
    va_copy(ps.args, args);
    593d:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    ps.fmt.pc = fmt;
    5942:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
    ps.Attr = EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_RED);
    5947:	48 c7 84 24 90 00 00 	movq   $0x47,0x90(%rsp)
    594e:	00 47 00 00 00 
    va_copy(ps.args, args);
    5953:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    5958:	0f 11 44 24 58       	movups %xmm0,0x58(%rsp)
    if (!DbgOut) {
    595d:	48 85 d2             	test   %rdx,%rdx
    5960:	0f 84 b2 00 00 00    	je     5a18 <DbgPrint+0x1d8>
        ps.Attr = DbgOut->Mode->Attribute;
    5966:	48 8b 42 48          	mov    0x48(%rdx),%rax
    596a:	4c 63 60 08          	movslq 0x8(%rax),%r12
        ps.Context = DbgOut;
    596e:	48 89 94 24 c8 00 00 	mov    %rdx,0xc8(%rsp)
    5975:	00 
        ps.Attr = DbgOut->Mode->Attribute;
    5976:	4c 89 a4 24 90 00 00 	mov    %r12,0x90(%rsp)
    597d:	00 
        ps.SetAttr = (INTN (EFIAPI *)(VOID *, UINTN))  DbgOut->SetAttribute;
    597e:	48 8b 72 28          	mov    0x28(%rdx),%rsi
        ps.Attr = DbgOut->Mode->Attribute;
    5982:	4c 89 e0             	mov    %r12,%rax
    5985:	25 f0 00 00 00       	and    $0xf0,%eax
        ps.SetAttr = (INTN (EFIAPI *)(VOID *, UINTN))  DbgOut->SetAttribute;
    598a:	48 89 b4 24 c0 00 00 	mov    %rsi,0xc0(%rsp)
    5991:	00 
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    5992:	89 c2                	mov    %eax,%edx
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    5994:	89 c1                	mov    %eax,%ecx
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    5996:	83 c8 0e             	or     $0xe,%eax
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    5999:	83 ca 07             	or     $0x7,%edx
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    599c:	83 c9 0f             	or     $0xf,%ecx
        attr = ps.AttrHighlight;
    599f:	f6 c3 02             	test   $0x2,%bl
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    59a2:	48 89 94 24 a0 00 00 	mov    %rdx,0xa0(%rsp)
    59a9:	00 
        attr = ps.AttrHighlight;
    59aa:	48 0f 45 d1          	cmovne %rcx,%rdx
        attr = ps.AttrError;
    59ae:	f7 c3 00 00 00 80    	test   $0x80000000,%ebx
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    59b4:	48 89 8c 24 a8 00 00 	mov    %rcx,0xa8(%rsp)
    59bb:	00 
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    59bc:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
    59c3:	00 
        attr = ps.AttrError;
    59c4:	48 0f 45 d0          	cmovne %rax,%rdx
    if (ps.SetAttr) {
    59c8:	48 85 f6             	test   %rsi,%rsi
    59cb:	74 12                	je     59df <DbgPrint+0x19f>
        ps.Attr = attr;
    59cd:	48 89 94 24 90 00 00 	mov    %rdx,0x90(%rsp)
    59d4:	00 
        uefi_call_wrapper(ps.SetAttr, 2, ps.Context, attr);
    59d5:	48 8b 8c 24 c8 00 00 	mov    0xc8(%rsp),%rcx
    59dc:	00 
    59dd:	ff d6                	call   *%rsi
    _Print (&ps);
    59df:	4c 89 ef             	mov    %r13,%rdi
    59e2:	e8 49 f4 ff ff       	call   4e30 <_Print>
    if (ps.SetAttr) {
    59e7:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
    59ee:	00 
    59ef:	48 85 c0             	test   %rax,%rax
    59f2:	0f 84 cf fe ff ff    	je     58c7 <DbgPrint+0x87>
        uefi_call_wrapper(ps.SetAttr, 2, ps.Context, SavedAttribute);
    59f8:	48 8b 8c 24 c8 00 00 	mov    0xc8(%rsp),%rcx
    59ff:	00 
    5a00:	4c 89 e2             	mov    %r12,%rdx
    5a03:	ff d0                	call   *%rax
}
    5a05:	48 81 c4 98 01 00 00 	add    $0x198,%rsp
    5a0c:	31 c0                	xor    %eax,%eax
    5a0e:	5b                   	pop    %rbx
    5a0f:	5d                   	pop    %rbp
    5a10:	41 5c                	pop    %r12
    5a12:	41 5d                	pop    %r13
    5a14:	c3                   	ret    
    5a15:	0f 1f 00             	nopl   (%rax)
        DbgOut = ST->StdErr;
    5a18:	48 8b 05 a9 62 00 00 	mov    0x62a9(%rip),%rax        # bcc8 <ST>
    5a1f:	48 8b 50 50          	mov    0x50(%rax),%rdx
    if (DbgOut) {
    5a23:	48 85 d2             	test   %rdx,%rdx
    5a26:	0f 85 3a ff ff ff    	jne    5966 <DbgPrint+0x126>
    if (ps.SetAttr) {
    5a2c:	b8 4e 00 00 00       	mov    $0x4e,%eax
    5a31:	b9 4f 00 00 00       	mov    $0x4f,%ecx
    5a36:	ba 47 00 00 00       	mov    $0x47,%edx
    5a3b:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
    5a42:	00 
    5a43:	41 bc 47 00 00 00    	mov    $0x47,%r12d
    5a49:	e9 51 ff ff ff       	jmp    599f <DbgPrint+0x15f>
    5a4e:	66 90                	xchg   %ax,%ax

0000000000005a50 <_PoolCatPrint>:
{
    5a50:	f3 0f 1e fa          	endbr64 
    5a54:	41 56                	push   %r14
    5a56:	41 55                	push   %r13
    5a58:	49 89 cd             	mov    %rcx,%r13
    5a5b:	41 54                	push   %r12
    5a5d:	49 89 d4             	mov    %rdx,%r12
    5a60:	55                   	push   %rbp
    5a61:	48 89 fd             	mov    %rdi,%rbp
    5a64:	53                   	push   %rbx
    5a65:	48 89 f3             	mov    %rsi,%rbx
    ZeroMem (&ps, sizeof(ps));
    5a68:	be 98 00 00 00       	mov    $0x98,%esi
{
    5a6d:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    ZeroMem (&ps, sizeof(ps));
    5a74:	49 89 e6             	mov    %rsp,%r14
    5a77:	4c 89 f7             	mov    %r14,%rdi
    5a7a:	e8 71 df ff ff       	call   39f0 <ZeroMem>
    ps.Output  = Output;
    5a7f:	4c 89 6c 24 78       	mov    %r13,0x78(%rsp)
    _Print (&ps);
    5a84:	4c 89 f7             	mov    %r14,%rdi
    ps.Context = spc;
    5a87:	4c 89 a4 24 88 00 00 	mov    %r12,0x88(%rsp)
    5a8e:	00 
    ps.fmt.pw = fmt;
    5a8f:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
    va_copy(ps.args, args);
    5a94:	f3 0f 6f 03          	movdqu (%rbx),%xmm0
    5a98:	0f 11 44 24 18       	movups %xmm0,0x18(%rsp)
    5a9d:	48 8b 43 10          	mov    0x10(%rbx),%rax
    5aa1:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    _Print (&ps);
    5aa6:	e8 85 f3 ff ff       	call   4e30 <_Print>
}
    5aab:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    5ab2:	5b                   	pop    %rbx
    5ab3:	5d                   	pop    %rbp
    5ab4:	41 5c                	pop    %r12
    5ab6:	41 5d                	pop    %r13
    5ab8:	41 5e                	pop    %r14
    5aba:	c3                   	ret    
    5abb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000005ac0 <UnicodeVSPrint>:
{
    5ac0:	f3 0f 1e fa          	endbr64 
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5ac4:	48 d1 ee             	shr    %rsi
{
    5ac7:	48 83 ec 28          	sub    $0x28,%rsp
    5acb:	49 89 c8             	mov    %rcx,%r8
    5ace:	49 89 f9             	mov    %rdi,%r9
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5ad1:	48 83 ee 01          	sub    $0x1,%rsi
{
    5ad5:	48 89 d7             	mov    %rdx,%rdi
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5ad8:	48 89 e2             	mov    %rsp,%rdx
    spc.str    = Str;
    5adb:	4c 89 0c 24          	mov    %r9,(%rsp)
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5adf:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5ae4:	48 8d 0d 25 e9 ff ff 	lea    -0x16db(%rip),%rcx        # 4410 <_SPrint>
    5aeb:	4c 89 c6             	mov    %r8,%rsi
    spc.len    = 0;
    5aee:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    5af5:	00 00 
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5af7:	e8 54 ff ff ff       	call   5a50 <_PoolCatPrint>
}
    5afc:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    5b01:	48 83 c4 28          	add    $0x28,%rsp
    5b05:	c3                   	ret    
    5b06:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    5b0d:	00 00 00 

0000000000005b10 <VPoolPrint>:
{
    5b10:	f3 0f 1e fa          	endbr64 
    5b14:	41 55                	push   %r13
    5b16:	41 54                	push   %r12
    5b18:	49 89 f4             	mov    %rsi,%r12
    ZeroMem (&spc, sizeof(spc));
    5b1b:	be 18 00 00 00       	mov    $0x18,%esi
{
    5b20:	55                   	push   %rbp
    5b21:	48 89 fd             	mov    %rdi,%rbp
    5b24:	48 83 ec 20          	sub    $0x20,%rsp
    ZeroMem (&spc, sizeof(spc));
    5b28:	49 89 e5             	mov    %rsp,%r13
    5b2b:	4c 89 ef             	mov    %r13,%rdi
    5b2e:	e8 bd de ff ff       	call   39f0 <ZeroMem>
    _PoolCatPrint (fmt, args, &spc, _PoolPrint);
    5b33:	4c 89 ea             	mov    %r13,%rdx
    5b36:	4c 89 e6             	mov    %r12,%rsi
    5b39:	48 89 ef             	mov    %rbp,%rdi
    5b3c:	48 8d 0d fd e9 ff ff 	lea    -0x1603(%rip),%rcx        # 4540 <_PoolPrint>
    5b43:	e8 08 ff ff ff       	call   5a50 <_PoolCatPrint>
}
    5b48:	48 8b 04 24          	mov    (%rsp),%rax
    5b4c:	48 83 c4 20          	add    $0x20,%rsp
    5b50:	5d                   	pop    %rbp
    5b51:	41 5c                	pop    %r12
    5b53:	41 5d                	pop    %r13
    5b55:	c3                   	ret    
    5b56:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    5b5d:	00 00 00 

0000000000005b60 <CatPrint>:
{
    5b60:	f3 0f 1e fa          	endbr64 
    5b64:	53                   	push   %rbx
    5b65:	48 89 fb             	mov    %rdi,%rbx
    5b68:	48 89 f7             	mov    %rsi,%rdi
    5b6b:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
    5b72:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    5b77:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    5b7c:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    5b81:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    5b86:	84 c0                	test   %al,%al
    5b88:	74 37                	je     5bc1 <CatPrint+0x61>
    5b8a:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    5b8f:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    5b94:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    5b99:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    5ba0:	00 
    5ba1:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    5ba8:	00 
    5ba9:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    5bb0:	00 
    5bb1:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    5bb8:	00 
    5bb9:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    5bc0:	00 
    va_start (args, fmt);
    5bc1:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    5bc8:	00 
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    5bc9:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    5bce:	48 89 da             	mov    %rbx,%rdx
    va_start (args, fmt);
    5bd1:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
    5bd8:	00 
    5bd9:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    5bde:	48 8d 0d 5b e9 ff ff 	lea    -0x16a5(%rip),%rcx        # 4540 <_PoolPrint>
    va_start (args, fmt);
    5be5:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    5bea:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    5bef:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    5bf6:	00 
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    5bf7:	e8 54 fe ff ff       	call   5a50 <_PoolCatPrint>
    return Str->str;
    5bfc:	48 8b 03             	mov    (%rbx),%rax
}
    5bff:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
    5c06:	5b                   	pop    %rbx
    5c07:	c3                   	ret    
    5c08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    5c0f:	00 

0000000000005c10 <PoolPrint>:
{
    5c10:	f3 0f 1e fa          	endbr64 
    5c14:	41 54                	push   %r12
    5c16:	55                   	push   %rbp
    5c17:	48 89 fd             	mov    %rdi,%rbp
    5c1a:	48 81 ec e8 00 00 00 	sub    $0xe8,%rsp
    5c21:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
    5c26:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
    5c2b:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
    5c30:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
    5c35:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
    5c3a:	84 c0                	test   %al,%al
    5c3c:	74 3a                	je     5c78 <PoolPrint+0x68>
    5c3e:	0f 29 44 24 60       	movaps %xmm0,0x60(%rsp)
    5c43:	0f 29 4c 24 70       	movaps %xmm1,0x70(%rsp)
    5c48:	0f 29 94 24 80 00 00 	movaps %xmm2,0x80(%rsp)
    5c4f:	00 
    5c50:	0f 29 9c 24 90 00 00 	movaps %xmm3,0x90(%rsp)
    5c57:	00 
    5c58:	0f 29 a4 24 a0 00 00 	movaps %xmm4,0xa0(%rsp)
    5c5f:	00 
    5c60:	0f 29 ac 24 b0 00 00 	movaps %xmm5,0xb0(%rsp)
    5c67:	00 
    5c68:	0f 29 b4 24 c0 00 00 	movaps %xmm6,0xc0(%rsp)
    5c6f:	00 
    5c70:	0f 29 bc 24 d0 00 00 	movaps %xmm7,0xd0(%rsp)
    5c77:	00 
    ZeroMem (&spc, sizeof(spc));
    5c78:	49 89 e4             	mov    %rsp,%r12
    va_start (args, fmt);
    5c7b:	48 8d 84 24 00 01 00 	lea    0x100(%rsp),%rax
    5c82:	00 
    ZeroMem (&spc, sizeof(spc));
    5c83:	be 18 00 00 00       	mov    $0x18,%esi
    va_start (args, fmt);
    5c88:	c7 44 24 18 08 00 00 	movl   $0x8,0x18(%rsp)
    5c8f:	00 
    5c90:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    ZeroMem (&spc, sizeof(spc));
    5c95:	4c 89 e7             	mov    %r12,%rdi
    va_start (args, fmt);
    5c98:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
    5c9d:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    5ca2:	c7 44 24 1c 30 00 00 	movl   $0x30,0x1c(%rsp)
    5ca9:	00 
    ZeroMem (&spc, sizeof(spc));
    5caa:	e8 41 dd ff ff       	call   39f0 <ZeroMem>
    _PoolCatPrint (fmt, args, &spc, _PoolPrint);
    5caf:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    5cb4:	4c 89 e2             	mov    %r12,%rdx
    5cb7:	48 89 ef             	mov    %rbp,%rdi
    5cba:	48 8d 0d 7f e8 ff ff 	lea    -0x1781(%rip),%rcx        # 4540 <_PoolPrint>
    5cc1:	e8 8a fd ff ff       	call   5a50 <_PoolCatPrint>
}
    5cc6:	48 8b 04 24          	mov    (%rsp),%rax
    5cca:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    5cd1:	5d                   	pop    %rbp
    5cd2:	41 5c                	pop    %r12
    5cd4:	c3                   	ret    
    5cd5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    5cdc:	00 00 00 00 

0000000000005ce0 <UnicodeSPrint>:
{
    5ce0:	f3 0f 1e fa          	endbr64 
    5ce4:	48 81 ec e8 00 00 00 	sub    $0xe8,%rsp
    5ceb:	49 89 fa             	mov    %rdi,%r10
    5cee:	48 89 d7             	mov    %rdx,%rdi
    5cf1:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
    5cf6:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
    5cfb:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
    5d00:	84 c0                	test   %al,%al
    5d02:	74 3a                	je     5d3e <UnicodeSPrint+0x5e>
    5d04:	0f 29 44 24 60       	movaps %xmm0,0x60(%rsp)
    5d09:	0f 29 4c 24 70       	movaps %xmm1,0x70(%rsp)
    5d0e:	0f 29 94 24 80 00 00 	movaps %xmm2,0x80(%rsp)
    5d15:	00 
    5d16:	0f 29 9c 24 90 00 00 	movaps %xmm3,0x90(%rsp)
    5d1d:	00 
    5d1e:	0f 29 a4 24 a0 00 00 	movaps %xmm4,0xa0(%rsp)
    5d25:	00 
    5d26:	0f 29 ac 24 b0 00 00 	movaps %xmm5,0xb0(%rsp)
    5d2d:	00 
    5d2e:	0f 29 b4 24 c0 00 00 	movaps %xmm6,0xc0(%rsp)
    5d35:	00 
    5d36:	0f 29 bc 24 d0 00 00 	movaps %xmm7,0xd0(%rsp)
    5d3d:	00 
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5d3e:	48 d1 ee             	shr    %rsi
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5d41:	48 89 e2             	mov    %rsp,%rdx
    va_start (args, fmt);
    5d44:	48 8d 84 24 f0 00 00 	lea    0xf0(%rsp),%rax
    5d4b:	00 
    5d4c:	c7 44 24 18 18 00 00 	movl   $0x18,0x18(%rsp)
    5d53:	00 
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5d54:	48 83 ee 01          	sub    $0x1,%rsi
    va_start (args, fmt);
    5d58:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5d5d:	48 8d 0d ac e6 ff ff 	lea    -0x1954(%rip),%rcx        # 4410 <_SPrint>
    va_start (args, fmt);
    5d64:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5d69:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5d6e:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    va_start (args, fmt);
    5d73:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    5d78:	c7 44 24 1c 30 00 00 	movl   $0x30,0x1c(%rsp)
    5d7f:	00 
    spc.str    = Str;
    5d80:	4c 89 14 24          	mov    %r10,(%rsp)
    spc.len    = 0;
    5d84:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    5d8b:	00 00 
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5d8d:	e8 be fc ff ff       	call   5a50 <_PoolCatPrint>
}
    5d92:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    5d97:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    5d9e:	c3                   	ret    
    5d9f:	90                   	nop

0000000000005da0 <AsciiVSPrint>:
{
    5da0:	f3 0f 1e fa          	endbr64 
    5da4:	41 57                	push   %r15
    5da6:	49 89 d7             	mov    %rdx,%r15
    5da9:	41 56                	push   %r14
    5dab:	49 89 ce             	mov    %rcx,%r14
    5dae:	41 55                	push   %r13
    5db0:	49 89 f5             	mov    %rsi,%r13
    5db3:	41 54                	push   %r12
        return 0;
    5db5:	45 31 e4             	xor    %r12d,%r12d
{
    5db8:	55                   	push   %rbp
    5db9:	53                   	push   %rbx
    5dba:	48 89 fb             	mov    %rdi,%rbx
    UnicodeStr = AllocatePool(StrSize * sizeof(CHAR16));
    5dbd:	48 8d 3c 36          	lea    (%rsi,%rsi,1),%rdi
{
    5dc1:	48 83 ec 28          	sub    $0x28,%rsp
    UnicodeStr = AllocatePool(StrSize * sizeof(CHAR16));
    5dc5:	e8 e6 da ff ff       	call   38b0 <AllocatePool>
    if (!UnicodeStr)
    5dca:	48 85 c0             	test   %rax,%rax
    5dcd:	74 7f                	je     5e4e <AsciiVSPrint+0xae>
    UnicodeFmt = PoolPrint(L"%a", fmt);
    5dcf:	4c 89 fe             	mov    %r15,%rsi
    5dd2:	48 89 c5             	mov    %rax,%rbp
    5dd5:	48 8d 3d c4 89 00 00 	lea    0x89c4(%rip),%rdi        # e7a0 <_DYNAMIC+0x27a0>
    5ddc:	31 c0                	xor    %eax,%eax
    5dde:	e8 2d fe ff ff       	call   5c10 <PoolPrint>
    5de3:	49 89 c7             	mov    %rax,%r15
    if (!UnicodeFmt) {
    5de6:	48 85 c0             	test   %rax,%rax
    5de9:	74 5b                	je     5e46 <AsciiVSPrint+0xa6>
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5deb:	49 d1 ed             	shr    %r13
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5dee:	48 89 c7             	mov    %rax,%rdi
    5df1:	48 89 e2             	mov    %rsp,%rdx
    5df4:	4c 89 f6             	mov    %r14,%rsi
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5df7:	49 83 ed 01          	sub    $0x1,%r13
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5dfb:	48 8d 0d 0e e6 ff ff 	lea    -0x19f2(%rip),%rcx        # 4410 <_SPrint>
    spc.str    = Str;
    5e02:	48 89 2c 24          	mov    %rbp,(%rsp)
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    5e06:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
    spc.len    = 0;
    5e0b:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    5e12:	00 00 
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    5e14:	e8 37 fc ff ff       	call   5a50 <_PoolCatPrint>
    return spc.len;
    5e19:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
    FreePool(UnicodeFmt);
    5e1e:	4c 89 ff             	mov    %r15,%rdi
    5e21:	e8 aa db ff ff       	call   39d0 <FreePool>
    for (i = 0; i < Len; i++)
    5e26:	4d 85 e4             	test   %r12,%r12
    5e29:	74 16                	je     5e41 <AsciiVSPrint+0xa1>
    5e2b:	31 c0                	xor    %eax,%eax
    5e2d:	0f 1f 00             	nopl   (%rax)
        Str[i] = (CHAR8)UnicodeStr[i];
    5e30:	0f b7 54 45 00       	movzwl 0x0(%rbp,%rax,2),%edx
    5e35:	88 14 03             	mov    %dl,(%rbx,%rax,1)
    for (i = 0; i < Len; i++)
    5e38:	48 83 c0 01          	add    $0x1,%rax
    5e3c:	4c 39 e0             	cmp    %r12,%rax
    5e3f:	75 ef                	jne    5e30 <AsciiVSPrint+0x90>
    Str[Len] = 0;
    5e41:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
    FreePool(UnicodeStr);
    5e46:	48 89 ef             	mov    %rbp,%rdi
    5e49:	e8 82 db ff ff       	call   39d0 <FreePool>
}
    5e4e:	48 83 c4 28          	add    $0x28,%rsp
    5e52:	4c 89 e0             	mov    %r12,%rax
    5e55:	5b                   	pop    %rbx
    5e56:	5d                   	pop    %rbp
    5e57:	41 5c                	pop    %r12
    5e59:	41 5d                	pop    %r13
    5e5b:	41 5e                	pop    %r14
    5e5d:	41 5f                	pop    %r15
    5e5f:	c3                   	ret    

0000000000005e60 <_IPrint>:
{
    5e60:	f3 0f 1e fa          	endbr64 
    5e64:	41 57                	push   %r15
    5e66:	49 89 f7             	mov    %rsi,%r15
    ZeroMem (&ps, sizeof(ps));
    5e69:	be 98 00 00 00       	mov    $0x98,%esi
{
    5e6e:	41 56                	push   %r14
    5e70:	49 89 fe             	mov    %rdi,%r14
    5e73:	41 55                	push   %r13
    5e75:	49 89 cd             	mov    %rcx,%r13
    5e78:	41 54                	push   %r12
    5e7a:	55                   	push   %rbp
    5e7b:	4c 89 cd             	mov    %r9,%rbp
    5e7e:	53                   	push   %rbx
    5e7f:	48 89 d3             	mov    %rdx,%rbx
    5e82:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    ZeroMem (&ps, sizeof(ps));
    5e89:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
{
    5e8e:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
    ZeroMem (&ps, sizeof(ps));
    5e93:	4c 89 e7             	mov    %r12,%rdi
    5e96:	e8 55 db ff ff       	call   39f0 <ZeroMem>
    ps.Output  = (INTN (EFIAPI *)(VOID *, CHAR16 *)) Out->OutputString;
    5e9b:	48 8b 43 08          	mov    0x8(%rbx),%rax
    ps.Context = Out;
    5e9f:	48 89 9c 24 b8 00 00 	mov    %rbx,0xb8(%rsp)
    5ea6:	00 
    ps.Output  = (INTN (EFIAPI *)(VOID *, CHAR16 *)) Out->OutputString;
    5ea7:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
    5eae:	00 
    ps.SetAttr = (INTN (EFIAPI *)(VOID *, UINTN))  Out->SetAttribute;
    5eaf:	48 8b 43 28          	mov    0x28(%rbx),%rax
    5eb3:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
    5eba:	00 
    ps.Attr = Out->Mode->Attribute;
    5ebb:	48 8b 43 48          	mov    0x48(%rbx),%rax
    5ebf:	48 63 50 08          	movslq 0x8(%rax),%rdx
    5ec3:	48 89 d0             	mov    %rdx,%rax
    5ec6:	48 89 94 24 80 00 00 	mov    %rdx,0x80(%rsp)
    5ecd:	00 
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    5ece:	25 f0 00 00 00       	and    $0xf0,%eax
    5ed3:	89 c2                	mov    %eax,%edx
    5ed5:	83 ca 07             	or     $0x7,%edx
    5ed8:	48 89 94 24 90 00 00 	mov    %rdx,0x90(%rsp)
    5edf:	00 
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    5ee0:	89 c2                	mov    %eax,%edx
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    5ee2:	83 c8 0e             	or     $0xe,%eax
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    5ee5:	83 ca 0f             	or     $0xf,%edx
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    5ee8:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    5eef:	00 
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    5ef0:	48 89 94 24 98 00 00 	mov    %rdx,0x98(%rsp)
    5ef7:	00 
    if (fmt) {
    5ef8:	4d 85 ed             	test   %r13,%r13
    5efb:	74 4b                	je     5f48 <_IPrint+0xe8>
        ps.fmt.pw = fmt;
    5efd:	4c 89 6c 24 40       	mov    %r13,0x40(%rsp)
    va_copy(ps.args, args);
    5f02:	f3 0f 6f 45 00       	movdqu 0x0(%rbp),%xmm0
    5f07:	48 8b 45 10          	mov    0x10(%rbp),%rax
    5f0b:	0f 11 44 24 48       	movups %xmm0,0x48(%rsp)
    5f10:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    if (Column != (UINTN) -1) {
    5f15:	49 83 fe ff          	cmp    $0xffffffffffffffff,%r14
    5f19:	74 0c                	je     5f27 <_IPrint+0xc7>
        uefi_call_wrapper(Out->SetCursorPosition, 3, Out, Column, Row);
    5f1b:	4d 89 f8             	mov    %r15,%r8
    5f1e:	4c 89 f2             	mov    %r14,%rdx
    5f21:	48 89 d9             	mov    %rbx,%rcx
    5f24:	ff 53 38             	call   *0x38(%rbx)
    back = _Print (&ps);
    5f27:	4c 89 e7             	mov    %r12,%rdi
    5f2a:	e8 01 ef ff ff       	call   4e30 <_Print>
}
    5f2f:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5f36:	5b                   	pop    %rbx
    5f37:	5d                   	pop    %rbp
    5f38:	41 5c                	pop    %r12
    5f3a:	41 5d                	pop    %r13
    5f3c:	41 5e                	pop    %r14
    5f3e:	41 5f                	pop    %r15
    5f40:	c3                   	ret    
    5f41:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        ps.fmt.pc = fmta;
    5f48:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
        ps.fmt.Ascii = TRUE;
    5f4d:	c6 44 24 30 01       	movb   $0x1,0x30(%rsp)
        ps.fmt.pc = fmta;
    5f52:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    5f57:	eb a9                	jmp    5f02 <_IPrint+0xa2>
    5f59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000005f60 <Print>:
{
    5f60:	f3 0f 1e fa          	endbr64 
    5f64:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    5f6b:	49 89 fa             	mov    %rdi,%r10
    5f6e:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    5f73:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    5f78:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    5f7d:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    5f82:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    5f87:	84 c0                	test   %al,%al
    5f89:	74 37                	je     5fc2 <Print+0x62>
    5f8b:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    5f90:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    5f95:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    5f9a:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    5fa1:	00 
    5fa2:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    5fa9:	00 
    5faa:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    5fb1:	00 
    5fb2:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    5fb9:	00 
    5fba:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    5fc1:	00 
    va_start (args, fmt);
    5fc2:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    5fc9:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    5fca:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    5fcf:	45 31 c0             	xor    %r8d,%r8d
    5fd2:	4c 89 d1             	mov    %r10,%rcx
    va_start (args, fmt);
    5fd5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    5fda:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    5fdf:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    5fe6:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    va_start (args, fmt);
    5fed:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    5ff2:	48 8b 05 cf 5c 00 00 	mov    0x5ccf(%rip),%rax        # bcc8 <ST>
    va_start (args, fmt);
    5ff9:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
    6000:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6001:	48 8b 50 40          	mov    0x40(%rax),%rdx
    va_start (args, fmt);
    6005:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    600c:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    600d:	e8 4e fe ff ff       	call   5e60 <_IPrint>
}
    6012:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    6019:	c3                   	ret    
    601a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000006020 <VPrint>:
{
    6020:	f3 0f 1e fa          	endbr64 
    return _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6024:	48 8b 05 9d 5c 00 00 	mov    0x5c9d(%rip),%rax        # bcc8 <ST>
{
    602b:	48 89 f9             	mov    %rdi,%rcx
    602e:	49 89 f1             	mov    %rsi,%r9
    return _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6031:	45 31 c0             	xor    %r8d,%r8d
    6034:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    603b:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    6042:	48 8b 50 40          	mov    0x40(%rax),%rdx
    6046:	e9 15 fe ff ff       	jmp    5e60 <_IPrint>
    604b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000006050 <PrintAt>:
{
    6050:	f3 0f 1e fa          	endbr64 
    6054:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    605b:	49 89 d2             	mov    %rdx,%r10
    605e:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    6063:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6068:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    606d:	84 c0                	test   %al,%al
    606f:	74 37                	je     60a8 <PrintAt+0x58>
    6071:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    6076:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    607b:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6080:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    6087:	00 
    6088:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    608f:	00 
    6090:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    6097:	00 
    6098:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    609f:	00 
    60a0:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    60a7:	00 
    va_start (args, fmt);
    60a8:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    60af:	00 
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    60b0:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    60b5:	45 31 c0             	xor    %r8d,%r8d
    60b8:	4c 89 d1             	mov    %r10,%rcx
    va_start (args, fmt);
    60bb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    60c0:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    60c5:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    60ca:	48 8b 05 f7 5b 00 00 	mov    0x5bf7(%rip),%rax        # bcc8 <ST>
    va_start (args, fmt);
    60d1:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%rsp)
    60d8:	00 
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    60d9:	48 8b 50 40          	mov    0x40(%rax),%rdx
    va_start (args, fmt);
    60dd:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    60e4:	00 
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    60e5:	e8 76 fd ff ff       	call   5e60 <_IPrint>
}
    60ea:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    60f1:	c3                   	ret    
    60f2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    60f9:	00 00 00 00 
    60fd:	0f 1f 00             	nopl   (%rax)

0000000000006100 <IPrint>:
{
    6100:	f3 0f 1e fa          	endbr64 
    6104:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    610b:	49 89 fa             	mov    %rdi,%r10
    610e:	49 89 f3             	mov    %rsi,%r11
    6111:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    6116:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    611b:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6120:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    6125:	84 c0                	test   %al,%al
    6127:	74 37                	je     6160 <IPrint+0x60>
    6129:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    612e:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    6133:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6138:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    613f:	00 
    6140:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    6147:	00 
    6148:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    614f:	00 
    6150:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    6157:	00 
    6158:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    615f:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
    6160:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    6165:	45 31 c0             	xor    %r8d,%r8d
    6168:	4c 89 d9             	mov    %r11,%rcx
    616b:	4c 89 d2             	mov    %r10,%rdx
    va_start (args, fmt);
    616e:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    6175:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
    6176:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    617d:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    va_start (args, fmt);
    6184:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
    618b:	00 
    618c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    6191:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    6196:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    619d:	00 
    619e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
    61a3:	e8 b8 fc ff ff       	call   5e60 <_IPrint>
}
    61a8:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    61af:	c3                   	ret    

00000000000061b0 <IPrintAt>:
{
    61b0:	f3 0f 1e fa          	endbr64 
    61b4:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    61bb:	49 89 fa             	mov    %rdi,%r10
    61be:	48 89 f7             	mov    %rsi,%rdi
    61c1:	48 89 d6             	mov    %rdx,%rsi
    61c4:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    61c9:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    61ce:	84 c0                	test   %al,%al
    61d0:	74 37                	je     6209 <IPrintAt+0x59>
    61d2:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    61d7:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    61dc:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    61e1:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    61e8:	00 
    61e9:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    61f0:	00 
    61f1:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    61f8:	00 
    61f9:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    6200:	00 
    6201:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    6208:	00 
    va_start (args, fmt);
    6209:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    6210:	00 
    back = _IPrint (Column, Row, Out, fmt, NULL, args);
    6211:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    6216:	45 31 c0             	xor    %r8d,%r8d
    6219:	4c 89 d2             	mov    %r10,%rdx
    va_start (args, fmt);
    621c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    6221:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    6226:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%rsp)
    622d:	00 
    622e:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    6235:	00 
    6236:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint (Column, Row, Out, fmt, NULL, args);
    623b:	e8 20 fc ff ff       	call   5e60 <_IPrint>
}
    6240:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    6247:	c3                   	ret    
    6248:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    624f:	00 

0000000000006250 <AsciiPrint>:
{
    6250:	f3 0f 1e fa          	endbr64 
    6254:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    625b:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    6260:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    6265:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    626a:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    626f:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    6274:	84 c0                	test   %al,%al
    6276:	74 37                	je     62af <AsciiPrint+0x5f>
    6278:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    627d:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    6282:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6287:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    628e:	00 
    628f:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    6296:	00 
    6297:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    629e:	00 
    629f:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    62a6:	00 
    62a7:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    62ae:	00 
    va_start (args, fmt);
    62af:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    62b6:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    62b7:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    62bc:	49 89 f8             	mov    %rdi,%r8
    62bf:	31 c9                	xor    %ecx,%ecx
    va_start (args, fmt);
    62c1:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    62c6:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    62cb:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    62d2:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    va_start (args, fmt);
    62d9:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    62de:	48 8b 05 e3 59 00 00 	mov    0x59e3(%rip),%rax        # bcc8 <ST>
    va_start (args, fmt);
    62e5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
    62ec:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    62ed:	48 8b 50 40          	mov    0x40(%rax),%rdx
    va_start (args, fmt);
    62f1:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    62f8:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    62f9:	e8 62 fb ff ff       	call   5e60 <_IPrint>
}
    62fe:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    6305:	c3                   	ret    
    6306:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    630d:	00 00 00 

0000000000006310 <DumpHex>:
    IN UINTN        Indent,
    IN UINTN        Offset,
    IN UINTN        DataSize,
    IN VOID         *UserData
    )
{
    6310:	f3 0f 1e fa          	endbr64 
    6314:	41 57                	push   %r15
    6316:	41 56                	push   %r14
    6318:	49 89 d6             	mov    %rdx,%r14
    631b:	41 55                	push   %r13
    631d:	41 54                	push   %r12
    631f:	49 89 cc             	mov    %rcx,%r12
    6322:	55                   	push   %rbp
    6323:	53                   	push   %rbx
    6324:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    UINTN           TempColumn;
    UINTN           ScreenSize;
    CHAR16          ReturnStr[1];


    uefi_call_wrapper(ST->ConOut->QueryMode, 4, ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    632b:	48 8b 05 96 59 00 00 	mov    0x5996(%rip),%rax        # bcc8 <ST>
{
    6332:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    uefi_call_wrapper(ST->ConOut->QueryMode, 4, ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    6337:	4c 8d 4c 24 68       	lea    0x68(%rsp),%r9
    633c:	4c 8d 44 24 60       	lea    0x60(%rsp),%r8
    6341:	48 8b 40 40          	mov    0x40(%rax),%rax
{
    6345:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    uefi_call_wrapper(ST->ConOut->QueryMode, 4, ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    634a:	48 8b 50 48          	mov    0x48(%rax),%rdx
    634e:	48 89 c1             	mov    %rax,%rcx
    6351:	48 63 52 04          	movslq 0x4(%rdx),%rdx
    6355:	ff 50 18             	call   *0x18(%rax)
    ScreenCount = 0;
    ScreenSize -= 2;
    6358:	48 83 6c 24 68 02    	subq   $0x2,0x68(%rsp)

    Data = UserData;
    while (DataSize) {
    635e:	4d 85 f6             	test   %r14,%r14
    6361:	0f 84 51 01 00 00    	je     64b8 <DumpHex+0x1a8>
    ScreenCount = 0;
    6367:	45 31 db             	xor    %r11d,%r11d
            //
            // If ScreenSize == 0 we have the console redirected so don't
            //  block updates
            //
            ScreenCount = 0;
            Print (L"Press Enter to continue :");
    636a:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    636f:	4d 89 f2             	mov    %r14,%r10
    6372:	4c 8d 7c 24 70       	lea    0x70(%rsp),%r15
    6377:	48 8d 1d 42 54 00 00 	lea    0x5442(%rip),%rbx        # b7c0 <Hex>
    637e:	48 8d 84 24 92 00 00 	lea    0x92(%rsp),%rax
    6385:	00 
            Val[Index*3+2] = (Index == 7)?'-':' ';
    6386:	41 bd 20 00 00 00    	mov    $0x20,%r13d
            Print (L"Press Enter to continue :");
    638c:	4d 89 de             	mov    %r11,%r14
    638f:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    6394:	48 8d 84 24 90 00 00 	lea    0x90(%rsp),%rax
    639b:	00 
    639c:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    63a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if (Size > DataSize) {
    63a8:	49 83 fa 0f          	cmp    $0xf,%r10
    63ac:	0f 86 1e 01 00 00    	jbe    64d0 <DumpHex+0x1c0>
    63b2:	49 83 ea 10          	sub    $0x10,%r10
        Size = 16;
    63b6:	bd 10 00 00 00       	mov    $0x10,%ebp
            c = Data[Index];
    63bb:	41 0f b6 04 24       	movzbl (%r12),%eax
            Val[Index*3+0] = Hex[c>>4];
    63c0:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
            Val[Index*3+2] = (Index == 7)?'-':' ';
    63c5:	bf 20 00 00 00       	mov    $0x20,%edi
            Str[Index] = (c < ' ' || c > 'z') ? '.' : c;
    63ca:	41 b8 2e 00 00 00    	mov    $0x2e,%r8d
            Val[Index*3+2] = (Index == 7)?'-':' ';
    63d0:	41 b9 2d 00 00 00    	mov    $0x2d,%r9d
            Val[Index*3+0] = Hex[c>>4];
    63d6:	89 c2                	mov    %eax,%edx
    63d8:	c0 ea 04             	shr    $0x4,%dl
    63db:	83 e2 0f             	and    $0xf,%edx
    63de:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    63e2:	88 94 24 90 00 00 00 	mov    %dl,0x90(%rsp)
            Val[Index*3+1] = Hex[c&0xF];
    63e9:	48 89 c2             	mov    %rax,%rdx
    63ec:	83 e2 0f             	and    $0xf,%edx
    63ef:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    63f3:	88 94 24 91 00 00 00 	mov    %dl,0x91(%rsp)
        for (Index=0; Index < Size; Index += 1) {
    63fa:	31 d2                	xor    %edx,%edx
    63fc:	eb 35                	jmp    6433 <DumpHex+0x123>
    63fe:	66 90                	xchg   %ax,%ax
            c = Data[Index];
    6400:	41 0f b6 04 14       	movzbl (%r12,%rdx,1),%eax
            Val[Index*3+0] = Hex[c>>4];
    6405:	89 c7                	mov    %eax,%edi
    6407:	40 c0 ef 04          	shr    $0x4,%dil
    640b:	83 e7 0f             	and    $0xf,%edi
    640e:	0f b6 3c 3b          	movzbl (%rbx,%rdi,1),%edi
    6412:	40 88 7e 01          	mov    %dil,0x1(%rsi)
            Val[Index*3+1] = Hex[c&0xF];
    6416:	48 89 c7             	mov    %rax,%rdi
    6419:	83 e7 0f             	and    $0xf,%edi
            Val[Index*3+2] = (Index == 7)?'-':' ';
    641c:	48 83 fa 07          	cmp    $0x7,%rdx
            Val[Index*3+1] = Hex[c&0xF];
    6420:	0f b6 3c 3b          	movzbl (%rbx,%rdi,1),%edi
    6424:	40 88 7e 02          	mov    %dil,0x2(%rsi)
            Val[Index*3+2] = (Index == 7)?'-':' ';
    6428:	44 89 ef             	mov    %r13d,%edi
    642b:	41 0f 44 f9          	cmove  %r9d,%edi
    642f:	48 83 c6 03          	add    $0x3,%rsi
    6433:	40 88 3e             	mov    %dil,(%rsi)
            Str[Index] = (c < ' ' || c > 'z') ? '.' : c;
    6436:	8d 78 e0             	lea    -0x20(%rax),%edi
    6439:	40 80 ff 5b          	cmp    $0x5b,%dil
    643d:	41 0f 43 c0          	cmovae %r8d,%eax
    6441:	41 88 04 17          	mov    %al,(%r15,%rdx,1)
        for (Index=0; Index < Size; Index += 1) {
    6445:	48 83 c2 01          	add    $0x1,%rdx
    6449:	48 39 d5             	cmp    %rdx,%rbp
    644c:	75 b2                	jne    6400 <DumpHex+0xf0>
        Val[Index*3] = 0;
    644e:	48 8d 44 6d 00       	lea    0x0(%rbp,%rbp,2),%rax
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    6453:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
    6458:	4d 89 f9             	mov    %r15,%r9
        Data += Size;
    645b:	49 01 ec             	add    %rbp,%r12
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    645e:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
        Val[Index*3] = 0;
    6463:	4c 89 54 24 30       	mov    %r10,0x30(%rsp)
        ScreenCount++;
    6468:	49 83 c6 01          	add    $0x1,%r14
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    646c:	48 8d 15 33 83 00 00 	lea    0x8333(%rip),%rdx        # e7a6 <_DYNAMIC+0x27a6>
        Val[Index*3] = 0;
    6473:	c6 84 04 90 00 00 00 	movb   $0x0,0x90(%rsp,%rax,1)
    647a:	00 
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    647b:	48 8d 3d 26 83 00 00 	lea    0x8326(%rip),%rdi        # e7a8 <_DYNAMIC+0x27a8>
    6482:	31 c0                	xor    %eax,%eax
    6484:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
        Str[Index] = 0;
    6489:	c6 44 2c 70 00       	movb   $0x0,0x70(%rsp,%rbp,1)
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    648e:	e8 cd fa ff ff       	call   5f60 <Print>
        Offset += Size;
    6493:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
        if (ScreenCount >= ScreenSize && ScreenSize != 0) {
    6498:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    649d:	4c 8b 54 24 30       	mov    0x30(%rsp),%r10
        Offset += Size;
    64a2:	48 01 e9             	add    %rbp,%rcx
        if (ScreenCount >= ScreenSize && ScreenSize != 0) {
    64a5:	4c 39 f0             	cmp    %r14,%rax
    64a8:	77 05                	ja     64af <DumpHex+0x19f>
    64aa:	48 85 c0             	test   %rax,%rax
    64ad:	75 31                	jne    64e0 <DumpHex+0x1d0>
    while (DataSize) {
    64af:	4d 85 d2             	test   %r10,%r10
    64b2:	0f 85 f0 fe ff ff    	jne    63a8 <DumpHex+0x98>
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
            Print (L"\n");
        }

    }
}
    64b8:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    64bf:	5b                   	pop    %rbx
    64c0:	5d                   	pop    %rbp
    64c1:	41 5c                	pop    %r12
    64c3:	41 5d                	pop    %r13
    64c5:	41 5e                	pop    %r14
    64c7:	41 5f                	pop    %r15
    64c9:	c3                   	ret    
    64ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    64d0:	4c 89 d5             	mov    %r10,%rbp
    64d3:	45 31 d2             	xor    %r10d,%r10d
    64d6:	e9 e0 fe ff ff       	jmp    63bb <DumpHex+0xab>
    64db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            Print (L"Press Enter to continue :");
    64e0:	48 8d 3d e9 82 00 00 	lea    0x82e9(%rip),%rdi        # e7d0 <_DYNAMIC+0x27d0>
    64e7:	31 c0                	xor    %eax,%eax
    64e9:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
            ScreenCount = 0;
    64ee:	45 31 f6             	xor    %r14d,%r14d
            Print (L"Press Enter to continue :");
    64f1:	e8 6a fa ff ff       	call   5f60 <Print>
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
    64f6:	48 8d 74 24 5e       	lea    0x5e(%rsp),%rsi
    64fb:	ba 01 00 00 00       	mov    $0x1,%edx
    6500:	48 8d 3d fd 82 00 00 	lea    0x82fd(%rip),%rdi        # e804 <_DYNAMIC+0x2804>
    6507:	e8 64 cd ff ff       	call   3270 <Input>
            Print (L"\n");
    650c:	48 8d 3d f3 82 00 00 	lea    0x82f3(%rip),%rdi        # e806 <_DYNAMIC+0x2806>
    6513:	31 c0                	xor    %eax,%eax
    6515:	e8 46 fa ff ff       	call   5f60 <Print>
            ScreenCount = 0;
    651a:	4c 8b 54 24 30       	mov    0x30(%rsp),%r10
    651f:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    6524:	eb 89                	jmp    64af <DumpHex+0x19f>
    6526:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    652d:	00 00 00 

0000000000006530 <pek>:


VOID
pek ()
{
    6530:	f3 0f 1e fa          	endbr64 
    6534:	48 83 ec 38          	sub    $0x38,%rsp
	EFI_INPUT_KEY efi_input_key;
	UINTN index;
	uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, L"\tHit any key to continue\r\n");
    6538:	48 8b 05 89 57 00 00 	mov    0x5789(%rip),%rax        # bcc8 <ST>
    653f:	48 8d 15 ca 82 00 00 	lea    0x82ca(%rip),%rdx        # e810 <_DYNAMIC+0x2810>
    6546:	48 8b 40 40          	mov    0x40(%rax),%rax
    654a:	48 89 c1             	mov    %rax,%rcx
    654d:	ff 50 08             	call   *0x8(%rax)
	uefi_call_wrapper(ST->BootServices->WaitForEvent, 3, 1, &ST->ConIn->WaitForKey, &index);
    6550:	48 8b 05 71 57 00 00 	mov    0x5771(%rip),%rax        # bcc8 <ST>
    6557:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    655c:	b9 01 00 00 00       	mov    $0x1,%ecx
    6561:	48 8b 70 30          	mov    0x30(%rax),%rsi
    6565:	48 8b 40 60          	mov    0x60(%rax),%rax
    6569:	48 8d 56 10          	lea    0x10(%rsi),%rdx
    656d:	ff 50 60             	call   *0x60(%rax)
	uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &efi_input_key);
    6570:	48 8b 05 51 57 00 00 	mov    0x5751(%rip),%rax        # bcc8 <ST>
    6577:	48 8d 54 24 24       	lea    0x24(%rsp),%rdx
    657c:	48 8b 40 30          	mov    0x30(%rax),%rax
    6580:	48 89 c1             	mov    %rax,%rcx
    6583:	ff 50 08             	call   *0x8(%rax)
}
    6586:	48 83 c4 38          	add    $0x38,%rsp
    658a:	c3                   	ret    
    658b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000006590 <getch>:

CHAR16
getch ()
{
    6590:	f3 0f 1e fa          	endbr64 
    6594:	48 83 ec 38          	sub    $0x38,%rsp
	EFI_INPUT_KEY efi_input_key;
	UINTN index;
	uefi_call_wrapper(ST->BootServices->WaitForEvent, 3, 1, &ST->ConIn->WaitForKey, &index);
    6598:	48 8b 05 29 57 00 00 	mov    0x5729(%rip),%rax        # bcc8 <ST>
    659f:	b9 01 00 00 00       	mov    $0x1,%ecx
    65a4:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    65a9:	48 8b 70 30          	mov    0x30(%rax),%rsi
    65ad:	48 8b 40 60          	mov    0x60(%rax),%rax
    65b1:	48 8d 56 10          	lea    0x10(%rsi),%rdx
    65b5:	ff 50 60             	call   *0x60(%rax)
	uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &efi_input_key);
    65b8:	48 8b 05 09 57 00 00 	mov    0x5709(%rip),%rax        # bcc8 <ST>
    65bf:	48 8d 54 24 24       	lea    0x24(%rsp),%rdx
    65c4:	48 8b 40 30          	mov    0x30(%rax),%rax
    65c8:	48 89 c1             	mov    %rax,%rcx
    65cb:	ff 50 08             	call   *0x8(%rax)
	return efi_input_key.UnicodeChar;
}
    65ce:	0f b7 44 24 26       	movzwl 0x26(%rsp),%eax
    65d3:	48 83 c4 38          	add    $0x38,%rsp
    65d7:	c3                   	ret    
    65d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    65df:	00 

00000000000065e0 <putch>:



VOID
putch (CHAR16 cc)
{ CHAR16 * pcc=L"";
    65e0:	f3 0f 1e fa          	endbr64 
   *pcc= cc;
    65e4:	66 89 3d 19 82 00 00 	mov    %di,0x8219(%rip)        # e804 <_DYNAMIC+0x2804>
   Output (pcc);
    65eb:	48 8d 3d 12 82 00 00 	lea    0x8212(%rip),%rdi        # e804 <_DYNAMIC+0x2804>
    65f2:	e9 79 cb ff ff       	jmp    3170 <Output>
    65f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    65fe:	00 00 

0000000000006600 <StrCmp>:
StrCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    )
// compare strings
{
    6600:	f3 0f 1e fa          	endbr64 
    return RtStrCmp(s1, s2);
    6604:	e9 37 07 00 00       	jmp    6d40 <RtStrCmp>
    6609:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006610 <StrnCmp>:
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2,
    IN UINTN    len
    )
// compare strings
{
    6610:	f3 0f 1e fa          	endbr64 
    while (*s1  &&  len) {
    6614:	0f b7 07             	movzwl (%rdi),%eax
    6617:	66 85 c0             	test   %ax,%ax
    661a:	75 21                	jne    663d <StrnCmp+0x2d>
    661c:	eb 2a                	jmp    6648 <StrnCmp+0x38>
    661e:	66 90                	xchg   %ax,%ax
        if (*s1 != *s2) {
    6620:	0f b7 0e             	movzwl (%rsi),%ecx
    6623:	66 39 c1             	cmp    %ax,%cx
    6626:	75 2a                	jne    6652 <StrnCmp+0x42>
    while (*s1  &&  len) {
    6628:	0f b7 47 02          	movzwl 0x2(%rdi),%eax
            break;
        }

        s1  += 1;
    662c:	48 83 c7 02          	add    $0x2,%rdi
        s2  += 1;
    6630:	48 83 c6 02          	add    $0x2,%rsi
        len -= 1;
    6634:	48 83 ea 01          	sub    $0x1,%rdx
    while (*s1  &&  len) {
    6638:	66 85 c0             	test   %ax,%ax
    663b:	74 0b                	je     6648 <StrnCmp+0x38>
    663d:	48 85 d2             	test   %rdx,%rdx
    6640:	75 de                	jne    6620 <StrnCmp+0x10>
    }

    return len ? *s1 - *s2 : 0;
    6642:	31 c0                	xor    %eax,%eax
}
    6644:	c3                   	ret    
    6645:	0f 1f 00             	nopl   (%rax)
    return len ? *s1 - *s2 : 0;
    6648:	31 c0                	xor    %eax,%eax
    664a:	48 85 d2             	test   %rdx,%rdx
    664d:	74 f5                	je     6644 <StrnCmp+0x34>
    664f:	0f b7 0e             	movzwl (%rsi),%ecx
    6652:	29 c8                	sub    %ecx,%eax
    6654:	48 98                	cltq   
    6656:	c3                   	ret    
    6657:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    665e:	00 00 

0000000000006660 <LibStubStriCmp>:
LibStubStriCmp (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This EFI_UNUSED,
    IN CHAR16                           *s1,
    IN CHAR16                           *s2
    )
{
    6660:	f3 0f 1e fa          	endbr64 
    6664:	57                   	push   %rdi
    6665:	48 89 d7             	mov    %rdx,%rdi
    6668:	56                   	push   %rsi
    6669:	4c 89 c6             	mov    %r8,%rsi
    666c:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    6673:	0f 29 34 24          	movaps %xmm6,(%rsp)
    6677:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    667c:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    6682:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    6688:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    668e:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    6694:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    669a:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    66a0:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    66a7:	00 00 
    66a9:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    66b0:	00 00 
    return RtStrCmp(s1, s2);
    66b2:	e8 89 06 00 00       	call   6d40 <RtStrCmp>
    return StrCmp (s1, s2);
}
    66b7:	0f 28 34 24          	movaps (%rsp),%xmm6
    66bb:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    66c0:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    66c6:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    66cc:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    66d2:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    66d8:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    66de:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    66e4:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    66eb:	00 00 
    66ed:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    66f4:	00 00 
    66f6:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    66fd:	5e                   	pop    %rsi
    66fe:	5f                   	pop    %rdi
    66ff:	c3                   	ret    

0000000000006700 <LibStubStrLwrUpr>:
VOID EFIAPI
LibStubStrLwrUpr (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This EFI_UNUSED,
    IN CHAR16                           *Str EFI_UNUSED
    )
{
    6700:	f3 0f 1e fa          	endbr64 
}
    6704:	c3                   	ret    
    6705:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    670c:	00 00 00 00 

0000000000006710 <StriCmp>:
StriCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    )
// compare strings
{
    6710:	f3 0f 1e fa          	endbr64 
    6714:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    6718:	48 8b 05 a1 4d 00 00 	mov    0x4da1(%rip),%rax        # b4c0 <UnicodeInterface>
{
    671f:	48 89 fa             	mov    %rdi,%rdx
    6722:	49 89 f0             	mov    %rsi,%r8
    	return UnicodeInterface->StriColl(UnicodeInterface, (CHAR16 *)s1, (CHAR16 *)s2);
    6725:	48 89 c1             	mov    %rax,%rcx
    else
	return uefi_call_wrapper(UnicodeInterface->StriColl, 3, UnicodeInterface, (CHAR16 *)s1, (CHAR16 *)s2);
    6728:	ff 10                	call   *(%rax)
}
    672a:	48 83 c4 28          	add    $0x28,%rsp
    672e:	c3                   	ret    
    672f:	90                   	nop

0000000000006730 <StrLwr>:
VOID
StrLwr (
    IN CHAR16   *Str
    )
// lwoer case string
{
    6730:	f3 0f 1e fa          	endbr64 
    6734:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    6738:	48 8b 05 81 4d 00 00 	mov    0x4d81(%rip),%rax        # b4c0 <UnicodeInterface>
{
    673f:	48 89 fa             	mov    %rdi,%rdx
    	UnicodeInterface->StrLwr(UnicodeInterface, Str);
    6742:	48 89 c1             	mov    %rax,%rcx
    else uefi_call_wrapper(UnicodeInterface->StrLwr, 2, UnicodeInterface, Str);
    6745:	ff 50 10             	call   *0x10(%rax)
}
    6748:	48 83 c4 28          	add    $0x28,%rsp
    674c:	c3                   	ret    
    674d:	0f 1f 00             	nopl   (%rax)

0000000000006750 <StrUpr>:
VOID
StrUpr (
    IN CHAR16   *Str
    )
// upper case string
{
    6750:	f3 0f 1e fa          	endbr64 
    6754:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    6758:	48 8b 05 61 4d 00 00 	mov    0x4d61(%rip),%rax        # b4c0 <UnicodeInterface>
{
    675f:	48 89 fa             	mov    %rdi,%rdx
        UnicodeInterface->StrUpr(UnicodeInterface, Str);
    6762:	48 89 c1             	mov    %rax,%rcx
    else uefi_call_wrapper(UnicodeInterface->StrUpr, 2, UnicodeInterface, Str);
    6765:	ff 50 18             	call   *0x18(%rax)
}
    6768:	48 83 c4 28          	add    $0x28,%rsp
    676c:	c3                   	ret    
    676d:	0f 1f 00             	nopl   (%rax)

0000000000006770 <StrCpy>:
StrCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
// copy strings
{
    6770:	f3 0f 1e fa          	endbr64 
    RtStrCpy (Dest, Src);
    6774:	e9 17 06 00 00       	jmp    6d90 <RtStrCpy>
    6779:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006780 <StrnCpy>:
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
// copy strings
{
    6780:	f3 0f 1e fa          	endbr64 
    RtStrnCpy (Dest, Src, Len);
    6784:	e9 37 06 00 00       	jmp    6dc0 <RtStrnCpy>
    6789:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006790 <StpCpy>:
StpCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
// copy strings
{
    6790:	f3 0f 1e fa          	endbr64 
    return RtStpCpy (Dest, Src);
    6794:	e9 97 06 00 00       	jmp    6e30 <RtStpCpy>
    6799:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000067a0 <StpnCpy>:
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
// copy strings
{
    67a0:	f3 0f 1e fa          	endbr64 
    return RtStpnCpy (Dest, Src, Len);
    67a4:	e9 b7 06 00 00       	jmp    6e60 <RtStpnCpy>
    67a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000067b0 <StrCat>:
VOID
StrCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
{
    67b0:	f3 0f 1e fa          	endbr64 
    RtStrCat(Dest, Src);
    67b4:	e9 37 07 00 00       	jmp    6ef0 <RtStrCat>
    67b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000067c0 <StrnCat>:
StrnCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
{
    67c0:	f3 0f 1e fa          	endbr64 
    RtStrnCat(Dest, Src, Len);
    67c4:	e9 77 07 00 00       	jmp    6f40 <RtStrnCat>
    67c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000067d0 <StrnLen>:
StrnLen (
    IN CONST CHAR16   *s1,
    IN UINTN           Len
    )
// string length
{
    67d0:	f3 0f 1e fa          	endbr64 
    return RtStrnLen(s1, Len);
    67d4:	e9 27 08 00 00       	jmp    7000 <RtStrnLen>
    67d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000067e0 <StrLen>:
UINTN
StrLen (
    IN CONST CHAR16   *s1
    )
// string length
{
    67e0:	f3 0f 1e fa          	endbr64 
    return RtStrLen(s1);
    67e4:	e9 e7 07 00 00       	jmp    6fd0 <RtStrLen>
    67e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000067f0 <StrSize>:
UINTN
StrSize (
    IN CONST CHAR16   *s1
    )
// string size
{
    67f0:	f3 0f 1e fa          	endbr64 
    return RtStrSize(s1);
    67f4:	e9 47 08 00 00       	jmp    7040 <RtStrSize>
    67f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006800 <StrDuplicate>:
CHAR16 *
StrDuplicate (
    IN CONST CHAR16   *Src
    )
// duplicate a string
{
    6800:	f3 0f 1e fa          	endbr64 
    6804:	41 55                	push   %r13
    6806:	49 89 fd             	mov    %rdi,%r13
    6809:	41 54                	push   %r12
    680b:	53                   	push   %rbx
    680c:	48 83 ec 20          	sub    $0x20,%rsp
    return RtStrSize(s1);
    6810:	e8 2b 08 00 00       	call   7040 <RtStrSize>
    CHAR16      *Dest;
    UINTN       Size;

    Size = StrSize(Src);
    Dest = AllocatePool (Size);
    6815:	48 89 c7             	mov    %rax,%rdi
    return RtStrSize(s1);
    6818:	48 89 c3             	mov    %rax,%rbx
    Dest = AllocatePool (Size);
    681b:	e8 90 d0 ff ff       	call   38b0 <AllocatePool>
    6820:	49 89 c4             	mov    %rax,%r12
    if (Dest) {
    6823:	48 85 c0             	test   %rax,%rax
    6826:	74 0e                	je     6836 <StrDuplicate+0x36>
        CopyMem (Dest, (void *)Src, Size);
    6828:	49 89 d8             	mov    %rbx,%r8
    682b:	4c 89 ea             	mov    %r13,%rdx
    682e:	48 89 c1             	mov    %rax,%rcx
    6831:	e8 7a d2 ff ff       	call   3ab0 <CopyMem>
    }
    return Dest;
}
    6836:	48 83 c4 20          	add    $0x20,%rsp
    683a:	4c 89 e0             	mov    %r12,%rax
    683d:	5b                   	pop    %rbx
    683e:	41 5c                	pop    %r12
    6840:	41 5d                	pop    %r13
    6842:	c3                   	ret    
    6843:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    684a:	00 00 00 00 
    684e:	66 90                	xchg   %ax,%ax

0000000000006850 <strlena>:
UINTN
strlena (
    IN CONST CHAR8    *s1
    )
// string length
{
    6850:	f3 0f 1e fa          	endbr64 
    UINTN        len;

    for (len=0; *s1; s1+=1, len+=1) ;
    6854:	31 c0                	xor    %eax,%eax
    6856:	80 3f 00             	cmpb   $0x0,(%rdi)
    6859:	74 15                	je     6870 <strlena+0x20>
    685b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    6860:	48 83 c0 01          	add    $0x1,%rax
    6864:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
    6868:	75 f6                	jne    6860 <strlena+0x10>
    686a:	c3                   	ret    
    686b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    return len;
}
    6870:	c3                   	ret    
    6871:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6878:	00 00 00 00 
    687c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000006880 <strcmpa>:
strcmpa (
    IN CONST CHAR8    *s1,
    IN CONST CHAR8    *s2
    )
// compare strings
{
    6880:	f3 0f 1e fa          	endbr64 
    while (*s1) {
    6884:	0f b6 07             	movzbl (%rdi),%eax
    6887:	84 c0                	test   %al,%al
    6889:	75 18                	jne    68a3 <strcmpa+0x23>
    688b:	eb 2e                	jmp    68bb <strcmpa+0x3b>
    688d:	0f 1f 00             	nopl   (%rax)
    6890:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
    6894:	48 83 c7 01          	add    $0x1,%rdi
        s2 += 1;
    6898:	48 8d 56 01          	lea    0x1(%rsi),%rdx
    while (*s1) {
    689c:	84 c0                	test   %al,%al
    689e:	74 10                	je     68b0 <strcmpa+0x30>
        s2 += 1;
    68a0:	48 89 d6             	mov    %rdx,%rsi
        if (*s1 != *s2) {
    68a3:	0f b6 16             	movzbl (%rsi),%edx
    68a6:	38 c2                	cmp    %al,%dl
    68a8:	74 e6                	je     6890 <strcmpa+0x10>
    }

    return *s1 - *s2;
    68aa:	29 d0                	sub    %edx,%eax
    68ac:	48 98                	cltq   
}
    68ae:	c3                   	ret    
    68af:	90                   	nop
    return *s1 - *s2;
    68b0:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
    68b4:	31 c0                	xor    %eax,%eax
    68b6:	29 d0                	sub    %edx,%eax
    68b8:	48 98                	cltq   
}
    68ba:	c3                   	ret    
    return *s1 - *s2;
    68bb:	0f b6 16             	movzbl (%rsi),%edx
    68be:	31 c0                	xor    %eax,%eax
    68c0:	eb e8                	jmp    68aa <strcmpa+0x2a>
    68c2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    68c9:	00 00 00 00 
    68cd:	0f 1f 00             	nopl   (%rax)

00000000000068d0 <strncmpa>:
    IN CONST CHAR8    *s1,
    IN CONST CHAR8    *s2,
    IN UINTN    len
    )
// compare strings
{
    68d0:	f3 0f 1e fa          	endbr64 
    while (*s1  &&  len) {
    68d4:	0f b6 07             	movzbl (%rdi),%eax
    68d7:	84 c0                	test   %al,%al
    68d9:	75 20                	jne    68fb <strncmpa+0x2b>
    68db:	eb 2b                	jmp    6908 <strncmpa+0x38>
    68dd:	0f 1f 00             	nopl   (%rax)
        if (*s1 != *s2) {
    68e0:	0f b6 0e             	movzbl (%rsi),%ecx
    68e3:	38 c1                	cmp    %al,%cl
    68e5:	75 2b                	jne    6912 <strncmpa+0x42>
    while (*s1  &&  len) {
    68e7:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
            break;
        }

        s1  += 1;
    68eb:	48 83 c7 01          	add    $0x1,%rdi
        s2  += 1;
    68ef:	48 83 c6 01          	add    $0x1,%rsi
        len -= 1;
    68f3:	48 83 ea 01          	sub    $0x1,%rdx
    while (*s1  &&  len) {
    68f7:	84 c0                	test   %al,%al
    68f9:	74 0d                	je     6908 <strncmpa+0x38>
    68fb:	48 85 d2             	test   %rdx,%rdx
    68fe:	75 e0                	jne    68e0 <strncmpa+0x10>
    }

    return len ? *s1 - *s2 : 0;
    6900:	31 c0                	xor    %eax,%eax
}
    6902:	c3                   	ret    
    6903:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    return len ? *s1 - *s2 : 0;
    6908:	31 c0                	xor    %eax,%eax
    690a:	48 85 d2             	test   %rdx,%rdx
    690d:	74 f3                	je     6902 <strncmpa+0x32>
    690f:	0f b6 0e             	movzbl (%rsi),%ecx
    6912:	29 c8                	sub    %ecx,%eax
    6914:	48 98                	cltq   
    6916:	c3                   	ret    
    6917:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    691e:	00 00 

0000000000006920 <xtoi>:
UINTN
xtoi (
    CONST CHAR16  *str
    )
// convert hex string to uint
{
    6920:	f3 0f 1e fa          	endbr64 
    6924:	0f 1f 40 00          	nopl   0x0(%rax)
    UINTN       u;
    CHAR16      c;

    // skip preceeding white space
    while (*str == ' ') {
    6928:	0f b7 17             	movzwl (%rdi),%edx
        str += 1;
    692b:	48 83 c7 02          	add    $0x2,%rdi
    while (*str == ' ') {
    692f:	66 83 fa 20          	cmp    $0x20,%dx
    6933:	74 f3                	je     6928 <xtoi+0x8>
    }

    // convert hex digits
    u = 0;
    6935:	31 c0                	xor    %eax,%eax
    while ((c = *(str++))) {
    6937:	66 85 d2             	test   %dx,%dx
    693a:	75 26                	jne    6962 <xtoi+0x42>
    693c:	eb 5a                	jmp    6998 <xtoi+0x78>
    693e:	66 90                	xchg   %ax,%ax
        if (c >= 'a'  &&  c <= 'f') {
            c -= 'a' - 'A';
    6940:	83 ea 20             	sub    $0x20,%edx
        }

        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F')) {
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    6943:	48 c1 e0 04          	shl    $0x4,%rax
    6947:	0f b7 ca             	movzwl %dx,%ecx
    694a:	ba 37 00 00 00       	mov    $0x37,%edx
    while ((c = *(str++))) {
    694f:	48 83 c7 02          	add    $0x2,%rdi
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    6953:	48 29 d1             	sub    %rdx,%rcx
    while ((c = *(str++))) {
    6956:	0f b7 57 fe          	movzwl -0x2(%rdi),%edx
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    695a:	48 09 c8             	or     %rcx,%rax
    while ((c = *(str++))) {
    695d:	66 85 d2             	test   %dx,%dx
    6960:	74 3e                	je     69a0 <xtoi+0x80>
        if (c >= 'a'  &&  c <= 'f') {
    6962:	8d 4a 9f             	lea    -0x61(%rdx),%ecx
    6965:	66 83 f9 05          	cmp    $0x5,%cx
    6969:	76 d5                	jbe    6940 <xtoi+0x20>
        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F')) {
    696b:	8d 4a d0             	lea    -0x30(%rdx),%ecx
    696e:	66 83 f9 09          	cmp    $0x9,%cx
    6972:	76 09                	jbe    697d <xtoi+0x5d>
    6974:	8d 4a bf             	lea    -0x41(%rdx),%ecx
    6977:	66 83 f9 05          	cmp    $0x5,%cx
    697b:	77 1b                	ja     6998 <xtoi+0x78>
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    697d:	48 c1 e0 04          	shl    $0x4,%rax
    6981:	66 83 fa 41          	cmp    $0x41,%dx
    6985:	0f b7 ca             	movzwl %dx,%ecx
    6988:	48 19 d2             	sbb    %rdx,%rdx
    698b:	48 83 e2 f9          	and    $0xfffffffffffffff9,%rdx
    698f:	48 83 c2 37          	add    $0x37,%rdx
    6993:	eb ba                	jmp    694f <xtoi+0x2f>
    6995:	0f 1f 00             	nopl   (%rax)
            break;
        }
    }

    return u;
}
    6998:	c3                   	ret    
    6999:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    69a0:	c3                   	ret    
    69a1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    69a8:	00 00 00 00 
    69ac:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000069b0 <Atoi>:
UINTN
Atoi (
    CONST CHAR16  *str
    )
// convert hex string to uint
{
    69b0:	f3 0f 1e fa          	endbr64 
    69b4:	0f 1f 40 00          	nopl   0x0(%rax)
    UINTN       u;
    CHAR16      c;

    // skip preceeding white space
    while (*str == ' ') {
    69b8:	0f b7 07             	movzwl (%rdi),%eax
        str += 1;
    69bb:	48 83 c7 02          	add    $0x2,%rdi
    while (*str == ' ') {
    69bf:	66 83 f8 20          	cmp    $0x20,%ax
    69c3:	74 f3                	je     69b8 <Atoi+0x8>
    }

    // convert digits
    u = 0;
    69c5:	45 31 c0             	xor    %r8d,%r8d
    while ((c = *(str++))) {
    69c8:	66 85 c0             	test   %ax,%ax
    69cb:	75 19                	jne    69e6 <Atoi+0x36>
    69cd:	eb 20                	jmp    69ef <Atoi+0x3f>
    69cf:	90                   	nop
        if (c >= '0' && c <= '9') {
            u = (u * 10) + c - '0';
    69d0:	4b 8d 14 80          	lea    (%r8,%r8,4),%rdx
    while ((c = *(str++))) {
    69d4:	48 83 c7 02          	add    $0x2,%rdi
            u = (u * 10) + c - '0';
    69d8:	4c 8d 44 50 d0       	lea    -0x30(%rax,%rdx,2),%r8
    while ((c = *(str++))) {
    69dd:	0f b7 47 fe          	movzwl -0x2(%rdi),%eax
    69e1:	66 85 c0             	test   %ax,%ax
    69e4:	74 09                	je     69ef <Atoi+0x3f>
        if (c >= '0' && c <= '9') {
    69e6:	8d 50 d0             	lea    -0x30(%rax),%edx
    69e9:	66 83 fa 09          	cmp    $0x9,%dx
    69ed:	76 e1                	jbe    69d0 <Atoi+0x20>
            break;
        }
    }

    return u;
}
    69ef:	4c 89 c0             	mov    %r8,%rax
    69f2:	c3                   	ret    
    69f3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    69fa:	00 00 00 00 
    69fe:	66 90                	xchg   %ax,%ax

0000000000006a00 <MetaMatch>:
BOOLEAN
MetaMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    )
{
    6a00:	f3 0f 1e fa          	endbr64 
    6a04:	55                   	push   %rbp
    6a05:	48 89 fd             	mov    %rdi,%rbp
    6a08:	53                   	push   %rbx
    6a09:	48 89 f3             	mov    %rsi,%rbx
    6a0c:	48 83 ec 08          	sub    $0x8,%rsp
    6a10:	48 8d 75 02          	lea    0x2(%rbp),%rsi
    CHAR16  c, p, l;

    for (; ;) {
        p = *Pattern;
    6a14:	0f b7 03             	movzwl (%rbx),%eax
            // End of pattern.  If end of string, TRUE match
            return *String ? FALSE : TRUE;

        case '*':
            // Match zero or more chars
            while (*String) {
    6a17:	0f b7 4e fe          	movzwl -0x2(%rsi),%ecx
    6a1b:	48 8d 6e fe          	lea    -0x2(%rsi),%rbp
        Pattern += 1;
    6a1f:	48 83 c3 02          	add    $0x2,%rbx
        switch (p) {
    6a23:	66 83 f8 3f          	cmp    $0x3f,%ax
    6a27:	0f 84 eb 00 00 00    	je     6b18 <MetaMatch+0x118>
    6a2d:	77 51                	ja     6a80 <MetaMatch+0x80>
    6a2f:	66 85 c0             	test   %ax,%ax
    6a32:	0f 84 08 01 00 00    	je     6b40 <MetaMatch+0x140>
    6a38:	66 83 f8 2a          	cmp    $0x2a,%ax
    6a3c:	0f 85 ee 00 00 00    	jne    6b30 <MetaMatch+0x130>
            while (*String) {
    6a42:	66 85 c9             	test   %cx,%cx
    6a45:	74 c9                	je     6a10 <MetaMatch+0x10>
                if (MetaMatch (String, Pattern)) {
    6a47:	48 89 de             	mov    %rbx,%rsi
    6a4a:	48 89 ef             	mov    %rbp,%rdi
    6a4d:	e8 ae ff ff ff       	call   6a00 <MetaMatch>
    6a52:	84 c0                	test   %al,%al
    6a54:	75 1a                	jne    6a70 <MetaMatch+0x70>
                    return TRUE;
                }
                String += 1;
    6a56:	48 83 c5 02          	add    $0x2,%rbp
            while (*String) {
    6a5a:	66 83 7d 00 00       	cmpw   $0x0,0x0(%rbp)
    6a5f:	74 af                	je     6a10 <MetaMatch+0x10>
                if (MetaMatch (String, Pattern)) {
    6a61:	48 89 de             	mov    %rbx,%rsi
    6a64:	48 89 ef             	mov    %rbp,%rdi
    6a67:	e8 94 ff ff ff       	call   6a00 <MetaMatch>
    6a6c:	84 c0                	test   %al,%al
    6a6e:	74 e6                	je     6a56 <MetaMatch+0x56>

            String += 1;
            break;
        }
    }
}
    6a70:	48 83 c4 08          	add    $0x8,%rsp
    6a74:	5b                   	pop    %rbx
    6a75:	5d                   	pop    %rbp
    6a76:	c3                   	ret    
    6a77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6a7e:	00 00 
        switch (p) {
    6a80:	66 83 f8 5b          	cmp    $0x5b,%ax
    6a84:	0f 85 a6 00 00 00    	jne    6b30 <MetaMatch+0x130>
            if (!c) {
    6a8a:	66 85 c9             	test   %cx,%cx
    6a8d:	0f 84 8a 00 00 00    	je     6b1d <MetaMatch+0x11d>
            l = 0;
    6a93:	31 d2                	xor    %edx,%edx
    6a95:	eb 10                	jmp    6aa7 <MetaMatch+0xa7>
    6a97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6a9e:	00 00 
    6aa0:	89 c2                	mov    %eax,%edx
                if (c == p) {                       // if char matches
    6aa2:	66 39 c8             	cmp    %cx,%ax
    6aa5:	74 39                	je     6ae0 <MetaMatch+0xe0>
            while ((p = *Pattern++)) {
    6aa7:	0f b7 03             	movzwl (%rbx),%eax
    6aaa:	48 83 c3 02          	add    $0x2,%rbx
    6aae:	66 85 c0             	test   %ax,%ax
    6ab1:	74 3d                	je     6af0 <MetaMatch+0xf0>
                if (p == ']') {
    6ab3:	66 83 f8 5d          	cmp    $0x5d,%ax
    6ab7:	74 64                	je     6b1d <MetaMatch+0x11d>
                if (p == '-') {                     // if range of chars,
    6ab9:	66 83 f8 2d          	cmp    $0x2d,%ax
    6abd:	75 e1                	jne    6aa0 <MetaMatch+0xa0>
                    p = *Pattern;                   // get high range
    6abf:	0f b7 03             	movzwl (%rbx),%eax
                    if (p == 0 || p == ']') {
    6ac2:	66 85 c0             	test   %ax,%ax
    6ac5:	74 56                	je     6b1d <MetaMatch+0x11d>
    6ac7:	66 83 f8 5d          	cmp    $0x5d,%ax
    6acb:	74 50                	je     6b1d <MetaMatch+0x11d>
                    if (c >= l && c <= p) {         // if in range,
    6acd:	66 39 ca             	cmp    %cx,%dx
    6ad0:	77 ce                	ja     6aa0 <MetaMatch+0xa0>
    6ad2:	66 39 c8             	cmp    %cx,%ax
    6ad5:	73 2f                	jae    6b06 <MetaMatch+0x106>
    6ad7:	89 c2                	mov    %eax,%edx
                if (c == p) {                       // if char matches
    6ad9:	66 39 c8             	cmp    %cx,%ax
    6adc:	75 c9                	jne    6aa7 <MetaMatch+0xa7>
    6ade:	66 90                	xchg   %ax,%ax
            while (p && p != ']') {
    6ae0:	66 83 f8 5d          	cmp    $0x5d,%ax
    6ae4:	75 20                	jne    6b06 <MetaMatch+0x106>
    6ae6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6aed:	00 00 00 
    6af0:	48 83 c6 02          	add    $0x2,%rsi
    6af4:	e9 1b ff ff ff       	jmp    6a14 <MetaMatch+0x14>
    6af9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    6b00:	66 83 f8 5d          	cmp    $0x5d,%ax
    6b04:	74 ea                	je     6af0 <MetaMatch+0xf0>
                p = *Pattern;
    6b06:	0f b7 03             	movzwl (%rbx),%eax
                Pattern += 1;
    6b09:	48 83 c3 02          	add    $0x2,%rbx
            while (p && p != ']') {
    6b0d:	66 85 c0             	test   %ax,%ax
    6b10:	75 ee                	jne    6b00 <MetaMatch+0x100>
    6b12:	eb dc                	jmp    6af0 <MetaMatch+0xf0>
    6b14:	0f 1f 40 00          	nopl   0x0(%rax)
            if (!*String) {
    6b18:	66 85 c9             	test   %cx,%cx
    6b1b:	75 d3                	jne    6af0 <MetaMatch+0xf0>
}
    6b1d:	48 83 c4 08          	add    $0x8,%rsp
                return FALSE;
    6b21:	31 c0                	xor    %eax,%eax
}
    6b23:	5b                   	pop    %rbx
    6b24:	5d                   	pop    %rbp
    6b25:	c3                   	ret    
    6b26:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6b2d:	00 00 00 
            if (c != p) {
    6b30:	66 39 c8             	cmp    %cx,%ax
    6b33:	75 e8                	jne    6b1d <MetaMatch+0x11d>
    6b35:	48 83 c6 02          	add    $0x2,%rsi
    6b39:	e9 d6 fe ff ff       	jmp    6a14 <MetaMatch+0x14>
    6b3e:	66 90                	xchg   %ax,%ax
            return *String ? FALSE : TRUE;
    6b40:	66 85 c9             	test   %cx,%cx
    6b43:	0f 94 c0             	sete   %al
}
    6b46:	48 83 c4 08          	add    $0x8,%rsp
    6b4a:	5b                   	pop    %rbx
    6b4b:	5d                   	pop    %rbp
    6b4c:	c3                   	ret    
    6b4d:	0f 1f 00             	nopl   (%rax)

0000000000006b50 <LibStubMetaiMatch>:
LibStubMetaiMatch (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This EFI_UNUSED,
    IN CHAR16                           *String,
    IN CHAR16                           *Pattern
    )
{
    6b50:	f3 0f 1e fa          	endbr64 
    6b54:	57                   	push   %rdi
    6b55:	48 89 d7             	mov    %rdx,%rdi
    6b58:	56                   	push   %rsi
    6b59:	4c 89 c6             	mov    %r8,%rsi
    6b5c:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    6b63:	0f 29 34 24          	movaps %xmm6,(%rsp)
    6b67:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    6b6c:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    6b72:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    6b78:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    6b7e:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    6b84:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    6b8a:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    6b90:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    6b97:	00 00 
    6b99:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    6ba0:	00 00 
    return MetaMatch (String, Pattern);
    6ba2:	e8 59 fe ff ff       	call   6a00 <MetaMatch>
}
    6ba7:	0f 28 34 24          	movaps (%rsp),%xmm6
    6bab:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    6bb0:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    6bb6:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    6bbc:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    6bc2:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    6bc8:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    6bce:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    6bd4:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    6bdb:	00 00 
    6bdd:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    6be4:	00 00 
    6be6:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    6bed:	5e                   	pop    %rsi
    6bee:	5f                   	pop    %rdi
    6bef:	c3                   	ret    

0000000000006bf0 <MetaiMatch>:
BOOLEAN
MetaiMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    )
{
    6bf0:	f3 0f 1e fa          	endbr64 
    6bf4:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    6bf8:	48 8b 05 c1 48 00 00 	mov    0x48c1(%rip),%rax        # b4c0 <UnicodeInterface>
{
    6bff:	48 89 fa             	mov    %rdi,%rdx
    6c02:	49 89 f0             	mov    %rsi,%r8
    	return UnicodeInterface->MetaiMatch(UnicodeInterface, String, Pattern);
    6c05:	48 89 c1             	mov    %rax,%rcx
    else return uefi_call_wrapper(UnicodeInterface->MetaiMatch, 3, UnicodeInterface, String, Pattern);
    6c08:	ff 50 08             	call   *0x8(%rax)
}
    6c0b:	48 83 c4 28          	add    $0x28,%rsp
    6c0f:	c3                   	ret    

0000000000006c10 <RtZeroMem>:
RUNTIMEFUNCTION
RtZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    )
{
    6c10:	f3 0f 1e fa          	endbr64 
    INT8        *pt;

    pt = Buffer;
    while (Size--) {
    6c14:	48 85 f6             	test   %rsi,%rsi
    6c17:	74 14                	je     6c2d <RtZeroMem+0x1d>
    6c19:	48 01 fe             	add    %rdi,%rsi
    6c1c:	0f 1f 40 00          	nopl   0x0(%rax)
        *(pt++) = 0;
    6c20:	48 83 c7 01          	add    $0x1,%rdi
    6c24:	c6 47 ff 00          	movb   $0x0,-0x1(%rdi)
    while (Size--) {
    6c28:	48 39 f7             	cmp    %rsi,%rdi
    6c2b:	75 f3                	jne    6c20 <RtZeroMem+0x10>
    }
}
    6c2d:	c3                   	ret    
    6c2e:	66 90                	xchg   %ax,%ax

0000000000006c30 <RtSetMem>:
RtSetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value
    )
{
    6c30:	f3 0f 1e fa          	endbr64 
    INT8        *pt;

    pt = Buffer;
    while (Size--) {
    6c34:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
    6c38:	48 85 f6             	test   %rsi,%rsi
    6c3b:	74 0f                	je     6c4c <RtSetMem+0x1c>
    6c3d:	0f 1f 00             	nopl   (%rax)
        *(pt++) = Value;
    6c40:	48 83 c7 01          	add    $0x1,%rdi
    6c44:	88 57 ff             	mov    %dl,-0x1(%rdi)
    while (Size--) {
    6c47:	48 39 c7             	cmp    %rax,%rdi
    6c4a:	75 f4                	jne    6c40 <RtSetMem+0x10>
    }
}
    6c4c:	c3                   	ret    
    6c4d:	0f 1f 00             	nopl   (%rax)

0000000000006c50 <RtCopyMem>:
RtCopyMem (
    IN VOID        *Dest,
    IN CONST VOID  *Src,
    IN UINTN       len
    )
{
    6c50:	f3 0f 1e fa          	endbr64 
    CHAR8 *d = (CHAR8*)Dest;
    CHAR8 *s = (CHAR8*)Src;

    if (d == NULL || s == NULL || s == d)
    6c54:	48 85 ff             	test   %rdi,%rdi
    6c57:	0f 94 c0             	sete   %al
    6c5a:	48 39 f7             	cmp    %rsi,%rdi
    6c5d:	0f 94 c1             	sete   %cl
    6c60:	08 c8                	or     %cl,%al
    6c62:	75 2c                	jne    6c90 <RtCopyMem+0x40>
    6c64:	48 85 f6             	test   %rsi,%rsi
    6c67:	74 27                	je     6c90 <RtCopyMem+0x40>
    // we don't end up overwriting source data that we need for the copy.
    if ((d > s) && (d < s + len)) {
        for (d += len, s += len; len--; )
            *--d = *--s;
    } else {
        while (len--)
    6c69:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    if ((d > s) && (d < s + len)) {
    6c6d:	48 39 f7             	cmp    %rsi,%rdi
    6c70:	77 26                	ja     6c98 <RtCopyMem+0x48>
        while (len--)
    6c72:	31 c0                	xor    %eax,%eax
    6c74:	48 85 d2             	test   %rdx,%rdx
    6c77:	74 47                	je     6cc0 <RtCopyMem+0x70>
    6c79:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            *d++ = *s++;
    6c80:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
    6c84:	88 0c 07             	mov    %cl,(%rdi,%rax,1)
        while (len--)
    6c87:	48 83 c0 01          	add    $0x1,%rax
    6c8b:	48 39 c2             	cmp    %rax,%rdx
    6c8e:	75 f0                	jne    6c80 <RtCopyMem+0x30>
    }
}
    6c90:	c3                   	ret    
    6c91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if ((d > s) && (d < s + len)) {
    6c98:	48 8d 0c 16          	lea    (%rsi,%rdx,1),%rcx
    6c9c:	48 39 cf             	cmp    %rcx,%rdi
    6c9f:	73 d1                	jae    6c72 <RtCopyMem+0x22>
        for (d += len, s += len; len--; )
    6ca1:	48 85 d2             	test   %rdx,%rdx
    6ca4:	74 ea                	je     6c90 <RtCopyMem+0x40>
    6ca6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6cad:	00 00 00 
            *--d = *--s;
    6cb0:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
    6cb4:	88 14 07             	mov    %dl,(%rdi,%rax,1)
        for (d += len, s += len; len--; )
    6cb7:	48 83 e8 01          	sub    $0x1,%rax
    6cbb:	73 f3                	jae    6cb0 <RtCopyMem+0x60>
    6cbd:	c3                   	ret    
    6cbe:	66 90                	xchg   %ax,%ax
    6cc0:	c3                   	ret    
    6cc1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6cc8:	00 00 00 00 
    6ccc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000006cd0 <RtCompareMem>:
RtCompareMem (
    IN CONST VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    )
{
    6cd0:	f3 0f 1e fa          	endbr64 
    CONST CHAR8    *d = Dest, *s = Src;
    while (len--) {
    6cd4:	31 c0                	xor    %eax,%eax
    6cd6:	48 85 d2             	test   %rdx,%rdx
    6cd9:	75 0e                	jne    6ce9 <RtCompareMem+0x19>
    6cdb:	eb 26                	jmp    6d03 <RtCompareMem+0x33>
    6cdd:	0f 1f 00             	nopl   (%rax)
    6ce0:	48 83 c0 01          	add    $0x1,%rax
    6ce4:	48 39 c2             	cmp    %rax,%rdx
    6ce7:	74 17                	je     6d00 <RtCompareMem+0x30>
        if (*d != *s) {
    6ce9:	0f b6 0c 07          	movzbl (%rdi,%rax,1),%ecx
    6ced:	44 0f b6 04 06       	movzbl (%rsi,%rax,1),%r8d
    6cf2:	44 38 c1             	cmp    %r8b,%cl
    6cf5:	74 e9                	je     6ce0 <RtCompareMem+0x10>
            return *d - *s;
    6cf7:	0f b6 c1             	movzbl %cl,%eax
    6cfa:	44 29 c0             	sub    %r8d,%eax
    6cfd:	48 98                	cltq   
    6cff:	c3                   	ret    

        d += 1;
        s += 1;
    }

    return 0;
    6d00:	31 c0                	xor    %eax,%eax
    6d02:	c3                   	ret    
}
    6d03:	c3                   	ret    
    6d04:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6d0b:	00 00 00 00 
    6d0f:	90                   	nop

0000000000006d10 <RtCompareGuid>:

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    6d10:	f3 0f 1e fa          	endbr64 
    //

    g1 = (INT32 *) Guid1;
    g2 = (INT32 *) Guid2;

    r  = g1[0] - g2[0];
    6d14:	8b 17                	mov    (%rdi),%edx
    r |= g1[1] - g2[1];
    6d16:	8b 47 04             	mov    0x4(%rdi),%eax
    r  = g1[0] - g2[0];
    6d19:	2b 16                	sub    (%rsi),%edx
    r |= g1[1] - g2[1];
    6d1b:	2b 46 04             	sub    0x4(%rsi),%eax
    6d1e:	09 d0                	or     %edx,%eax
    r |= g1[2] - g2[2];
    6d20:	8b 57 08             	mov    0x8(%rdi),%edx
    6d23:	2b 56 08             	sub    0x8(%rsi),%edx
    6d26:	09 c2                	or     %eax,%edx
    r |= g1[3] - g2[3];
    6d28:	8b 47 0c             	mov    0xc(%rdi),%eax
    6d2b:	2b 46 0c             	sub    0xc(%rsi),%eax
    6d2e:	09 d0                	or     %edx,%eax

    return r;
    6d30:	48 98                	cltq   
}
    6d32:	c3                   	ret    
    6d33:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6d3a:	00 00 00 
    6d3d:	0f 1f 00             	nopl   (%rax)

0000000000006d40 <RtStrCmp>:
RtStrCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    )
// compare strings
{
    6d40:	f3 0f 1e fa          	endbr64 
    while (*s1) {
    6d44:	0f b7 07             	movzwl (%rdi),%eax
    6d47:	66 85 c0             	test   %ax,%ax
    6d4a:	75 18                	jne    6d64 <RtStrCmp+0x24>
    6d4c:	eb 35                	jmp    6d83 <RtStrCmp+0x43>
    6d4e:	66 90                	xchg   %ax,%ax
    6d50:	0f b7 47 02          	movzwl 0x2(%rdi),%eax
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
    6d54:	48 83 c7 02          	add    $0x2,%rdi
        s2 += 1;
    6d58:	48 8d 56 02          	lea    0x2(%rsi),%rdx
    while (*s1) {
    6d5c:	66 85 c0             	test   %ax,%ax
    6d5f:	74 17                	je     6d78 <RtStrCmp+0x38>
        s2 += 1;
    6d61:	48 89 d6             	mov    %rdx,%rsi
        if (*s1 != *s2) {
    6d64:	0f b7 16             	movzwl (%rsi),%edx
    6d67:	66 39 c2             	cmp    %ax,%dx
    6d6a:	74 e4                	je     6d50 <RtStrCmp+0x10>
    }

    return *s1 - *s2;
    6d6c:	29 d0                	sub    %edx,%eax
    6d6e:	48 98                	cltq   
}
    6d70:	c3                   	ret    
    6d71:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    return *s1 - *s2;
    6d78:	0f b7 56 02          	movzwl 0x2(%rsi),%edx
    6d7c:	31 c0                	xor    %eax,%eax
    6d7e:	29 d0                	sub    %edx,%eax
    6d80:	48 98                	cltq   
}
    6d82:	c3                   	ret    
    return *s1 - *s2;
    6d83:	0f b7 16             	movzwl (%rsi),%edx
    6d86:	31 c0                	xor    %eax,%eax
    6d88:	eb e2                	jmp    6d6c <RtStrCmp+0x2c>
    6d8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000006d90 <RtStrCpy>:
RtStrCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
// copy strings
{
    6d90:	f3 0f 1e fa          	endbr64 
    while (*Src) {
    6d94:	eb 15                	jmp    6dab <RtStrCpy+0x1b>
    6d96:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6d9d:	00 00 00 
        *(Dest++) = *(Src++);
    6da0:	66 89 07             	mov    %ax,(%rdi)
    6da3:	48 83 c7 02          	add    $0x2,%rdi
    6da7:	48 83 c6 02          	add    $0x2,%rsi
    while (*Src) {
    6dab:	0f b7 06             	movzwl (%rsi),%eax
    6dae:	66 85 c0             	test   %ax,%ax
    6db1:	75 ed                	jne    6da0 <RtStrCpy+0x10>
    }
    *Dest = 0;
    6db3:	31 c0                	xor    %eax,%eax
    6db5:	66 89 07             	mov    %ax,(%rdi)
}
    6db8:	c3                   	ret    
    6db9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006dc0 <RtStrnCpy>:
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
// copy strings
{
    6dc0:	f3 0f 1e fa          	endbr64 
    6dc4:	41 55                	push   %r13
    6dc6:	41 54                	push   %r12
    6dc8:	49 89 fc             	mov    %rdi,%r12
    6dcb:	55                   	push   %rbp
    IN UINTN           Len
    )
// string length
{
    UINTN i;
    for (i = 0; *s1 && i < Len; i++)
    6dcc:	66 83 3e 00          	cmpw   $0x0,(%rsi)
{
    6dd0:	48 89 f5             	mov    %rsi,%rbp
    for (i = 0; *s1 && i < Len; i++)
    6dd3:	74 4b                	je     6e20 <RtStrnCpy+0x60>
    6dd5:	48 85 d2             	test   %rdx,%rdx
    6dd8:	74 46                	je     6e20 <RtStrnCpy+0x60>
    6dda:	31 c0                	xor    %eax,%eax
    6ddc:	eb 07                	jmp    6de5 <RtStrnCpy+0x25>
    6dde:	66 90                	xchg   %ax,%ax
    6de0:	48 39 c2             	cmp    %rax,%rdx
    6de3:	76 0c                	jbe    6df1 <RtStrnCpy+0x31>
    6de5:	48 83 c0 01          	add    $0x1,%rax
    6de9:	66 83 7c 45 00 00    	cmpw   $0x0,0x0(%rbp,%rax,2)
    6def:	75 ef                	jne    6de0 <RtStrnCpy+0x20>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    6df1:	4c 8d 2c 00          	lea    (%rax,%rax,1),%r13
    if (Size != Len)
    6df5:	48 39 c2             	cmp    %rax,%rdx
    6df8:	74 12                	je     6e0c <RtStrnCpy+0x4c>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    6dfa:	48 29 c2             	sub    %rax,%rdx
    6dfd:	4b 8d 3c 2c          	lea    (%r12,%r13,1),%rdi
    6e01:	48 8d 34 12          	lea    (%rdx,%rdx,1),%rsi
    6e05:	31 d2                	xor    %edx,%edx
    6e07:	e8 24 fe ff ff       	call   6c30 <RtSetMem>
    RtCopyMem(Dest, Src, Size * sizeof(CHAR16));
    6e0c:	4c 89 ea             	mov    %r13,%rdx
    6e0f:	48 89 ee             	mov    %rbp,%rsi
    6e12:	4c 89 e7             	mov    %r12,%rdi
}
    6e15:	5d                   	pop    %rbp
    6e16:	41 5c                	pop    %r12
    6e18:	41 5d                	pop    %r13
    RtCopyMem(Dest, Src, Size * sizeof(CHAR16));
    6e1a:	e9 31 fe ff ff       	jmp    6c50 <RtCopyMem>
    6e1f:	90                   	nop
    for (i = 0; *s1 && i < Len; i++)
    6e20:	45 31 ed             	xor    %r13d,%r13d
    6e23:	31 c0                	xor    %eax,%eax
    6e25:	eb ce                	jmp    6df5 <RtStrnCpy+0x35>
    6e27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6e2e:	00 00 

0000000000006e30 <RtStpCpy>:
{
    6e30:	f3 0f 1e fa          	endbr64 
    while (*Src) {
    6e34:	0f b7 16             	movzwl (%rsi),%edx
{
    6e37:	48 89 f8             	mov    %rdi,%rax
    while (*Src) {
    6e3a:	66 85 d2             	test   %dx,%dx
    6e3d:	74 14                	je     6e53 <RtStpCpy+0x23>
    6e3f:	90                   	nop
        *(Dest++) = *(Src++);
    6e40:	48 83 c6 02          	add    $0x2,%rsi
    6e44:	66 89 10             	mov    %dx,(%rax)
    6e47:	48 83 c0 02          	add    $0x2,%rax
    while (*Src) {
    6e4b:	0f b7 16             	movzwl (%rsi),%edx
    6e4e:	66 85 d2             	test   %dx,%dx
    6e51:	75 ed                	jne    6e40 <RtStpCpy+0x10>
    *Dest = 0;
    6e53:	31 d2                	xor    %edx,%edx
    6e55:	66 89 10             	mov    %dx,(%rax)
}
    6e58:	c3                   	ret    
    6e59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006e60 <RtStpnCpy>:
{
    6e60:	f3 0f 1e fa          	endbr64 
    6e64:	41 56                	push   %r14
    6e66:	41 55                	push   %r13
    6e68:	41 54                	push   %r12
    6e6a:	49 89 fc             	mov    %rdi,%r12
    6e6d:	55                   	push   %rbp
    6e6e:	48 89 f5             	mov    %rsi,%rbp
    6e71:	48 83 ec 08          	sub    $0x8,%rsp
    for (i = 0; *s1 && i < Len; i++)
    6e75:	66 83 3e 00          	cmpw   $0x0,(%rsi)
    6e79:	74 5d                	je     6ed8 <RtStpnCpy+0x78>
    6e7b:	48 85 d2             	test   %rdx,%rdx
    6e7e:	74 58                	je     6ed8 <RtStpnCpy+0x78>
    6e80:	31 c0                	xor    %eax,%eax
    6e82:	eb 09                	jmp    6e8d <RtStpnCpy+0x2d>
    6e84:	0f 1f 40 00          	nopl   0x0(%rax)
    6e88:	48 39 c2             	cmp    %rax,%rdx
    6e8b:	76 0c                	jbe    6e99 <RtStpnCpy+0x39>
    6e8d:	48 83 c0 01          	add    $0x1,%rax
    6e91:	66 83 7c 45 00 00    	cmpw   $0x0,0x0(%rbp,%rax,2)
    6e97:	75 ef                	jne    6e88 <RtStpnCpy+0x28>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    6e99:	4c 8d 2c 00          	lea    (%rax,%rax,1),%r13
    6e9d:	4f 8d 34 2c          	lea    (%r12,%r13,1),%r14
    if (Size != Len)
    6ea1:	48 39 c2             	cmp    %rax,%rdx
    6ea4:	74 11                	je     6eb7 <RtStpnCpy+0x57>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    6ea6:	48 29 c2             	sub    %rax,%rdx
    6ea9:	4c 89 f7             	mov    %r14,%rdi
    6eac:	48 8d 34 12          	lea    (%rdx,%rdx,1),%rsi
    6eb0:	31 d2                	xor    %edx,%edx
    6eb2:	e8 79 fd ff ff       	call   6c30 <RtSetMem>
    RtCopyMem(Dest, Src, Size * sizeof(CHAR16));
    6eb7:	4c 89 ea             	mov    %r13,%rdx
    6eba:	48 89 ee             	mov    %rbp,%rsi
    6ebd:	4c 89 e7             	mov    %r12,%rdi
    6ec0:	e8 8b fd ff ff       	call   6c50 <RtCopyMem>
}
    6ec5:	48 83 c4 08          	add    $0x8,%rsp
    6ec9:	4c 89 f0             	mov    %r14,%rax
    6ecc:	5d                   	pop    %rbp
    6ecd:	41 5c                	pop    %r12
    6ecf:	41 5d                	pop    %r13
    6ed1:	41 5e                	pop    %r14
    6ed3:	c3                   	ret    
    6ed4:	0f 1f 40 00          	nopl   0x0(%rax)
    for (i = 0; *s1 && i < Len; i++)
    6ed8:	4d 89 e6             	mov    %r12,%r14
    6edb:	45 31 ed             	xor    %r13d,%r13d
    6ede:	31 c0                	xor    %eax,%eax
    6ee0:	eb bf                	jmp    6ea1 <RtStpnCpy+0x41>
    6ee2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6ee9:	00 00 00 00 
    6eed:	0f 1f 00             	nopl   (%rax)

0000000000006ef0 <RtStrCat>:
{
    6ef0:	f3 0f 1e fa          	endbr64 
    for (len=0; *s1; s1+=1, len+=1) ;
    6ef4:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    6ef8:	74 31                	je     6f2b <RtStrCat+0x3b>
    6efa:	31 c0                	xor    %eax,%eax
    6efc:	0f 1f 40 00          	nopl   0x0(%rax)
    6f00:	48 83 c0 01          	add    $0x1,%rax
    6f04:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    6f09:	75 f5                	jne    6f00 <RtStrCat+0x10>
    RtStrCpy(Dest+RtStrLen(Dest), Src);
    6f0b:	48 8d 3c 47          	lea    (%rdi,%rax,2),%rdi
    while (*Src) {
    6f0f:	0f b7 06             	movzwl (%rsi),%eax
    6f12:	66 85 c0             	test   %ax,%ax
    6f15:	74 1c                	je     6f33 <RtStrCat+0x43>
    6f17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6f1e:	00 00 
        *(Dest++) = *(Src++);
    6f20:	66 89 07             	mov    %ax,(%rdi)
    6f23:	48 83 c7 02          	add    $0x2,%rdi
    6f27:	48 83 c6 02          	add    $0x2,%rsi
    while (*Src) {
    6f2b:	0f b7 06             	movzwl (%rsi),%eax
    6f2e:	66 85 c0             	test   %ax,%ax
    6f31:	75 ed                	jne    6f20 <RtStrCat+0x30>
    *Dest = 0;
    6f33:	31 c0                	xor    %eax,%eax
    6f35:	66 89 07             	mov    %ax,(%rdi)
}
    6f38:	c3                   	ret    
    6f39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006f40 <RtStrnCat>:
{
    6f40:	f3 0f 1e fa          	endbr64 
    6f44:	53                   	push   %rbx
    for (len=0; *s1; s1+=1, len+=1) ;
    6f45:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    6f49:	74 55                	je     6fa0 <RtStrnCat+0x60>
    6f4b:	31 c9                	xor    %ecx,%ecx
    6f4d:	0f 1f 00             	nopl   (%rax)
    6f50:	48 83 c1 01          	add    $0x1,%rcx
    6f54:	66 83 3c 4f 00       	cmpw   $0x0,(%rdi,%rcx,2)
    6f59:	75 f5                	jne    6f50 <RtStrnCat+0x10>
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    6f5b:	4c 8d 04 4f          	lea    (%rdi,%rcx,2),%r8
    for (i = 0; *s1 && i < Len; i++)
    6f5f:	66 83 3e 00          	cmpw   $0x0,(%rsi)
    6f63:	74 4b                	je     6fb0 <RtStrnCat+0x70>
    6f65:	48 85 d2             	test   %rdx,%rdx
    6f68:	74 46                	je     6fb0 <RtStrnCat+0x70>
    6f6a:	31 c0                	xor    %eax,%eax
    6f6c:	eb 07                	jmp    6f75 <RtStrnCat+0x35>
    6f6e:	66 90                	xchg   %ax,%ax
    6f70:	48 39 c2             	cmp    %rax,%rdx
    6f73:	76 0b                	jbe    6f80 <RtStrnCat+0x40>
    6f75:	48 83 c0 01          	add    $0x1,%rax
    6f79:	66 83 3c 46 00       	cmpw   $0x0,(%rsi,%rax,2)
    6f7e:	75 f0                	jne    6f70 <RtStrnCat+0x30>
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    6f80:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
    Dest[DestSize + Size] = '\0';
    6f84:	48 01 c8             	add    %rcx,%rax
    6f87:	48 8d 1c 47          	lea    (%rdi,%rax,2),%rbx
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    6f8b:	4c 89 c7             	mov    %r8,%rdi
    6f8e:	e8 bd fc ff ff       	call   6c50 <RtCopyMem>
    Dest[DestSize + Size] = '\0';
    6f93:	31 c0                	xor    %eax,%eax
    6f95:	66 89 03             	mov    %ax,(%rbx)
}
    6f98:	5b                   	pop    %rbx
    6f99:	c3                   	ret    
    6f9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for (len=0; *s1; s1+=1, len+=1) ;
    6fa0:	49 89 f8             	mov    %rdi,%r8
    6fa3:	31 c9                	xor    %ecx,%ecx
    6fa5:	eb b8                	jmp    6f5f <RtStrnCat+0x1f>
    6fa7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6fae:	00 00 
    for (i = 0; *s1 && i < Len; i++)
    6fb0:	31 d2                	xor    %edx,%edx
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    6fb2:	4c 89 c7             	mov    %r8,%rdi
    for (i = 0; *s1 && i < Len; i++)
    6fb5:	4c 89 c3             	mov    %r8,%rbx
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    6fb8:	e8 93 fc ff ff       	call   6c50 <RtCopyMem>
    Dest[DestSize + Size] = '\0';
    6fbd:	31 c0                	xor    %eax,%eax
    6fbf:	66 89 03             	mov    %ax,(%rbx)
}
    6fc2:	5b                   	pop    %rbx
    6fc3:	c3                   	ret    
    6fc4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6fcb:	00 00 00 00 
    6fcf:	90                   	nop

0000000000006fd0 <RtStrLen>:
{
    6fd0:	f3 0f 1e fa          	endbr64 
    for (len=0; *s1; s1+=1, len+=1) ;
    6fd4:	31 c0                	xor    %eax,%eax
    6fd6:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    6fda:	74 14                	je     6ff0 <RtStrLen+0x20>
    6fdc:	0f 1f 40 00          	nopl   0x0(%rax)
    6fe0:	48 83 c0 01          	add    $0x1,%rax
    6fe4:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    6fe9:	75 f5                	jne    6fe0 <RtStrLen+0x10>
    6feb:	c3                   	ret    
    6fec:	0f 1f 40 00          	nopl   0x0(%rax)
}
    6ff0:	c3                   	ret    
    6ff1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6ff8:	00 00 00 00 
    6ffc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007000 <RtStrnLen>:
{
    7000:	f3 0f 1e fa          	endbr64 
    for (i = 0; *s1 && i < Len; i++)
    7004:	31 c0                	xor    %eax,%eax
    7006:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    700a:	74 1c                	je     7028 <RtStrnLen+0x28>
    700c:	48 85 f6             	test   %rsi,%rsi
    700f:	75 0c                	jne    701d <RtStrnLen+0x1d>
    7011:	eb 15                	jmp    7028 <RtStrnLen+0x28>
    7013:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    7018:	48 39 c6             	cmp    %rax,%rsi
    701b:	76 13                	jbe    7030 <RtStrnLen+0x30>
    701d:	48 83 c0 01          	add    $0x1,%rax
    7021:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    7026:	75 f0                	jne    7018 <RtStrnLen+0x18>
        s1++;
    return i;
}
    7028:	c3                   	ret    
    7029:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    7030:	c3                   	ret    
    7031:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7038:	00 00 00 00 
    703c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007040 <RtStrSize>:
RUNTIMEFUNCTION
RtStrSize (
    IN CONST CHAR16   *s1
    )
// string size
{
    7040:	f3 0f 1e fa          	endbr64 
    UINTN        len;

    for (len=0; *s1; s1+=1, len+=1) ;
    7044:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    7048:	74 1e                	je     7068 <RtStrSize+0x28>
    704a:	31 c0                	xor    %eax,%eax
    704c:	0f 1f 40 00          	nopl   0x0(%rax)
    7050:	48 89 c2             	mov    %rax,%rdx
    7053:	48 83 c0 01          	add    $0x1,%rax
    7057:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    705c:	75 f2                	jne    7050 <RtStrSize+0x10>
    return (len + 1) * sizeof(CHAR16);
    705e:	48 8d 44 12 04       	lea    0x4(%rdx,%rdx,1),%rax
    7063:	c3                   	ret    
    7064:	0f 1f 40 00          	nopl   0x0(%rax)
    for (len=0; *s1; s1+=1, len+=1) ;
    7068:	b8 02 00 00 00       	mov    $0x2,%eax
}
    706d:	c3                   	ret    
    706e:	66 90                	xchg   %ax,%ax

0000000000007070 <RtBCDtoDecimal>:
UINT8
RUNTIMEFUNCTION
RtBCDtoDecimal(
    IN  UINT8 BcdValue
    )
{
    7070:	f3 0f 1e fa          	endbr64 
    UINTN   High, Low;

    High    = BcdValue >> 4;
    7074:	89 f8                	mov    %edi,%eax
    Low     = BcdValue - (High << 4);
    7076:	83 e7 0f             	and    $0xf,%edi
    High    = BcdValue >> 4;
    7079:	c0 e8 04             	shr    $0x4,%al

    return ((UINT8)(Low + (High * 10)));
    707c:	8d 04 80             	lea    (%rax,%rax,4),%eax
    707f:	8d 04 47             	lea    (%rdi,%rax,2),%eax
}
    7082:	c3                   	ret    
    7083:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    708a:	00 00 00 00 
    708e:	66 90                	xchg   %ax,%ax

0000000000007090 <RtDecimaltoBCD>:
UINT8
RUNTIMEFUNCTION
RtDecimaltoBCD (
    IN  UINT8 DecValue
    )
{
    7090:	f3 0f 1e fa          	endbr64 
    UINTN   High, Low;

    High    = DecValue / 10;
    7094:	b8 cd ff ff ff       	mov    $0xffffffcd,%eax
    7099:	40 f6 e7             	mul    %dil
    Low     = DecValue - (High * 10);
    709c:	40 0f b6 ff          	movzbl %dil,%edi
    High    = DecValue / 10;
    70a0:	66 c1 e8 0b          	shr    $0xb,%ax
    70a4:	0f b6 d0             	movzbl %al,%edx

    return ((UINT8)(Low + (High << 4)));
    70a7:	c1 e0 04             	shl    $0x4,%eax
    Low     = DecValue - (High * 10);
    70aa:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
    70ae:	48 01 d2             	add    %rdx,%rdx
    70b1:	48 29 d7             	sub    %rdx,%rdi
    return ((UINT8)(Low + (High << 4)));
    70b4:	01 f8                	add    %edi,%eax
}
    70b6:	c3                   	ret    
    70b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    70be:	00 00 

00000000000070c0 <InitializeLibPlatform>:
VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle EFI_UNUSED,
    IN EFI_SYSTEM_TABLE     *SystemTable EFI_UNUSED
    )
{
    70c0:	f3 0f 1e fa          	endbr64 
}
    70c4:	c3                   	ret    
    70c5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    70cc:	00 00 00 
    70cf:	90                   	nop

00000000000070d0 <LShiftU64>:
LShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
// Left shift 64bit by 32bit and get a 64bit result
{
    70d0:	f3 0f 1e fa          	endbr64 
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    return Operand << Count;
    70d4:	48 89 f8             	mov    %rdi,%rax
    70d7:	89 f1                	mov    %esi,%ecx
    70d9:	48 d3 e0             	shl    %cl,%rax
        mov     dword ptr Result[4], edx
    }

    return Result;
#endif
}
    70dc:	c3                   	ret    
    70dd:	0f 1f 00             	nopl   (%rax)

00000000000070e0 <RShiftU64>:
RShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
// Right shift 64bit by 32bit and get a 64bit result
{
    70e0:	f3 0f 1e fa          	endbr64 
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    return Operand >> Count;
    70e4:	48 89 f8             	mov    %rdi,%rax
    70e7:	89 f1                	mov    %esi,%ecx
    70e9:	48 d3 e8             	shr    %cl,%rax
        mov     dword ptr Result[4], edx
    }

    return Result;
#endif
}
    70ec:	c3                   	ret    
    70ed:	0f 1f 00             	nopl   (%rax)

00000000000070f0 <MultU64x32>:
MultU64x32 (
    IN UINT64   Multiplicand,
    IN UINTN    Multiplier
    )
// Multiple 64bit by 32bit and get a 64bit result
{
    70f0:	f3 0f 1e fa          	endbr64 
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    return Multiplicand * Multiplier;
    70f4:	48 89 f8             	mov    %rdi,%rax
    70f7:	48 0f af c6          	imul   %rsi,%rax
        add     dword ptr Result[4], eax
    }

    return Result;
#endif
}
    70fb:	c3                   	ret    
    70fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007100 <DivU64x32>:
    IN UINTN    Divisor,
    OUT UINTN   *Remainder OPTIONAL
    )
// divide 64bit by 32bit and get a 64bit result
// N.B. only works for 31bit divisors!!
{
    7100:	f3 0f 1e fa          	endbr64 
    7104:	48 89 d1             	mov    %rdx,%rcx
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    if (Remainder)
    7107:	48 85 d2             	test   %rdx,%rdx
    710a:	74 0b                	je     7117 <DivU64x32+0x17>
	*Remainder = Dividend % Divisor;
    710c:	48 89 f8             	mov    %rdi,%rax
    710f:	31 d2                	xor    %edx,%edx
    7111:	48 f7 f6             	div    %rsi
    7114:	48 89 11             	mov    %rdx,(%rcx)
    return Dividend / Divisor;
    7117:	48 89 f8             	mov    %rdi,%rax
    711a:	31 d2                	xor    %edx,%edx
    711c:	48 f7 f6             	div    %rsi
        *Remainder = Rem;
    }

    return Dividend;
#endif
}
    711f:	c3                   	ret    

0000000000007120 <_DevPathEndInstance>:
static VOID
_DevPathEndInstance (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath EFI_UNUSED
    )
{
    7120:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L",");
    7124:	48 8d 35 3d 77 00 00 	lea    0x773d(%rip),%rsi        # e868 <_DYNAMIC+0x2868>
    712b:	31 c0                	xor    %eax,%eax
    712d:	e9 2e ea ff ff       	jmp    5b60 <CatPrint>
    7132:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7139:	00 00 00 00 
    713d:	0f 1f 00             	nopl   (%rax)

0000000000007140 <_DevPathBssBss>:
{
    7140:	f3 0f 1e fa          	endbr64 
    switch (Bss->DeviceType) {
    7144:	66 83 7e 04 06       	cmpw   $0x6,0x4(%rsi)
    7149:	77 7e                	ja     71c9 <_DevPathBssBss+0x89>
    714b:	0f b7 46 04          	movzwl 0x4(%rsi),%eax
    714f:	48 8d 15 7e 77 00 00 	lea    0x777e(%rip),%rdx        # e8d4 <_DYNAMIC+0x28d4>
    7156:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    715a:	48 01 d0             	add    %rdx,%rax
    715d:	3e ff e0             	notrack jmp *%rax
    7160:	48 8d 15 13 77 00 00 	lea    0x7713(%rip),%rdx        # e87a <_DYNAMIC+0x287a>
    CatPrint(Str, L"Bss-%s(%a)", Type, Bss->String);
    7167:	48 8d 4e 08          	lea    0x8(%rsi),%rcx
    716b:	31 c0                	xor    %eax,%eax
    716d:	48 8d 35 48 77 00 00 	lea    0x7748(%rip),%rsi        # e8bc <_DYNAMIC+0x28bc>
    7174:	e9 e7 e9 ff ff       	jmp    5b60 <CatPrint>
    7179:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_FLOPPY:               Type = L"Floppy";       break;
    7180:	48 8d 15 e5 76 00 00 	lea    0x76e5(%rip),%rdx        # e86c <_DYNAMIC+0x286c>
    7187:	eb de                	jmp    7167 <_DevPathBssBss+0x27>
    7189:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_EMBEDDED_NETWORK:     Type = L"Net";          break;
    7190:	48 8d 15 19 77 00 00 	lea    0x7719(%rip),%rdx        # e8b0 <_DYNAMIC+0x28b0>
    7197:	eb ce                	jmp    7167 <_DevPathBssBss+0x27>
    7199:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_CDROM:                Type = L"CDROM";        break;
    71a0:	48 8d 15 e7 76 00 00 	lea    0x76e7(%rip),%rdx        # e88e <_DYNAMIC+0x288e>
    71a7:	eb be                	jmp    7167 <_DevPathBssBss+0x27>
    71a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_PCMCIA:               Type = L"PCMCIA";       break;
    71b0:	48 8d 15 e3 76 00 00 	lea    0x76e3(%rip),%rdx        # e89a <_DYNAMIC+0x289a>
    71b7:	eb ae                	jmp    7167 <_DevPathBssBss+0x27>
    71b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_USB:                  Type = L"Usb";          break;
    71c0:	48 8d 15 e1 76 00 00 	lea    0x76e1(%rip),%rdx        # e8a8 <_DYNAMIC+0x28a8>
    71c7:	eb 9e                	jmp    7167 <_DevPathBssBss+0x27>
    default:                            Type = L"?";            break;
    71c9:	48 8d 15 e8 76 00 00 	lea    0x76e8(%rip),%rdx        # e8b8 <_DYNAMIC+0x28b8>
    71d0:	eb 95                	jmp    7167 <_DevPathBssBss+0x27>
    71d2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    71d9:	00 00 00 00 
    71dd:	0f 1f 00             	nopl   (%rax)

00000000000071e0 <_DevPathMediaProtocol>:
{
    71e0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"%g", &MediaProt->Protocol);
    71e4:	48 8d 56 04          	lea    0x4(%rsi),%rdx
    71e8:	31 c0                	xor    %eax,%eax
    71ea:	48 8d 35 ff 76 00 00 	lea    0x76ff(%rip),%rsi        # e8f0 <_DYNAMIC+0x28f0>
    71f1:	e9 6a e9 ff ff       	jmp    5b60 <CatPrint>
    71f6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    71fd:	00 00 00 

0000000000007200 <_DevPathFilePath>:
{
    7200:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"%s", Fp->PathName);
    7204:	48 8d 56 04          	lea    0x4(%rsi),%rdx
    7208:	31 c0                	xor    %eax,%eax
    720a:	48 8d 35 e5 76 00 00 	lea    0x76e5(%rip),%rsi        # e8f6 <_DYNAMIC+0x28f6>
    7211:	e9 4a e9 ff ff       	jmp    5b60 <CatPrint>
    7216:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    721d:	00 00 00 

0000000000007220 <_DevPathCDROM>:
{
    7220:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"CDROM(0x%x)" , Cd-> BootEntry ) ;
    7224:	8b 56 04             	mov    0x4(%rsi),%edx
    7227:	31 c0                	xor    %eax,%eax
    7229:	48 8d 35 cc 76 00 00 	lea    0x76cc(%rip),%rsi        # e8fc <_DYNAMIC+0x28fc>
    7230:	e9 2b e9 ff ff       	jmp    5b60 <CatPrint>
    7235:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    723c:	00 00 00 00 

0000000000007240 <_DevPathSata>:
{
    7240:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"Sata(0x%x,0x%x,0x%x)" , Sata-> HBAPortNumber ,
    7244:	0f b7 4e 06          	movzwl 0x6(%rsi),%ecx
    7248:	0f b7 56 04          	movzwl 0x4(%rsi),%edx
    724c:	31 c0                	xor    %eax,%eax
    724e:	44 0f b7 46 08       	movzwl 0x8(%rsi),%r8d
    7253:	48 8d 35 be 76 00 00 	lea    0x76be(%rip),%rsi        # e918 <_DYNAMIC+0x2918>
    725a:	e9 01 e9 ff ff       	jmp    5b60 <CatPrint>
    725f:	90                   	nop

0000000000007260 <_DevPathUart>:
{
    7260:	f3 0f 1e fa          	endbr64 
    7264:	41 54                	push   %r12
    7266:	41 bc 78 00 00 00    	mov    $0x78,%r12d
    726c:	55                   	push   %rbp
    726d:	48 89 fd             	mov    %rdi,%rbp
    7270:	53                   	push   %rbx
    switch (Uart->Parity) {
    7271:	0f b6 46 11          	movzbl 0x11(%rsi),%eax
{
    7275:	48 89 f3             	mov    %rsi,%rbx
    7278:	3c 05                	cmp    $0x5,%al
    727a:	77 0c                	ja     7288 <_DevPathUart+0x28>
    CatPrint(Str, L"%c,", Parity);
    727c:	48 8d 15 07 7c 00 00 	lea    0x7c07(%rip),%rdx        # ee8a <CSWTCH.43>
    7283:	44 0f b6 24 02       	movzbl (%rdx,%rax,1),%r12d
    if (Uart->BaudRate == 0) {
    7288:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    728c:	48 85 d2             	test   %rdx,%rdx
    728f:	0f 85 9b 00 00 00    	jne    7330 <_DevPathUart+0xd0>
        CatPrint(Str, L"Uart(DEFAULT,");
    7295:	48 8d 35 a6 76 00 00 	lea    0x76a6(%rip),%rsi        # e942 <_DYNAMIC+0x2942>
    729c:	48 89 ef             	mov    %rbp,%rdi
    729f:	31 c0                	xor    %eax,%eax
    72a1:	e8 ba e8 ff ff       	call   5b60 <CatPrint>
    if (Uart->DataBits == 0) {
    72a6:	0f b6 53 10          	movzbl 0x10(%rbx),%edx
    72aa:	84 d2                	test   %dl,%dl
    72ac:	0f 85 9b 00 00 00    	jne    734d <_DevPathUart+0xed>
        CatPrint(Str, L"DEFAULT,");
    72b2:	48 8d 35 b9 76 00 00 	lea    0x76b9(%rip),%rsi        # e972 <_DYNAMIC+0x2972>
    72b9:	48 89 ef             	mov    %rbp,%rdi
    72bc:	31 c0                	xor    %eax,%eax
    72be:	e8 9d e8 ff ff       	call   5b60 <CatPrint>
    CatPrint(Str, L"%c,", Parity);
    72c3:	48 8d 35 c2 76 00 00 	lea    0x76c2(%rip),%rsi        # e98c <_DYNAMIC+0x298c>
    72ca:	44 89 e2             	mov    %r12d,%edx
    72cd:	48 89 ef             	mov    %rbp,%rdi
    72d0:	31 c0                	xor    %eax,%eax
    72d2:	e8 89 e8 ff ff       	call   5b60 <CatPrint>
    switch (Uart->StopBits) {
    72d7:	0f b6 43 12          	movzbl 0x12(%rbx),%eax
        case 2  : CatPrint(Str, L"1.5)"); break;
    72db:	48 8d 35 be 76 00 00 	lea    0x76be(%rip),%rsi        # e9a0 <_DYNAMIC+0x29a0>
    switch (Uart->StopBits) {
    72e2:	3c 02                	cmp    $0x2,%al
    72e4:	74 0d                	je     72f3 <_DevPathUart+0x93>
    72e6:	77 20                	ja     7308 <_DevPathUart+0xa8>
        case 1  : CatPrint(Str, L"1)");   break;
    72e8:	48 8d 35 ab 76 00 00 	lea    0x76ab(%rip),%rsi        # e99a <_DYNAMIC+0x299a>
    switch (Uart->StopBits) {
    72ef:	84 c0                	test   %al,%al
    72f1:	74 75                	je     7368 <_DevPathUart+0x108>
}
    72f3:	5b                   	pop    %rbx
        default : CatPrint(Str, L"x)");   break;
    72f4:	48 89 ef             	mov    %rbp,%rdi
    72f7:	31 c0                	xor    %eax,%eax
}
    72f9:	5d                   	pop    %rbp
    72fa:	41 5c                	pop    %r12
        default : CatPrint(Str, L"x)");   break;
    72fc:	e9 5f e8 ff ff       	jmp    5b60 <CatPrint>
    7301:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case 3  : CatPrint(Str, L"2)");   break;
    7308:	48 8d 35 9b 76 00 00 	lea    0x769b(%rip),%rsi        # e9aa <_DYNAMIC+0x29aa>
    switch (Uart->StopBits) {
    730f:	3c 03                	cmp    $0x3,%al
    7311:	74 e0                	je     72f3 <_DevPathUart+0x93>
}
    7313:	5b                   	pop    %rbx
        default : CatPrint(Str, L"x)");   break;
    7314:	48 89 ef             	mov    %rbp,%rdi
    7317:	48 8d 35 92 76 00 00 	lea    0x7692(%rip),%rsi        # e9b0 <_DYNAMIC+0x29b0>
}
    731e:	5d                   	pop    %rbp
        default : CatPrint(Str, L"x)");   break;
    731f:	31 c0                	xor    %eax,%eax
}
    7321:	41 5c                	pop    %r12
        default : CatPrint(Str, L"x)");   break;
    7323:	e9 38 e8 ff ff       	jmp    5b60 <CatPrint>
    7328:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    732f:	00 
        CatPrint(Str, L"Uart(%ld,", Uart->BaudRate);
    7330:	48 8d 35 27 76 00 00 	lea    0x7627(%rip),%rsi        # e95e <_DYNAMIC+0x295e>
    7337:	48 89 ef             	mov    %rbp,%rdi
    733a:	31 c0                	xor    %eax,%eax
    733c:	e8 1f e8 ff ff       	call   5b60 <CatPrint>
    if (Uart->DataBits == 0) {
    7341:	0f b6 53 10          	movzbl 0x10(%rbx),%edx
    7345:	84 d2                	test   %dl,%dl
    7347:	0f 84 65 ff ff ff    	je     72b2 <_DevPathUart+0x52>
        CatPrint(Str, L"%d,", Uart->DataBits);
    734d:	48 8d 35 30 76 00 00 	lea    0x7630(%rip),%rsi        # e984 <_DYNAMIC+0x2984>
    7354:	48 89 ef             	mov    %rbp,%rdi
    7357:	31 c0                	xor    %eax,%eax
    7359:	e8 02 e8 ff ff       	call   5b60 <CatPrint>
    735e:	e9 60 ff ff ff       	jmp    72c3 <_DevPathUart+0x63>
    7363:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
}
    7368:	5b                   	pop    %rbx
        default : CatPrint(Str, L"x)");   break;
    7369:	48 89 ef             	mov    %rbp,%rdi
        case 0  : CatPrint(Str, L"D)");   break;
    736c:	48 8d 35 21 76 00 00 	lea    0x7621(%rip),%rsi        # e994 <_DYNAMIC+0x2994>
}
    7373:	5d                   	pop    %rbp
        default : CatPrint(Str, L"x)");   break;
    7374:	31 c0                	xor    %eax,%eax
}
    7376:	41 5c                	pop    %r12
        default : CatPrint(Str, L"x)");   break;
    7378:	e9 e3 e7 ff ff       	jmp    5b60 <CatPrint>
    737d:	0f 1f 00             	nopl   (%rax)

0000000000007380 <_DevPathInfiniBand>:
{
    7380:	f3 0f 1e fa          	endbr64 
    7384:	48 83 ec 18          	sub    $0x18,%rsp
    CatPrint(Str, L"Infiniband(0x%x,%g,0x%lx,0x%lx,0x%lx)",
    7388:	48 8b 46 28          	mov    0x28(%rsi),%rax
    738c:	8b 56 04             	mov    0x4(%rsi),%edx
        InfiniBand->ResourceFlags, InfiniBand->PortGid, InfiniBand->ServiceId,
    738f:	48 8d 4e 08          	lea    0x8(%rsi),%rcx
    CatPrint(Str, L"Infiniband(0x%x,%g,0x%lx,0x%lx,0x%lx)",
    7393:	48 89 04 24          	mov    %rax,(%rsp)
    7397:	4c 8b 4e 20          	mov    0x20(%rsi),%r9
    739b:	31 c0                	xor    %eax,%eax
    739d:	4c 8b 46 18          	mov    0x18(%rsi),%r8
    73a1:	48 8d 35 10 76 00 00 	lea    0x7610(%rip),%rsi        # e9b8 <_DYNAMIC+0x29b8>
    73a8:	e8 b3 e7 ff ff       	call   5b60 <CatPrint>
}
    73ad:	48 83 c4 18          	add    $0x18,%rsp
    73b1:	c3                   	ret    
    73b2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    73b9:	00 00 00 00 
    73bd:	0f 1f 00             	nopl   (%rax)

00000000000073c0 <_DevPathUri>:
{
    73c0:	f3 0f 1e fa          	endbr64 
    CatPrint( Str, L"Uri(%a)", Uri->Uri );
    73c4:	48 8d 56 04          	lea    0x4(%rsi),%rdx
    73c8:	31 c0                	xor    %eax,%eax
    73ca:	48 8d 35 33 76 00 00 	lea    0x7633(%rip),%rsi        # ea04 <_DYNAMIC+0x2a04>
    73d1:	e9 8a e7 ff ff       	jmp    5b60 <CatPrint>
    73d6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    73dd:	00 00 00 

00000000000073e0 <_DevPathMacAddr>:
{
    73e0:	f3 0f 1e fa          	endbr64 
    73e4:	41 56                	push   %r14
    73e6:	41 55                	push   %r13
    73e8:	41 54                	push   %r12
    73ea:	49 89 fc             	mov    %rdi,%r12
    73ed:	55                   	push   %rbp
    73ee:	48 89 f5             	mov    %rsi,%rbp
    73f1:	53                   	push   %rbx
    if (MAC->IfType == 0x01 || MAC->IfType == 0x00) {
    73f2:	80 7e 24 01          	cmpb   $0x1,0x24(%rsi)
    73f6:	0f b7 46 02          	movzwl 0x2(%rsi),%eax
    73fa:	76 64                	jbe    7460 <_DevPathMacAddr+0x80>
    HwAddressSize -= sizeof( MAC-> IfType ) ;
    73fc:	4c 8d 70 fb          	lea    -0x5(%rax),%r14
    CatPrint(Str, L"Mac(");
    7400:	48 8d 35 0d 76 00 00 	lea    0x760d(%rip),%rsi        # ea14 <_DYNAMIC+0x2a14>
    7407:	31 c0                	xor    %eax,%eax
    7409:	e8 52 e7 ff ff       	call   5b60 <CatPrint>
    for(Index = 0; Index < HwAddressSize; Index++) {
    740e:	4d 85 f6             	test   %r14,%r14
    7411:	74 28                	je     743b <_DevPathMacAddr+0x5b>
    7413:	31 db                	xor    %ebx,%ebx
    7415:	4c 8d 2d 02 76 00 00 	lea    0x7602(%rip),%r13        # ea1e <_DYNAMIC+0x2a1e>
    741c:	0f 1f 40 00          	nopl   0x0(%rax)
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    7420:	0f b6 54 1d 04       	movzbl 0x4(%rbp,%rbx,1),%edx
    7425:	4c 89 ee             	mov    %r13,%rsi
    7428:	4c 89 e7             	mov    %r12,%rdi
    742b:	31 c0                	xor    %eax,%eax
    for(Index = 0; Index < HwAddressSize; Index++) {
    742d:	48 83 c3 01          	add    $0x1,%rbx
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    7431:	e8 2a e7 ff ff       	call   5b60 <CatPrint>
    for(Index = 0; Index < HwAddressSize; Index++) {
    7436:	4c 39 f3             	cmp    %r14,%rbx
    7439:	72 e5                	jb     7420 <_DevPathMacAddr+0x40>
    if ( MAC-> IfType != 0 ) {
    743b:	0f b6 55 24          	movzbl 0x24(%rbp),%edx
    743f:	84 d2                	test   %dl,%dl
    7441:	75 3d                	jne    7480 <_DevPathMacAddr+0xa0>
}
    7443:	5b                   	pop    %rbx
    CatPrint(Str, L")");
    7444:	4c 89 e7             	mov    %r12,%rdi
}
    7447:	5d                   	pop    %rbp
    CatPrint(Str, L")");
    7448:	31 c0                	xor    %eax,%eax
}
    744a:	41 5c                	pop    %r12
    CatPrint(Str, L")");
    744c:	48 8d 35 dd 75 00 00 	lea    0x75dd(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
}
    7453:	41 5d                	pop    %r13
    7455:	41 5e                	pop    %r14
    CatPrint(Str, L")");
    7457:	e9 04 e7 ff ff       	jmp    5b60 <CatPrint>
    745c:	0f 1f 40 00          	nopl   0x0(%rax)
    CatPrint(Str, L"Mac(");
    7460:	48 8d 35 ad 75 00 00 	lea    0x75ad(%rip),%rsi        # ea14 <_DYNAMIC+0x2a14>
    7467:	31 c0                	xor    %eax,%eax
        HwAddressSize = 6;
    7469:	41 be 06 00 00 00    	mov    $0x6,%r14d
    CatPrint(Str, L"Mac(");
    746f:	e8 ec e6 ff ff       	call   5b60 <CatPrint>
    for(Index = 0; Index < HwAddressSize; Index++) {
    7474:	eb 9d                	jmp    7413 <_DevPathMacAddr+0x33>
    7476:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    747d:	00 00 00 
        CatPrint(Str, L",%d" , MAC-> IfType ) ;
    7480:	48 8d 35 a1 75 00 00 	lea    0x75a1(%rip),%rsi        # ea28 <_DYNAMIC+0x2a28>
    7487:	4c 89 e7             	mov    %r12,%rdi
    748a:	31 c0                	xor    %eax,%eax
    748c:	e8 cf e6 ff ff       	call   5b60 <CatPrint>
    7491:	eb b0                	jmp    7443 <_DevPathMacAddr+0x63>
    7493:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    749a:	00 00 00 00 
    749e:	66 90                	xchg   %ax,%ax

00000000000074a0 <_DevPathI2O>:
{
    74a0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"I2O(0x%X)", I2O->Tid);
    74a4:	8b 56 04             	mov    0x4(%rsi),%edx
    74a7:	31 c0                	xor    %eax,%eax
    74a9:	48 8d 35 84 75 00 00 	lea    0x7584(%rip),%rsi        # ea34 <_DYNAMIC+0x2a34>
    74b0:	e9 ab e6 ff ff       	jmp    5b60 <CatPrint>
    74b5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    74bc:	00 00 00 00 

00000000000074c0 <_DevPathUsb>:
{
    74c0:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"Usb(0x%x,0x%x)" , Usb-> Port , Usb-> Endpoint ) ;
    74c4:	0f b6 4e 05          	movzbl 0x5(%rsi),%ecx
    74c8:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    74cc:	31 c0                	xor    %eax,%eax
    74ce:	48 8d 35 73 75 00 00 	lea    0x7573(%rip),%rsi        # ea48 <_DYNAMIC+0x2a48>
    74d5:	e9 86 e6 ff ff       	jmp    5b60 <CatPrint>
    74da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000074e0 <_DevPath1394>:
{
    74e0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"I1394(%016lx)", F1394->Guid);
    74e4:	48 8b 56 08          	mov    0x8(%rsi),%rdx
    74e8:	31 c0                	xor    %eax,%eax
    74ea:	48 8d 35 75 75 00 00 	lea    0x7575(%rip),%rsi        # ea66 <_DYNAMIC+0x2a66>
    74f1:	e9 6a e6 ff ff       	jmp    5b60 <CatPrint>
    74f6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    74fd:	00 00 00 

0000000000007500 <_DevPathFibre>:
{
    7500:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"Fibre%s(0x%016lx,0x%016lx)" ,
    7504:	0f b6 06             	movzbl (%rsi),%eax
    7507:	48 8d 15 74 75 00 00 	lea    0x7574(%rip),%rdx        # ea82 <_DYNAMIC+0x2a82>
    750e:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
    7512:	4c 8b 46 10          	mov    0x10(%rsi),%r8
    7516:	48 8d 35 73 75 00 00 	lea    0x7573(%rip),%rsi        # ea90 <_DYNAMIC+0x2a90>
    751d:	83 e0 7f             	and    $0x7f,%eax
    7520:	3c 03                	cmp    $0x3,%al
    7522:	48 8d 05 5b 75 00 00 	lea    0x755b(%rip),%rax        # ea84 <_DYNAMIC+0x2a84>
    7529:	48 0f 45 d0          	cmovne %rax,%rdx
    752d:	31 c0                	xor    %eax,%eax
    752f:	e9 2c e6 ff ff       	jmp    5b60 <CatPrint>
    7534:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    753b:	00 00 00 00 
    753f:	90                   	nop

0000000000007540 <_DevPathScsi>:
{
    7540:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Scsi(%d,%d)", Scsi->Pun, Scsi->Lun);
    7544:	0f b7 4e 06          	movzwl 0x6(%rsi),%ecx
    7548:	0f b7 56 04          	movzwl 0x4(%rsi),%edx
    754c:	31 c0                	xor    %eax,%eax
    754e:	48 8d 35 71 75 00 00 	lea    0x7571(%rip),%rsi        # eac6 <_DYNAMIC+0x2ac6>
    7555:	e9 06 e6 ff ff       	jmp    5b60 <CatPrint>
    755a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000007560 <_DevPathAtapi>:
{
    7560:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Ata(%s,%s)",
    7564:	80 7e 05 00          	cmpb   $0x0,0x5(%rsi)
    7568:	48 8d 05 7b 75 00 00 	lea    0x757b(%rip),%rax        # eaea <_DYNAMIC+0x2aea>
    756f:	48 8d 0d 68 75 00 00 	lea    0x7568(%rip),%rcx        # eade <_DYNAMIC+0x2ade>
    7576:	48 0f 44 c8          	cmove  %rax,%rcx
    757a:	48 8d 15 77 75 00 00 	lea    0x7577(%rip),%rdx        # eaf8 <_DYNAMIC+0x2af8>
    7581:	80 7e 04 00          	cmpb   $0x0,0x4(%rsi)
    7585:	48 8d 05 80 75 00 00 	lea    0x7580(%rip),%rax        # eb0c <_DYNAMIC+0x2b0c>
    758c:	48 8d 35 89 75 00 00 	lea    0x7589(%rip),%rsi        # eb1c <_DYNAMIC+0x2b1c>
    7593:	48 0f 44 d0          	cmove  %rax,%rdx
    7597:	31 c0                	xor    %eax,%eax
    7599:	e9 c2 e5 ff ff       	jmp    5b60 <CatPrint>
    759e:	66 90                	xchg   %ax,%ax

00000000000075a0 <_DevPathAcpi>:
{
    75a0:	f3 0f 1e fa          	endbr64 
    75a4:	55                   	push   %rbp
    75a5:	48 89 fd             	mov    %rdi,%rbp
    75a8:	53                   	push   %rbx
    75a9:	48 89 f3             	mov    %rsi,%rbx
    75ac:	48 83 ec 08          	sub    $0x8,%rsp
    if ((Acpi->HID & PNP_EISA_ID_MASK) == PNP_EISA_ID_CONST) {
    75b0:	8b 56 04             	mov    0x4(%rsi),%edx
    75b3:	66 81 fa d0 41       	cmp    $0x41d0,%dx
    75b8:	75 7e                	jne    7638 <_DevPathAcpi+0x98>
        switch ( EISA_ID_TO_NUM( Acpi-> HID ) ) {
    75ba:	c1 ea 10             	shr    $0x10,%edx
    75bd:	81 fa 04 06 00 00    	cmp    $0x604,%edx
    75c3:	0f 84 f7 00 00 00    	je     76c0 <_DevPathAcpi+0x120>
    75c9:	77 35                	ja     7600 <_DevPathAcpi+0x60>
    75cb:	81 fa 01 04 00 00    	cmp    $0x401,%edx
    75d1:	0f 84 d9 00 00 00    	je     76b0 <_DevPathAcpi+0x110>
    75d7:	81 fa 01 05 00 00    	cmp    $0x501,%edx
    75dd:	75 41                	jne    7620 <_DevPathAcpi+0x80>
                CatPrint( Str , L"Serial(%d)" , Acpi-> UID ) ;
    75df:	8b 56 08             	mov    0x8(%rsi),%edx
    75e2:	48 8d 35 89 75 00 00 	lea    0x7589(%rip),%rsi        # eb72 <_DYNAMIC+0x2b72>
}
    75e9:	48 83 c4 08          	add    $0x8,%rsp
                CatPrint( Str , L"ParallelPort(%d)" , Acpi-> UID ) ;
    75ed:	48 89 ef             	mov    %rbp,%rdi
    75f0:	31 c0                	xor    %eax,%eax
}
    75f2:	5b                   	pop    %rbx
    75f3:	5d                   	pop    %rbp
                CatPrint( Str , L"ParallelPort(%d)" , Acpi-> UID ) ;
    75f4:	e9 67 e5 ff ff       	jmp    5b60 <CatPrint>
    75f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        switch ( EISA_ID_TO_NUM( Acpi-> HID ) ) {
    7600:	81 fa 03 0a 00 00    	cmp    $0xa03,%edx
    7606:	74 68                	je     7670 <_DevPathAcpi+0xd0>
    7608:	81 fa 08 0a 00 00    	cmp    $0xa08,%edx
    760e:	75 70                	jne    7680 <_DevPathAcpi+0xe0>
                CatPrint( Str , L"PcieRoot(%d)" , Acpi-> UID ) ;
    7610:	8b 56 08             	mov    0x8(%rsi),%edx
    7613:	48 8d 35 9c 75 00 00 	lea    0x759c(%rip),%rsi        # ebb6 <_DYNAMIC+0x2bb6>
    761a:	eb cd                	jmp    75e9 <_DevPathAcpi+0x49>
    761c:	0f 1f 40 00          	nopl   0x0(%rax)
        switch ( EISA_ID_TO_NUM( Acpi-> HID ) ) {
    7620:	81 fa 01 03 00 00    	cmp    $0x301,%edx
    7626:	75 58                	jne    7680 <_DevPathAcpi+0xe0>
                CatPrint( Str , L"Keyboard(%d)" , Acpi-> UID ) ;
    7628:	8b 56 08             	mov    0x8(%rsi),%edx
    762b:	48 8d 35 00 75 00 00 	lea    0x7500(%rip),%rsi        # eb32 <_DYNAMIC+0x2b32>
    7632:	eb b5                	jmp    75e9 <_DevPathAcpi+0x49>
    7634:	0f 1f 40 00          	nopl   0x0(%rax)
        CatPrint( Str , L"Acpi(0x%X" , Acpi-> HID ) ;
    7638:	48 8d 35 ab 75 00 00 	lea    0x75ab(%rip),%rsi        # ebea <_DYNAMIC+0x2bea>
    763f:	31 c0                	xor    %eax,%eax
    7641:	e8 1a e5 ff ff       	call   5b60 <CatPrint>
        if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    7646:	8b 4b 08             	mov    0x8(%rbx),%ecx
    7649:	85 c9                	test   %ecx,%ecx
    764b:	0f 85 7f 00 00 00    	jne    76d0 <_DevPathAcpi+0x130>
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    7651:	8b 53 04             	mov    0x4(%rbx),%edx
}
    7654:	48 83 c4 08          	add    $0x8,%rsp
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    7658:	48 89 ef             	mov    %rbp,%rdi
    765b:	31 c0                	xor    %eax,%eax
}
    765d:	5b                   	pop    %rbx
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    765e:	48 8d 35 cb 73 00 00 	lea    0x73cb(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
}
    7665:	5d                   	pop    %rbp
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    7666:	e9 f5 e4 ff ff       	jmp    5b60 <CatPrint>
    766b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                CatPrint( Str , L"PciRoot(%d)" , Acpi-> UID ) ;
    7670:	8b 56 08             	mov    0x8(%rsi),%edx
    7673:	48 8d 35 24 75 00 00 	lea    0x7524(%rip),%rsi        # eb9e <_DYNAMIC+0x2b9e>
    767a:	e9 6a ff ff ff       	jmp    75e9 <_DevPathAcpi+0x49>
    767f:	90                   	nop
                CatPrint( Str , L"Acpi(PNP%04x" , EISA_ID_TO_NUM( Acpi-> HID ) ) ;
    7680:	48 8d 35 49 75 00 00 	lea    0x7549(%rip),%rsi        # ebd0 <_DYNAMIC+0x2bd0>
    7687:	48 89 ef             	mov    %rbp,%rdi
    768a:	31 c0                	xor    %eax,%eax
    768c:	e8 cf e4 ff ff       	call   5b60 <CatPrint>
                if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    7691:	8b 53 08             	mov    0x8(%rbx),%edx
    7694:	85 d2                	test   %edx,%edx
    7696:	75 58                	jne    76f0 <_DevPathAcpi+0x150>
}
    7698:	48 83 c4 08          	add    $0x8,%rsp
                CatPrint( Str , L")" ) ;
    769c:	48 89 ef             	mov    %rbp,%rdi
    769f:	48 8d 35 8a 73 00 00 	lea    0x738a(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
    76a6:	31 c0                	xor    %eax,%eax
}
    76a8:	5b                   	pop    %rbx
    76a9:	5d                   	pop    %rbp
                CatPrint( Str , L")" ) ;
    76aa:	e9 b1 e4 ff ff       	jmp    5b60 <CatPrint>
    76af:	90                   	nop
                CatPrint( Str , L"ParallelPort(%d)" , Acpi-> UID ) ;
    76b0:	8b 56 08             	mov    0x8(%rsi),%edx
    76b3:	48 8d 35 96 74 00 00 	lea    0x7496(%rip),%rsi        # eb50 <_DYNAMIC+0x2b50>
    76ba:	e9 2a ff ff ff       	jmp    75e9 <_DevPathAcpi+0x49>
    76bf:	90                   	nop
                CatPrint( Str , L"Floppy(%d)" , Acpi-> UID ) ;
    76c0:	8b 56 08             	mov    0x8(%rsi),%edx
    76c3:	48 8d 35 be 74 00 00 	lea    0x74be(%rip),%rsi        # eb88 <_DYNAMIC+0x2b88>
    76ca:	e9 1a ff ff ff       	jmp    75e9 <_DevPathAcpi+0x49>
    76cf:	90                   	nop
        if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    76d0:	89 ca                	mov    %ecx,%edx
    76d2:	48 8d 35 4f 73 00 00 	lea    0x734f(%rip),%rsi        # ea28 <_DYNAMIC+0x2a28>
    76d9:	48 89 ef             	mov    %rbp,%rdi
    76dc:	31 c0                	xor    %eax,%eax
    76de:	e8 7d e4 ff ff       	call   5b60 <CatPrint>
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    76e3:	8b 4b 08             	mov    0x8(%rbx),%ecx
    76e6:	e9 66 ff ff ff       	jmp    7651 <_DevPathAcpi+0xb1>
    76eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    76f0:	48 8d 35 31 73 00 00 	lea    0x7331(%rip),%rsi        # ea28 <_DYNAMIC+0x2a28>
    76f7:	48 89 ef             	mov    %rbp,%rdi
    76fa:	31 c0                	xor    %eax,%eax
    76fc:	e8 5f e4 ff ff       	call   5b60 <CatPrint>
    7701:	eb 95                	jmp    7698 <_DevPathAcpi+0xf8>
    7703:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    770a:	00 00 00 00 
    770e:	66 90                	xchg   %ax,%ax

0000000000007710 <_DevPathController>:
{
    7710:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Ctrl(%d)",
    7714:	8b 56 04             	mov    0x4(%rsi),%edx
    7717:	31 c0                	xor    %eax,%eax
    7719:	48 8d 35 de 74 00 00 	lea    0x74de(%rip),%rsi        # ebfe <_DYNAMIC+0x2bfe>
    7720:	e9 3b e4 ff ff       	jmp    5b60 <CatPrint>
    7725:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    772c:	00 00 00 00 

0000000000007730 <_DevPathMemMap>:
{
    7730:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"MemMap(%d,0x%x,0x%x)",
    7734:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
    7738:	8b 56 04             	mov    0x4(%rsi),%edx
    773b:	31 c0                	xor    %eax,%eax
    773d:	4c 8b 46 10          	mov    0x10(%rsi),%r8
    7741:	48 8d 35 c8 74 00 00 	lea    0x74c8(%rip),%rsi        # ec10 <_DYNAMIC+0x2c10>
    7748:	e9 13 e4 ff ff       	jmp    5b60 <CatPrint>
    774d:	0f 1f 00             	nopl   (%rax)

0000000000007750 <_DevPathPccard>:
{
    7750:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Pccard(0x%x)", Pccard-> FunctionNumber );
    7754:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    7758:	31 c0                	xor    %eax,%eax
    775a:	48 8d 35 d9 74 00 00 	lea    0x74d9(%rip),%rsi        # ec3a <_DYNAMIC+0x2c3a>
    7761:	e9 fa e3 ff ff       	jmp    5b60 <CatPrint>
    7766:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    776d:	00 00 00 

0000000000007770 <_DevPathPci>:
{
    7770:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Pci(0x%x,0x%x)", Pci->Device, Pci->Function);
    7774:	0f b6 4e 04          	movzbl 0x4(%rsi),%ecx
    7778:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
    777c:	31 c0                	xor    %eax,%eax
    777e:	48 8d 35 cf 74 00 00 	lea    0x74cf(%rip),%rsi        # ec54 <_DYNAMIC+0x2c54>
    7785:	e9 d6 e3 ff ff       	jmp    5b60 <CatPrint>
    778a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000007790 <_DevPathNodeUnknown>:
static VOID
_DevPathNodeUnknown (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    7790:	f3 0f 1e fa          	endbr64 
    7794:	41 57                	push   %r15
    7796:	49 89 ff             	mov    %rdi,%r15
    7799:	41 56                	push   %r14
    779b:	41 55                	push   %r13
    779d:	41 54                	push   %r12
    779f:	55                   	push   %rbp
    77a0:	48 89 f5             	mov    %rsi,%rbp
    77a3:	53                   	push   %rbx
    77a4:	48 83 ec 08          	sub    $0x8,%rsp
    UINT8 * value ;
    int length , index ;
    Path = DevPath ;
    value = DevPath ;
    value += 4 ;
    switch ( Path-> Type ) {
    77a8:	0f b6 16             	movzbl (%rsi),%edx
        case HARDWARE_DEVICE_PATH : { /* Unknown Hardware Device Path */
            CatPrint( Str , L"HardwarePath(%d" , Path-> SubType ) ;
    77ab:	44 0f b6 46 01       	movzbl 0x1(%rsi),%r8d
    switch ( Path-> Type ) {
    77b0:	80 fa 05             	cmp    $0x5,%dl
    77b3:	0f 87 26 01 00 00    	ja     78df <_DevPathNodeUnknown+0x14f>
    77b9:	48 8d 0d 4c 75 00 00 	lea    0x754c(%rip),%rcx        # ed0c <_DYNAMIC+0x2d0c>
    77c0:	0f b6 c2             	movzbl %dl,%eax
    77c3:	48 63 04 81          	movslq (%rcx,%rax,4),%rax
    77c7:	48 01 c8             	add    %rcx,%rax
    77ca:	3e ff e0             	notrack jmp *%rax
    77cd:	0f 1f 00             	nopl   (%rax)
        case MEDIA_DEVICE_PATH : { /* Unknown Media Device Path */
            CatPrint( Str , L"MediaPath(%d" , Path-> SubType ) ;
            break ;
        }
        case BBS_DEVICE_PATH : { /* Unknown BIOS Boot Specification Device Path */
            CatPrint( Str , L"BbsPath(%d" , Path-> SubType ) ;
    77d0:	44 89 c2             	mov    %r8d,%edx
    77d3:	48 8d 35 fe 74 00 00 	lea    0x74fe(%rip),%rsi        # ecd8 <_DYNAMIC+0x2cd8>
    77da:	31 c0                	xor    %eax,%eax
    77dc:	e8 7f e3 ff ff       	call   5b60 <CatPrint>
            break ;
    77e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        default : { /* Unknown Device Path */
            CatPrint( Str , L"Path(%d,%d" , Path-> Type , Path-> SubType ) ;
            break ;
        }
    }
    length = DevicePathNodeLength( Path ) ;
    77e8:	44 0f b7 65 02       	movzwl 0x2(%rbp),%r12d
    for ( index = 0 ; index < length ; index ++ ) {
    77ed:	31 db                	xor    %ebx,%ebx
    77ef:	4c 8d 2d 28 72 00 00 	lea    0x7228(%rip),%r13        # ea1e <_DYNAMIC+0x2a1e>
        if ( index == 0 ) CatPrint( Str , L",0x" ) ;
    77f6:	4c 8d 35 07 75 00 00 	lea    0x7507(%rip),%r14        # ed04 <_DYNAMIC+0x2d04>
    for ( index = 0 ; index < length ; index ++ ) {
    77fd:	45 85 e4             	test   %r12d,%r12d
    7800:	75 2d                	jne    782f <_DevPathNodeUnknown+0x9f>
    7802:	e9 b9 00 00 00       	jmp    78c0 <_DevPathNodeUnknown+0x130>
    7807:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    780e:	00 00 
        CatPrint( Str , L"%02x" , * value ) ;
    7810:	0f b6 54 1d 04       	movzbl 0x4(%rbp,%rbx,1),%edx
    7815:	4c 89 ee             	mov    %r13,%rsi
    7818:	4c 89 ff             	mov    %r15,%rdi
    781b:	31 c0                	xor    %eax,%eax
    for ( index = 0 ; index < length ; index ++ ) {
    781d:	48 83 c3 01          	add    $0x1,%rbx
        CatPrint( Str , L"%02x" , * value ) ;
    7821:	e8 3a e3 ff ff       	call   5b60 <CatPrint>
    for ( index = 0 ; index < length ; index ++ ) {
    7826:	41 39 dc             	cmp    %ebx,%r12d
    7829:	0f 8e 91 00 00 00    	jle    78c0 <_DevPathNodeUnknown+0x130>
        if ( index == 0 ) CatPrint( Str , L",0x" ) ;
    782f:	48 85 db             	test   %rbx,%rbx
    7832:	75 dc                	jne    7810 <_DevPathNodeUnknown+0x80>
    7834:	4c 89 f6             	mov    %r14,%rsi
    7837:	4c 89 ff             	mov    %r15,%rdi
    783a:	31 c0                	xor    %eax,%eax
    783c:	e8 1f e3 ff ff       	call   5b60 <CatPrint>
    7841:	eb cd                	jmp    7810 <_DevPathNodeUnknown+0x80>
    7843:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            CatPrint( Str , L"HardwarePath(%d" , Path-> SubType ) ;
    7848:	44 89 c2             	mov    %r8d,%edx
    784b:	48 8d 35 26 74 00 00 	lea    0x7426(%rip),%rsi        # ec78 <_DYNAMIC+0x2c78>
    7852:	31 c0                	xor    %eax,%eax
    7854:	e8 07 e3 ff ff       	call   5b60 <CatPrint>
            break ;
    7859:	eb 8d                	jmp    77e8 <_DevPathNodeUnknown+0x58>
    785b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            CatPrint( Str , L"AcpiPath(%d" , Path-> SubType ) ;
    7860:	44 89 c2             	mov    %r8d,%edx
    7863:	48 8d 35 2e 74 00 00 	lea    0x742e(%rip),%rsi        # ec98 <_DYNAMIC+0x2c98>
    786a:	31 c0                	xor    %eax,%eax
    786c:	e8 ef e2 ff ff       	call   5b60 <CatPrint>
            break ;
    7871:	e9 72 ff ff ff       	jmp    77e8 <_DevPathNodeUnknown+0x58>
    7876:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    787d:	00 00 00 
            CatPrint( Str , L"Msg(%d" , Path-> SubType ) ;
    7880:	44 89 c2             	mov    %r8d,%edx
    7883:	48 8d 35 26 74 00 00 	lea    0x7426(%rip),%rsi        # ecb0 <_DYNAMIC+0x2cb0>
    788a:	31 c0                	xor    %eax,%eax
    788c:	e8 cf e2 ff ff       	call   5b60 <CatPrint>
            break ;
    7891:	e9 52 ff ff ff       	jmp    77e8 <_DevPathNodeUnknown+0x58>
    7896:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    789d:	00 00 00 
            CatPrint( Str , L"MediaPath(%d" , Path-> SubType ) ;
    78a0:	44 89 c2             	mov    %r8d,%edx
    78a3:	48 8d 35 14 74 00 00 	lea    0x7414(%rip),%rsi        # ecbe <_DYNAMIC+0x2cbe>
    78aa:	31 c0                	xor    %eax,%eax
    78ac:	e8 af e2 ff ff       	call   5b60 <CatPrint>
            break ;
    78b1:	e9 32 ff ff ff       	jmp    77e8 <_DevPathNodeUnknown+0x58>
    78b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    78bd:	00 00 00 
	value ++ ;
    }
    CatPrint( Str , L")" ) ;
}
    78c0:	48 83 c4 08          	add    $0x8,%rsp
    CatPrint( Str , L")" ) ;
    78c4:	4c 89 ff             	mov    %r15,%rdi
    78c7:	48 8d 35 62 71 00 00 	lea    0x7162(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
    78ce:	31 c0                	xor    %eax,%eax
}
    78d0:	5b                   	pop    %rbx
    78d1:	5d                   	pop    %rbp
    78d2:	41 5c                	pop    %r12
    78d4:	41 5d                	pop    %r13
    78d6:	41 5e                	pop    %r14
    78d8:	41 5f                	pop    %r15
    CatPrint( Str , L")" ) ;
    78da:	e9 81 e2 ff ff       	jmp    5b60 <CatPrint>
            CatPrint( Str , L"Path(%d,%d" , Path-> Type , Path-> SubType ) ;
    78df:	44 89 c1             	mov    %r8d,%ecx
    78e2:	48 8d 35 05 74 00 00 	lea    0x7405(%rip),%rsi        # ecee <_DYNAMIC+0x2cee>
    78e9:	4c 89 ff             	mov    %r15,%rdi
    78ec:	31 c0                	xor    %eax,%eax
    78ee:	e8 6d e2 ff ff       	call   5b60 <CatPrint>
            break ;
    78f3:	e9 f0 fe ff ff       	jmp    77e8 <_DevPathNodeUnknown+0x58>
    78f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    78ff:	00 

0000000000007900 <_DevPathVendor>:
{
    7900:	f3 0f 1e fa          	endbr64 
    7904:	41 54                	push   %r12
    switch (DevicePathType(&Vendor->Header)) {
    7906:	48 8d 15 1d 74 00 00 	lea    0x741d(%rip),%rdx        # ed2a <_DYNAMIC+0x2d2a>
{
    790d:	55                   	push   %rbp
    790e:	48 89 fd             	mov    %rdi,%rbp
    7911:	53                   	push   %rbx
    7912:	0f b6 06             	movzbl (%rsi),%eax
    7915:	48 89 f3             	mov    %rsi,%rbx
    7918:	83 e0 7f             	and    $0x7f,%eax
    switch (DevicePathType(&Vendor->Header)) {
    791b:	3c 03                	cmp    $0x3,%al
    791d:	74 1f                	je     793e <_DevPathVendor+0x3e>
    case MEDIA_DEVICE_PATH:     Type = L"Media";     break;
    791f:	48 8d 15 0c 74 00 00 	lea    0x740c(%rip),%rdx        # ed32 <_DYNAMIC+0x2d32>
    switch (DevicePathType(&Vendor->Header)) {
    7926:	3c 04                	cmp    $0x4,%al
    7928:	74 14                	je     793e <_DevPathVendor+0x3e>
    case HARDWARE_DEVICE_PATH:  Type = L"Hw";        break;
    792a:	3c 01                	cmp    $0x1,%al
    792c:	48 8d 15 85 6f 00 00 	lea    0x6f85(%rip),%rdx        # e8b8 <_DYNAMIC+0x28b8>
    7933:	48 8d 05 ea 73 00 00 	lea    0x73ea(%rip),%rax        # ed24 <_DYNAMIC+0x2d24>
    793a:	48 0f 44 d0          	cmove  %rax,%rdx
    CatPrint(Str, L"Ven%s(%g", Type, &Vendor->Guid);
    793e:	4c 8d 63 04          	lea    0x4(%rbx),%r12
    7942:	48 8d 35 f5 73 00 00 	lea    0x73f5(%rip),%rsi        # ed3e <_DYNAMIC+0x2d3e>
    7949:	48 89 ef             	mov    %rbp,%rdi
    794c:	31 c0                	xor    %eax,%eax
    794e:	4c 89 e1             	mov    %r12,%rcx
    7951:	e8 0a e2 ff ff       	call   5b60 <CatPrint>
    if (CompareGuid (&Vendor->Guid, &UnknownDevice) == 0) {
    7956:	48 8d 35 f3 37 00 00 	lea    0x37f3(%rip),%rsi        # b150 <UnknownDevice>
    795d:	4c 89 e7             	mov    %r12,%rdi
    7960:	e8 2b 0f 00 00       	call   8890 <CompareGuid>
    7965:	48 85 c0             	test   %rax,%rax
    7968:	75 1e                	jne    7988 <_DevPathVendor+0x88>
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    796a:	0f b6 53 14          	movzbl 0x14(%rbx),%edx
    796e:	48 89 ef             	mov    %rbp,%rdi
}
    7971:	5b                   	pop    %rbx
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    7972:	48 8d 35 d7 73 00 00 	lea    0x73d7(%rip),%rsi        # ed50 <_DYNAMIC+0x2d50>
}
    7979:	5d                   	pop    %rbp
    797a:	41 5c                	pop    %r12
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    797c:	e9 df e1 ff ff       	jmp    5b60 <CatPrint>
    7981:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
}
    7988:	5b                   	pop    %rbx
        CatPrint(Str, L")");
    7989:	48 89 ef             	mov    %rbp,%rdi
    798c:	48 8d 35 9d 70 00 00 	lea    0x709d(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
}
    7993:	5d                   	pop    %rbp
        CatPrint(Str, L")");
    7994:	31 c0                	xor    %eax,%eax
}
    7996:	41 5c                	pop    %r12
        CatPrint(Str, L")");
    7998:	e9 c3 e1 ff ff       	jmp    5b60 <CatPrint>
    799d:	0f 1f 00             	nopl   (%rax)

00000000000079a0 <_DevPathHardDrive>:
{
    79a0:	f3 0f 1e fa          	endbr64 
    switch (Hd->SignatureType) {
    79a4:	0f b6 4e 29          	movzbl 0x29(%rsi),%ecx
            CatPrint(Str, L"HD(%d,MBR,0x%08x)",
    79a8:	8b 56 04             	mov    0x4(%rsi),%edx
    switch (Hd->SignatureType) {
    79ab:	80 f9 01             	cmp    $0x1,%cl
    79ae:	74 18                	je     79c8 <_DevPathHardDrive+0x28>
    79b0:	80 f9 02             	cmp    $0x2,%cl
    79b3:	74 2b                	je     79e0 <_DevPathHardDrive+0x40>
            CatPrint(Str, L"HD(%d,%d,0)",
    79b5:	48 8d 35 e4 73 00 00 	lea    0x73e4(%rip),%rsi        # eda0 <_DYNAMIC+0x2da0>
    79bc:	31 c0                	xor    %eax,%eax
    79be:	e9 9d e1 ff ff       	jmp    5b60 <CatPrint>
    79c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            CatPrint(Str, L"HD(%d,MBR,0x%08x)",
    79c8:	8b 4e 18             	mov    0x18(%rsi),%ecx
    79cb:	31 c0                	xor    %eax,%eax
    79cd:	48 8d 35 8c 73 00 00 	lea    0x738c(%rip),%rsi        # ed60 <_DYNAMIC+0x2d60>
    79d4:	e9 87 e1 ff ff       	jmp    5b60 <CatPrint>
    79d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                (EFI_GUID *) &(Hd->Signature[0])
    79e0:	48 8d 4e 18          	lea    0x18(%rsi),%rcx
            CatPrint(Str, L"HD(%d,GPT,%g)",
    79e4:	31 c0                	xor    %eax,%eax
    79e6:	48 8d 35 97 73 00 00 	lea    0x7397(%rip),%rsi        # ed84 <_DYNAMIC+0x2d84>
    79ed:	e9 6e e1 ff ff       	jmp    5b60 <CatPrint>
    79f2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    79f9:	00 00 00 00 
    79fd:	0f 1f 00             	nopl   (%rax)

0000000000007a00 <CatPrintIPv6.isra.0>:
        CatPrintIPv6_ADD( Address-> Addr[ 2 ] , Address-> Addr[ 3 ] ) ,
    7a00:	0f b6 c9             	movzbl %cl,%ecx
CatPrintIPv6(
    7a03:	41 55                	push   %r13
    7a05:	49 89 fa             	mov    %rdi,%r10
        CatPrintIPv6_ADD( Address-> Addr[ 2 ] , Address-> Addr[ 3 ] ) ,
    7a08:	45 0f b6 c0          	movzbl %r8b,%r8d
CatPrintIPv6(
    7a0c:	41 54                	push   %r12
        CatPrintIPv6_ADD( Address-> Addr[ 2 ] , Address-> Addr[ 3 ] ) ,
    7a0e:	c1 e1 08             	shl    $0x8,%ecx
CatPrintIPv6(
    7a11:	41 89 f4             	mov    %esi,%r12d
        CatPrintIPv6_ADD( Address-> Addr[ 4 ] , Address-> Addr[ 5 ] ) ,
    7a14:	41 0f b6 f1          	movzbl %r9b,%esi
CatPrintIPv6(
    7a18:	55                   	push   %rbp
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a19:	44 09 c1             	or     %r8d,%ecx
CatPrintIPv6(
    7a1c:	44 0f b6 ea          	movzbl %dl,%r13d
        CatPrintIPv6_ADD( Address-> Addr[ 4 ] , Address-> Addr[ 5 ] ) ,
    7a20:	c1 e6 08             	shl    $0x8,%esi
CatPrintIPv6(
    7a23:	53                   	push   %rbx
        CatPrintIPv6_ADD( Address-> Addr[ 14 ] , Address-> Addr[ 15 ] ) ) ;
    7a24:	0f b6 7c 24 70       	movzbl 0x70(%rsp),%edi
        CatPrintIPv6_ADD( Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ) ,
    7a29:	41 0f b6 d4          	movzbl %r12b,%edx
        CatPrintIPv6_ADD( Address-> Addr[ 14 ] , Address-> Addr[ 15 ] ) ) ;
    7a2d:	44 0f b6 44 24 78    	movzbl 0x78(%rsp),%r8d
CatPrintIPv6(
    7a33:	0f b6 44 24 40       	movzbl 0x40(%rsp),%eax
        CatPrintIPv6_ADD( Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ) ,
    7a38:	c1 e2 08             	shl    $0x8,%edx
        CatPrintIPv6_ADD( Address-> Addr[ 14 ] , Address-> Addr[ 15 ] ) ) ;
    7a3b:	c1 e7 08             	shl    $0x8,%edi
        CatPrintIPv6_ADD( Address-> Addr[ 6 ] , Address-> Addr[ 7 ] ) ,
    7a3e:	0f b6 6c 24 38       	movzbl 0x38(%rsp),%ebp
        CatPrintIPv6_ADD( Address-> Addr[ 4 ] , Address-> Addr[ 5 ] ) ,
    7a43:	0f b6 5c 24 28       	movzbl 0x28(%rsp),%ebx
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a48:	44 09 ea             	or     %r13d,%edx
    7a4b:	44 09 c7             	or     %r8d,%edi
        CatPrintIPv6_ADD( Address-> Addr[ 12 ] , Address-> Addr[ 13 ] ) ,
    7a4e:	44 0f b6 44 24 68    	movzbl 0x68(%rsp),%r8d
        CatPrintIPv6_ADD( Address-> Addr[ 6 ] , Address-> Addr[ 7 ] ) ,
    7a54:	44 0f b6 5c 24 30    	movzbl 0x30(%rsp),%r11d
        CatPrintIPv6_ADD( Address-> Addr[ 8 ] , Address-> Addr[ 9 ] ) ,
    7a5a:	c1 e0 08             	shl    $0x8,%eax
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a5d:	89 7c 24 40          	mov    %edi,0x40(%rsp)
        CatPrintIPv6_ADD( Address-> Addr[ 12 ] , Address-> Addr[ 13 ] ) ,
    7a61:	0f b6 7c 24 60       	movzbl 0x60(%rsp),%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a66:	09 de                	or     %ebx,%esi
        CatPrintIPv6_ADD( Address-> Addr[ 6 ] , Address-> Addr[ 7 ] ) ,
    7a68:	41 c1 e3 08          	shl    $0x8,%r11d
        CatPrintIPv6_ADD( Address-> Addr[ 12 ] , Address-> Addr[ 13 ] ) ,
    7a6c:	c1 e7 08             	shl    $0x8,%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a6f:	45 89 d9             	mov    %r11d,%r9d
    7a72:	44 09 c7             	or     %r8d,%edi
        CatPrintIPv6_ADD( Address-> Addr[ 10 ] , Address-> Addr[ 11 ] ) ,
    7a75:	44 0f b6 44 24 58    	movzbl 0x58(%rsp),%r8d
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a7b:	41 09 e9             	or     %ebp,%r9d
    7a7e:	89 7c 24 38          	mov    %edi,0x38(%rsp)
        CatPrintIPv6_ADD( Address-> Addr[ 10 ] , Address-> Addr[ 11 ] ) ,
    7a82:	0f b6 7c 24 50       	movzbl 0x50(%rsp),%edi
    7a87:	c1 e7 08             	shl    $0x8,%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7a8a:	44 09 c7             	or     %r8d,%edi
    7a8d:	41 89 f0             	mov    %esi,%r8d
    7a90:	48 8d 35 21 73 00 00 	lea    0x7321(%rip),%rsi        # edb8 <_DYNAMIC+0x2db8>
    7a97:	89 7c 24 30          	mov    %edi,0x30(%rsp)
        CatPrintIPv6_ADD( Address-> Addr[ 8 ] , Address-> Addr[ 9 ] ) ,
    7a9b:	0f b6 7c 24 48       	movzbl 0x48(%rsp),%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7aa0:	09 f8                	or     %edi,%eax
    7aa2:	4c 89 d7             	mov    %r10,%rdi
    7aa5:	89 44 24 28          	mov    %eax,0x28(%rsp)
}
    7aa9:	5b                   	pop    %rbx
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7aaa:	31 c0                	xor    %eax,%eax
}
    7aac:	5d                   	pop    %rbp
    7aad:	41 5c                	pop    %r12
    7aaf:	41 5d                	pop    %r13
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    7ab1:	e9 aa e0 ff ff       	jmp    5b60 <CatPrint>
    7ab6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7abd:	00 00 00 

0000000000007ac0 <_DevPathIPv6>:
{
    7ac0:	f3 0f 1e fa          	endbr64 
    7ac4:	41 54                	push   %r12
    CatPrint( Str , L"IPv6(") ;
    7ac6:	31 c0                	xor    %eax,%eax
    CatPrint( Str , L",") ;
    7ac8:	4c 8d 25 99 6d 00 00 	lea    0x6d99(%rip),%r12        # e868 <_DYNAMIC+0x2868>
{
    7acf:	55                   	push   %rbp
    7ad0:	48 89 fd             	mov    %rdi,%rbp
    7ad3:	53                   	push   %rbx
    7ad4:	48 89 f3             	mov    %rsi,%rbx
    CatPrint( Str , L"IPv6(") ;
    7ad7:	48 8d 35 46 73 00 00 	lea    0x7346(%rip),%rsi        # ee24 <_DYNAMIC+0x2e24>
{
    7ade:	48 83 ec 60          	sub    $0x60,%rsp
    CatPrint( Str , L"IPv6(") ;
    7ae2:	e8 79 e0 ff ff       	call   5b60 <CatPrint>
    CatPrintIPv6( Str , & IP-> RemoteIpAddress ) ;
    7ae7:	0f b6 43 23          	movzbl 0x23(%rbx),%eax
    7aeb:	0f b6 53 15          	movzbl 0x15(%rbx),%edx
    7aef:	48 89 ef             	mov    %rbp,%rdi
    7af2:	0f b6 4b 16          	movzbl 0x16(%rbx),%ecx
    7af6:	0f b6 73 14          	movzbl 0x14(%rbx),%esi
    7afa:	44 0f b6 4b 18       	movzbl 0x18(%rbx),%r9d
    7aff:	44 0f b6 43 17       	movzbl 0x17(%rbx),%r8d
    7b04:	88 44 24 50          	mov    %al,0x50(%rsp)
    7b08:	0f b6 43 22          	movzbl 0x22(%rbx),%eax
    7b0c:	88 44 24 48          	mov    %al,0x48(%rsp)
    7b10:	0f b6 43 21          	movzbl 0x21(%rbx),%eax
    7b14:	88 44 24 40          	mov    %al,0x40(%rsp)
    7b18:	0f b6 43 20          	movzbl 0x20(%rbx),%eax
    7b1c:	88 44 24 38          	mov    %al,0x38(%rsp)
    7b20:	0f b6 43 1f          	movzbl 0x1f(%rbx),%eax
    7b24:	88 44 24 30          	mov    %al,0x30(%rsp)
    7b28:	0f b6 43 1e          	movzbl 0x1e(%rbx),%eax
    7b2c:	88 44 24 28          	mov    %al,0x28(%rsp)
    7b30:	0f b6 43 1d          	movzbl 0x1d(%rbx),%eax
    7b34:	88 44 24 20          	mov    %al,0x20(%rsp)
    7b38:	0f b6 43 1c          	movzbl 0x1c(%rbx),%eax
    7b3c:	88 44 24 18          	mov    %al,0x18(%rsp)
    7b40:	0f b6 43 1b          	movzbl 0x1b(%rbx),%eax
    7b44:	88 44 24 10          	mov    %al,0x10(%rsp)
    7b48:	0f b6 43 1a          	movzbl 0x1a(%rbx),%eax
    7b4c:	88 44 24 08          	mov    %al,0x8(%rsp)
    7b50:	0f b6 43 19          	movzbl 0x19(%rbx),%eax
    7b54:	88 04 24             	mov    %al,(%rsp)
    7b57:	e8 a4 fe ff ff       	call   7a00 <CatPrintIPv6.isra.0>
    CatPrint( Str , L",") ;
    7b5c:	4c 89 e6             	mov    %r12,%rsi
    7b5f:	48 89 ef             	mov    %rbp,%rdi
    7b62:	31 c0                	xor    %eax,%eax
    7b64:	e8 f7 df ff ff       	call   5b60 <CatPrint>
    CatPrintNetworkProtocol( Str, IP-> Protocol ) ;
    7b69:	0f b7 53 28          	movzwl 0x28(%rbx),%edx
    if ( Proto == 6 ) {
    7b6d:	66 83 fa 06          	cmp    $0x6,%dx
    7b71:	0f 84 f9 00 00 00    	je     7c70 <_DevPathIPv6+0x1b0>
    } else if ( Proto == 17 ) {
    7b77:	66 83 fa 11          	cmp    $0x11,%dx
    7b7b:	0f 84 cf 00 00 00    	je     7c50 <_DevPathIPv6+0x190>
        CatPrint( Str , L"%d" , Proto ) ;
    7b81:	48 8d 35 b8 72 00 00 	lea    0x72b8(%rip),%rsi        # ee40 <_DYNAMIC+0x2e40>
    7b88:	48 89 ef             	mov    %rbp,%rdi
    7b8b:	31 c0                	xor    %eax,%eax
    7b8d:	e8 ce df ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L",%s," , IP-> IPAddressOrigin ?
    7b92:	80 7b 2a 00          	cmpb   $0x0,0x2a(%rbx)
    7b96:	48 8d 05 4b 72 00 00 	lea    0x724b(%rip),%rax        # ede8 <_DYNAMIC+0x2de8>
    7b9d:	48 89 ef             	mov    %rbp,%rdi
    7ba0:	48 8d 15 6f 72 00 00 	lea    0x726f(%rip),%rdx        # ee16 <_DYNAMIC+0x2e16>
    7ba7:	48 8d 35 98 72 00 00 	lea    0x7298(%rip),%rsi        # ee46 <_DYNAMIC+0x2e46>
    7bae:	48 0f 45 d0          	cmovne %rax,%rdx
    7bb2:	31 c0                	xor    %eax,%eax
    7bb4:	e8 a7 df ff ff       	call   5b60 <CatPrint>
    CatPrintIPv6( Str , & IP-> LocalIpAddress ) ;
    7bb9:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    7bbd:	0f b6 4b 06          	movzbl 0x6(%rbx),%ecx
    7bc1:	48 89 ef             	mov    %rbp,%rdi
    7bc4:	0f b6 53 05          	movzbl 0x5(%rbx),%edx
    7bc8:	0f b6 73 04          	movzbl 0x4(%rbx),%esi
    7bcc:	44 0f b6 4b 08       	movzbl 0x8(%rbx),%r9d
    7bd1:	44 0f b6 43 07       	movzbl 0x7(%rbx),%r8d
    7bd6:	88 44 24 50          	mov    %al,0x50(%rsp)
    7bda:	0f b6 43 12          	movzbl 0x12(%rbx),%eax
    7bde:	88 44 24 48          	mov    %al,0x48(%rsp)
    7be2:	0f b6 43 11          	movzbl 0x11(%rbx),%eax
    7be6:	88 44 24 40          	mov    %al,0x40(%rsp)
    7bea:	0f b6 43 10          	movzbl 0x10(%rbx),%eax
    7bee:	88 44 24 38          	mov    %al,0x38(%rsp)
    7bf2:	0f b6 43 0f          	movzbl 0xf(%rbx),%eax
    7bf6:	88 44 24 30          	mov    %al,0x30(%rsp)
    7bfa:	0f b6 43 0e          	movzbl 0xe(%rbx),%eax
    7bfe:	88 44 24 28          	mov    %al,0x28(%rsp)
    7c02:	0f b6 43 0d          	movzbl 0xd(%rbx),%eax
    7c06:	88 44 24 20          	mov    %al,0x20(%rsp)
    7c0a:	0f b6 43 0c          	movzbl 0xc(%rbx),%eax
    7c0e:	88 44 24 18          	mov    %al,0x18(%rsp)
    7c12:	0f b6 43 0b          	movzbl 0xb(%rbx),%eax
    7c16:	88 44 24 10          	mov    %al,0x10(%rsp)
    7c1a:	0f b6 43 0a          	movzbl 0xa(%rbx),%eax
    7c1e:	88 44 24 08          	mov    %al,0x8(%rsp)
    7c22:	0f b6 43 09          	movzbl 0x9(%rbx),%eax
    7c26:	88 04 24             	mov    %al,(%rsp)
    7c29:	e8 d2 fd ff ff       	call   7a00 <CatPrintIPv6.isra.0>
    if ( DevicePathNodeLength( & IP-> Header ) == sizeof( IPv6_DEVICE_PATH ) ) {
    7c2e:	66 83 7b 02 3c       	cmpw   $0x3c,0x2(%rbx)
    7c33:	74 5b                	je     7c90 <_DevPathIPv6+0x1d0>
}
    7c35:	48 83 c4 60          	add    $0x60,%rsp
    CatPrint( Str , L")") ;
    7c39:	48 89 ef             	mov    %rbp,%rdi
    7c3c:	48 8d 35 ed 6d 00 00 	lea    0x6ded(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
    7c43:	31 c0                	xor    %eax,%eax
}
    7c45:	5b                   	pop    %rbx
    7c46:	5d                   	pop    %rbp
    7c47:	41 5c                	pop    %r12
    CatPrint( Str , L")") ;
    7c49:	e9 12 df ff ff       	jmp    5b60 <CatPrint>
    7c4e:	66 90                	xchg   %ax,%ax
        CatPrint( Str , L"UDP" ) ;
    7c50:	48 8d 35 e1 71 00 00 	lea    0x71e1(%rip),%rsi        # ee38 <_DYNAMIC+0x2e38>
    7c57:	48 89 ef             	mov    %rbp,%rdi
    7c5a:	31 c0                	xor    %eax,%eax
    7c5c:	e8 ff de ff ff       	call   5b60 <CatPrint>
    7c61:	e9 2c ff ff ff       	jmp    7b92 <_DevPathIPv6+0xd2>
    7c66:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7c6d:	00 00 00 
        CatPrint( Str , L"TCP" ) ;
    7c70:	48 8d 35 b9 71 00 00 	lea    0x71b9(%rip),%rsi        # ee30 <_DYNAMIC+0x2e30>
    7c77:	48 89 ef             	mov    %rbp,%rdi
    7c7a:	31 c0                	xor    %eax,%eax
    7c7c:	e8 df de ff ff       	call   5b60 <CatPrint>
    7c81:	e9 0c ff ff ff       	jmp    7b92 <_DevPathIPv6+0xd2>
    7c86:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7c8d:	00 00 00 
        CatPrint( Str , L",") ;
    7c90:	4c 89 e6             	mov    %r12,%rsi
    7c93:	48 89 ef             	mov    %rbp,%rdi
    7c96:	31 c0                	xor    %eax,%eax
    7c98:	e8 c3 de ff ff       	call   5b60 <CatPrint>
        CatPrintIPv6( Str , & IP-> GatewayIpAddress ) ;
    7c9d:	0f b6 43 3b          	movzbl 0x3b(%rbx),%eax
    7ca1:	0f b6 53 2d          	movzbl 0x2d(%rbx),%edx
    7ca5:	48 89 ef             	mov    %rbp,%rdi
    7ca8:	0f b6 4b 2e          	movzbl 0x2e(%rbx),%ecx
    7cac:	0f b6 73 2c          	movzbl 0x2c(%rbx),%esi
    7cb0:	44 0f b6 4b 30       	movzbl 0x30(%rbx),%r9d
    7cb5:	44 0f b6 43 2f       	movzbl 0x2f(%rbx),%r8d
    7cba:	88 44 24 50          	mov    %al,0x50(%rsp)
    7cbe:	0f b6 43 3a          	movzbl 0x3a(%rbx),%eax
    7cc2:	88 44 24 48          	mov    %al,0x48(%rsp)
    7cc6:	0f b6 43 39          	movzbl 0x39(%rbx),%eax
    7cca:	88 44 24 40          	mov    %al,0x40(%rsp)
    7cce:	0f b6 43 38          	movzbl 0x38(%rbx),%eax
    7cd2:	88 44 24 38          	mov    %al,0x38(%rsp)
    7cd6:	0f b6 43 37          	movzbl 0x37(%rbx),%eax
    7cda:	88 44 24 30          	mov    %al,0x30(%rsp)
    7cde:	0f b6 43 36          	movzbl 0x36(%rbx),%eax
    7ce2:	88 44 24 28          	mov    %al,0x28(%rsp)
    7ce6:	0f b6 43 35          	movzbl 0x35(%rbx),%eax
    7cea:	88 44 24 20          	mov    %al,0x20(%rsp)
    7cee:	0f b6 43 34          	movzbl 0x34(%rbx),%eax
    7cf2:	88 44 24 18          	mov    %al,0x18(%rsp)
    7cf6:	0f b6 43 33          	movzbl 0x33(%rbx),%eax
    7cfa:	88 44 24 10          	mov    %al,0x10(%rsp)
    7cfe:	0f b6 43 32          	movzbl 0x32(%rbx),%eax
    7d02:	88 44 24 08          	mov    %al,0x8(%rsp)
    7d06:	0f b6 43 31          	movzbl 0x31(%rbx),%eax
    7d0a:	88 04 24             	mov    %al,(%rsp)
    7d0d:	e8 ee fc ff ff       	call   7a00 <CatPrintIPv6.isra.0>
        CatPrint( Str , L",") ;
    7d12:	4c 89 e6             	mov    %r12,%rsi
    7d15:	48 89 ef             	mov    %rbp,%rdi
    7d18:	31 c0                	xor    %eax,%eax
    7d1a:	e8 41 de ff ff       	call   5b60 <CatPrint>
        CatPrint( Str , L"%d" , & IP-> PrefixLength ) ;
    7d1f:	48 8d 53 2b          	lea    0x2b(%rbx),%rdx
    7d23:	48 89 ef             	mov    %rbp,%rdi
    7d26:	31 c0                	xor    %eax,%eax
    7d28:	48 8d 35 11 71 00 00 	lea    0x7111(%rip),%rsi        # ee40 <_DYNAMIC+0x2e40>
    7d2f:	e8 2c de ff ff       	call   5b60 <CatPrint>
    7d34:	e9 fc fe ff ff       	jmp    7c35 <_DevPathIPv6+0x175>
    7d39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007d40 <_DevPathIPv4>:
{
    7d40:	f3 0f 1e fa          	endbr64 
    7d44:	41 55                	push   %r13
    CatPrint( Str , L"IPv4(") ;
    7d46:	31 c0                	xor    %eax,%eax
    CatPrint( Str , L",") ;
    7d48:	4c 8d 2d 19 6b 00 00 	lea    0x6b19(%rip),%r13        # e868 <_DYNAMIC+0x2868>
{
    7d4f:	41 54                	push   %r12
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    7d51:	4c 8d 25 0e 71 00 00 	lea    0x710e(%rip),%r12        # ee66 <_DYNAMIC+0x2e66>
{
    7d58:	55                   	push   %rbp
    7d59:	48 89 fd             	mov    %rdi,%rbp
    7d5c:	53                   	push   %rbx
    7d5d:	48 89 f3             	mov    %rsi,%rbx
    CatPrint( Str , L"IPv4(") ;
    7d60:	48 8d 35 f3 70 00 00 	lea    0x70f3(%rip),%rsi        # ee5a <_DYNAMIC+0x2e5a>
{
    7d67:	48 83 ec 08          	sub    $0x8,%rsp
    CatPrint( Str , L"IPv4(") ;
    7d6b:	e8 f0 dd ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    7d70:	0f b6 53 08          	movzbl 0x8(%rbx),%edx
    7d74:	0f b6 4b 09          	movzbl 0x9(%rbx),%ecx
    7d78:	4c 89 e6             	mov    %r12,%rsi
    7d7b:	44 0f b6 4b 0b       	movzbl 0xb(%rbx),%r9d
    7d80:	44 0f b6 43 0a       	movzbl 0xa(%rbx),%r8d
    7d85:	48 89 ef             	mov    %rbp,%rdi
    7d88:	31 c0                	xor    %eax,%eax
    7d8a:	e8 d1 dd ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L",") ;
    7d8f:	4c 89 ee             	mov    %r13,%rsi
    7d92:	48 89 ef             	mov    %rbp,%rdi
    7d95:	31 c0                	xor    %eax,%eax
    7d97:	e8 c4 dd ff ff       	call   5b60 <CatPrint>
    CatPrintNetworkProtocol( Str , IP-> Protocol ) ;
    7d9c:	0f b7 53 10          	movzwl 0x10(%rbx),%edx
    if ( Proto == 6 ) {
    7da0:	66 83 fa 06          	cmp    $0x6,%dx
    7da4:	0f 84 e6 00 00 00    	je     7e90 <_DevPathIPv4+0x150>
    } else if ( Proto == 17 ) {
    7daa:	66 83 fa 11          	cmp    $0x11,%dx
    7dae:	0f 84 c4 00 00 00    	je     7e78 <_DevPathIPv4+0x138>
        CatPrint( Str , L"%d" , Proto ) ;
    7db4:	48 8d 35 85 70 00 00 	lea    0x7085(%rip),%rsi        # ee40 <_DYNAMIC+0x2e40>
    7dbb:	48 89 ef             	mov    %rbp,%rdi
    7dbe:	31 c0                	xor    %eax,%eax
    7dc0:	e8 9b dd ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L",%s" , IP-> StaticIpAddress ? L"Static" : L"DHCP" ) ;
    7dc5:	80 7b 12 00          	cmpb   $0x0,0x12(%rbx)
    7dc9:	48 8d 05 80 70 00 00 	lea    0x7080(%rip),%rax        # ee50 <_DYNAMIC+0x2e50>
    7dd0:	48 89 ef             	mov    %rbp,%rdi
    7dd3:	48 8d 15 3c 70 00 00 	lea    0x703c(%rip),%rdx        # ee16 <_DYNAMIC+0x2e16>
    7dda:	48 8d 35 9d 70 00 00 	lea    0x709d(%rip),%rsi        # ee7e <_DYNAMIC+0x2e7e>
    7de1:	48 0f 44 d0          	cmove  %rax,%rdx
    7de5:	31 c0                	xor    %eax,%eax
    7de7:	e8 74 dd ff ff       	call   5b60 <CatPrint>
    val |= Address-> Addr[ 2 ] | Address-> Addr[ 3 ] ;
    7dec:	0f b6 43 05          	movzbl 0x5(%rbx),%eax
    7df0:	0a 43 04             	or     0x4(%rbx),%al
    7df3:	0a 43 06             	or     0x6(%rbx),%al
    if ( ! show && DevicePathNodeLength( & IP-> Header ) == sizeof( IPv4_DEVICE_PATH ) ) {
    7df6:	0a 43 07             	or     0x7(%rbx),%al
    7df9:	74 55                	je     7e50 <_DevPathIPv4+0x110>
        CatPrint( Str , L"," ) ;
    7dfb:	4c 89 ee             	mov    %r13,%rsi
    7dfe:	48 89 ef             	mov    %rbp,%rdi
    7e01:	31 c0                	xor    %eax,%eax
    7e03:	e8 58 dd ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    7e08:	0f b6 4b 05          	movzbl 0x5(%rbx),%ecx
    7e0c:	0f b6 53 04          	movzbl 0x4(%rbx),%edx
    7e10:	31 c0                	xor    %eax,%eax
    7e12:	44 0f b6 4b 07       	movzbl 0x7(%rbx),%r9d
    7e17:	44 0f b6 43 06       	movzbl 0x6(%rbx),%r8d
    7e1c:	4c 89 e6             	mov    %r12,%rsi
    7e1f:	48 89 ef             	mov    %rbp,%rdi
    7e22:	e8 39 dd ff ff       	call   5b60 <CatPrint>
        if ( DevicePathNodeLength( & IP-> Header ) == sizeof( IPv4_DEVICE_PATH ) ) {
    7e27:	66 83 7b 02 1c       	cmpw   $0x1c,0x2(%rbx)
    7e2c:	0f 84 7e 00 00 00    	je     7eb0 <_DevPathIPv4+0x170>
}
    7e32:	48 83 c4 08          	add    $0x8,%rsp
    CatPrint( Str , L")") ;
    7e36:	48 89 ef             	mov    %rbp,%rdi
    7e39:	48 8d 35 f0 6b 00 00 	lea    0x6bf0(%rip),%rsi        # ea30 <_DYNAMIC+0x2a30>
    7e40:	31 c0                	xor    %eax,%eax
}
    7e42:	5b                   	pop    %rbx
    7e43:	5d                   	pop    %rbp
    7e44:	41 5c                	pop    %r12
    7e46:	41 5d                	pop    %r13
    CatPrint( Str , L")") ;
    7e48:	e9 13 dd ff ff       	jmp    5b60 <CatPrint>
    7e4d:	0f 1f 00             	nopl   (%rax)
    if ( ! show && DevicePathNodeLength( & IP-> Header ) == sizeof( IPv4_DEVICE_PATH ) ) {
    7e50:	66 83 7b 02 1c       	cmpw   $0x1c,0x2(%rbx)
    7e55:	75 db                	jne    7e32 <_DevPathIPv4+0xf2>
    if ( show ) {
    7e57:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    7e5b:	0a 43 14             	or     0x14(%rbx),%al
    7e5e:	0a 43 15             	or     0x15(%rbx),%al
    7e61:	0a 43 16             	or     0x16(%rbx),%al
    7e64:	0a 43 17             	or     0x17(%rbx),%al
    7e67:	0a 43 18             	or     0x18(%rbx),%al
    7e6a:	0a 43 19             	or     0x19(%rbx),%al
    7e6d:	0a 43 1a             	or     0x1a(%rbx),%al
    7e70:	74 c0                	je     7e32 <_DevPathIPv4+0xf2>
    7e72:	eb 87                	jmp    7dfb <_DevPathIPv4+0xbb>
    7e74:	0f 1f 40 00          	nopl   0x0(%rax)
        CatPrint( Str , L"UDP" ) ;
    7e78:	48 8d 35 b9 6f 00 00 	lea    0x6fb9(%rip),%rsi        # ee38 <_DYNAMIC+0x2e38>
    7e7f:	48 89 ef             	mov    %rbp,%rdi
    7e82:	31 c0                	xor    %eax,%eax
    7e84:	e8 d7 dc ff ff       	call   5b60 <CatPrint>
    7e89:	e9 37 ff ff ff       	jmp    7dc5 <_DevPathIPv4+0x85>
    7e8e:	66 90                	xchg   %ax,%ax
        CatPrint( Str , L"TCP" ) ;
    7e90:	48 8d 35 99 6f 00 00 	lea    0x6f99(%rip),%rsi        # ee30 <_DYNAMIC+0x2e30>
    7e97:	48 89 ef             	mov    %rbp,%rdi
    7e9a:	31 c0                	xor    %eax,%eax
    7e9c:	e8 bf dc ff ff       	call   5b60 <CatPrint>
    7ea1:	e9 1f ff ff ff       	jmp    7dc5 <_DevPathIPv4+0x85>
    7ea6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7ead:	00 00 00 
            if ( show ) {
    7eb0:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    7eb4:	0a 43 14             	or     0x14(%rbx),%al
    7eb7:	0a 43 15             	or     0x15(%rbx),%al
    7eba:	0a 43 16             	or     0x16(%rbx),%al
    7ebd:	0a 43 17             	or     0x17(%rbx),%al
    7ec0:	0a 43 18             	or     0x18(%rbx),%al
    7ec3:	0a 43 19             	or     0x19(%rbx),%al
    7ec6:	0a 43 1a             	or     0x1a(%rbx),%al
    7ec9:	0f 84 63 ff ff ff    	je     7e32 <_DevPathIPv4+0xf2>
                CatPrint( Str , L",") ;
    7ecf:	4c 89 ee             	mov    %r13,%rsi
    7ed2:	48 89 ef             	mov    %rbp,%rdi
    7ed5:	31 c0                	xor    %eax,%eax
    7ed7:	e8 84 dc ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    7edc:	0f b6 4b 14          	movzbl 0x14(%rbx),%ecx
    7ee0:	0f b6 53 13          	movzbl 0x13(%rbx),%edx
    7ee4:	31 c0                	xor    %eax,%eax
    7ee6:	44 0f b6 4b 16       	movzbl 0x16(%rbx),%r9d
    7eeb:	44 0f b6 43 15       	movzbl 0x15(%rbx),%r8d
    7ef0:	4c 89 e6             	mov    %r12,%rsi
    7ef3:	48 89 ef             	mov    %rbp,%rdi
    7ef6:	e8 65 dc ff ff       	call   5b60 <CatPrint>
    val |= Address-> Addr[ 2 ] | Address-> Addr[ 3 ] ;
    7efb:	0f b6 43 17          	movzbl 0x17(%rbx),%eax
    7eff:	0a 43 18             	or     0x18(%rbx),%al
    7f02:	0a 43 19             	or     0x19(%rbx),%al
                if ( IsNotNullIPv4( & IP-> SubnetMask ) ) {
    7f05:	0a 43 1a             	or     0x1a(%rbx),%al
    7f08:	0f 84 24 ff ff ff    	je     7e32 <_DevPathIPv4+0xf2>
                    CatPrint( Str , L",") ;
    7f0e:	4c 89 ee             	mov    %r13,%rsi
    7f11:	48 89 ef             	mov    %rbp,%rdi
    7f14:	31 c0                	xor    %eax,%eax
    7f16:	e8 45 dc ff ff       	call   5b60 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    7f1b:	0f b6 4b 18          	movzbl 0x18(%rbx),%ecx
    7f1f:	0f b6 53 17          	movzbl 0x17(%rbx),%edx
    7f23:	4c 89 e6             	mov    %r12,%rsi
    7f26:	44 0f b6 4b 1a       	movzbl 0x1a(%rbx),%r9d
    7f2b:	44 0f b6 43 19       	movzbl 0x19(%rbx),%r8d
    7f30:	48 89 ef             	mov    %rbp,%rdi
    7f33:	31 c0                	xor    %eax,%eax
    7f35:	e8 26 dc ff ff       	call   5b60 <CatPrint>
}
    7f3a:	e9 f3 fe ff ff       	jmp    7e32 <_DevPathIPv4+0xf2>
    7f3f:	90                   	nop

0000000000007f40 <DevicePathFromHandle>:
{
    7f40:	f3 0f 1e fa          	endbr64 
    7f44:	48 83 ec 38          	sub    $0x38,%rsp
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    7f48:	48 8b 05 71 3d 00 00 	mov    0x3d71(%rip),%rax        # bcc0 <BS>
{
    7f4f:	48 89 f9             	mov    %rdi,%rcx
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    7f52:	48 8d 15 37 35 00 00 	lea    0x3537(%rip),%rdx        # b490 <gEfiDevicePathProtocolGuid>
    7f59:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    7f5e:	ff 90 98 00 00 00    	call   *0x98(%rax)
    return DevicePath;
    7f64:	48 85 c0             	test   %rax,%rax
    7f67:	b8 00 00 00 00       	mov    $0x0,%eax
    7f6c:	48 0f 49 44 24 28    	cmovns 0x28(%rsp),%rax
}
    7f72:	48 83 c4 38          	add    $0x38,%rsp
    7f76:	c3                   	ret    
    7f77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    7f7e:	00 00 

0000000000007f80 <DevicePathInstance>:
{
    7f80:	f3 0f 1e fa          	endbr64 
    7f84:	41 57                	push   %r15
    7f86:	41 56                	push   %r14
    7f88:	41 55                	push   %r13
    7f8a:	41 54                	push   %r12
    7f8c:	55                   	push   %rbp
    7f8d:	53                   	push   %rbx
    7f8e:	48 83 ec 08          	sub    $0x8,%rsp
    DevPath = *DevicePath;
    7f92:	4c 8b 27             	mov    (%rdi),%r12
    if (!DevPath) {
    7f95:	4d 85 e4             	test   %r12,%r12
    7f98:	74 58                	je     7ff2 <DevicePathInstance+0x72>
        if (IsDevicePathEndType(DevPath)) {
    7f9a:	41 0f b6 04 24       	movzbl (%r12),%eax
        Next = NextDevicePathNode(DevPath);
    7f9f:	41 0f b7 5c 24 02    	movzwl 0x2(%r12),%ebx
    7fa5:	49 89 fd             	mov    %rdi,%r13
    7fa8:	49 89 f6             	mov    %rsi,%r14
        if (IsDevicePathEndType(DevPath)) {
    7fab:	83 e0 7f             	and    $0x7f,%eax
        Next = NextDevicePathNode(DevPath);
    7fae:	4c 01 e3             	add    %r12,%rbx
        if (IsDevicePathEndType(DevPath)) {
    7fb1:	3c 7f                	cmp    $0x7f,%al
    7fb3:	74 66                	je     801b <DevicePathInstance+0x9b>
    7fb5:	ba 01 02 00 00       	mov    $0x201,%edx
    7fba:	eb 0a                	jmp    7fc6 <DevicePathInstance+0x46>
    7fbc:	0f 1f 40 00          	nopl   0x0(%rax)
        if (Count > 01000) {
    7fc0:	48 83 ea 01          	sub    $0x1,%rdx
    7fc4:	74 3e                	je     8004 <DevicePathInstance+0x84>
        Next = NextDevicePathNode(DevPath);
    7fc6:	0f b7 43 02          	movzwl 0x2(%rbx),%eax
    7fca:	48 89 dd             	mov    %rbx,%rbp
    7fcd:	48 01 c3             	add    %rax,%rbx
        if (IsDevicePathEndType(DevPath)) {
    7fd0:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
    7fd4:	83 e0 7f             	and    $0x7f,%eax
    7fd7:	3c 7f                	cmp    $0x7f,%al
    7fd9:	75 e5                	jne    7fc0 <DevicePathInstance+0x40>
            DumpHex (0, 0, ((UINT8 *) DevPath) - ((UINT8 *) Start), Start);
    7fdb:	49 89 ef             	mov    %rbp,%r15
    7fde:	4d 29 e7             	sub    %r12,%r15
        Next = NULL;
    7fe1:	31 c0                	xor    %eax,%eax
    7fe3:	80 7d 01 ff          	cmpb   $0xff,0x1(%rbp)
    7fe7:	48 0f 44 d8          	cmove  %rax,%rbx
    *DevicePath = Next;
    7feb:	49 89 5d 00          	mov    %rbx,0x0(%r13)
    *Size = ((UINT8 *) DevPath) - ((UINT8 *) Start);
    7fef:	4d 89 3e             	mov    %r15,(%r14)
}
    7ff2:	48 83 c4 08          	add    $0x8,%rsp
    7ff6:	4c 89 e0             	mov    %r12,%rax
    7ff9:	5b                   	pop    %rbx
    7ffa:	5d                   	pop    %rbp
    7ffb:	41 5c                	pop    %r12
    7ffd:	41 5d                	pop    %r13
    7fff:	41 5e                	pop    %r14
    8001:	41 5f                	pop    %r15
    8003:	c3                   	ret    
            DumpHex (0, 0, ((UINT8 *) DevPath) - ((UINT8 *) Start), Start);
    8004:	49 89 ef             	mov    %rbp,%r15
    8007:	4c 89 e1             	mov    %r12,%rcx
    800a:	31 f6                	xor    %esi,%esi
    800c:	31 ff                	xor    %edi,%edi
    800e:	4d 29 e7             	sub    %r12,%r15
    8011:	4c 89 fa             	mov    %r15,%rdx
    8014:	e8 f7 e2 ff ff       	call   6310 <DumpHex>
            break;
    8019:	eb c6                	jmp    7fe1 <DevicePathInstance+0x61>
        if (IsDevicePathEndType(DevPath)) {
    801b:	4c 89 e5             	mov    %r12,%rbp
    801e:	45 31 ff             	xor    %r15d,%r15d
    8021:	eb be                	jmp    7fe1 <DevicePathInstance+0x61>
    8023:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    802a:	00 00 00 00 
    802e:	66 90                	xchg   %ax,%ax

0000000000008030 <DevicePathInstanceCount>:
{
    8030:	f3 0f 1e fa          	endbr64 
    8034:	41 54                	push   %r12
    Count = 0;
    8036:	45 31 e4             	xor    %r12d,%r12d
{
    8039:	55                   	push   %rbp
    803a:	53                   	push   %rbx
    803b:	48 83 ec 20          	sub    $0x20,%rsp
    803f:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    8044:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
    8049:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
    while (DevicePathInstance(&DevicePath, &Size)) {
    804e:	eb 04                	jmp    8054 <DevicePathInstanceCount+0x24>
        Count += 1;
    8050:	49 83 c4 01          	add    $0x1,%r12
    while (DevicePathInstance(&DevicePath, &Size)) {
    8054:	48 89 ee             	mov    %rbp,%rsi
    8057:	48 89 df             	mov    %rbx,%rdi
    805a:	e8 21 ff ff ff       	call   7f80 <DevicePathInstance>
    805f:	48 85 c0             	test   %rax,%rax
    8062:	75 ec                	jne    8050 <DevicePathInstanceCount+0x20>
}
    8064:	48 83 c4 20          	add    $0x20,%rsp
    8068:	4c 89 e0             	mov    %r12,%rax
    806b:	5b                   	pop    %rbx
    806c:	5d                   	pop    %rbp
    806d:	41 5c                	pop    %r12
    806f:	c3                   	ret    

0000000000008070 <DevicePathSize>:
{
    8070:	f3 0f 1e fa          	endbr64 
    while (!IsDevicePathEnd(DevPath)) {
    8074:	48 89 f8             	mov    %rdi,%rax
    8077:	eb 0e                	jmp    8087 <DevicePathSize+0x17>
    8079:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        DevPath = NextDevicePathNode(DevPath);
    8080:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    8084:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    8087:	0f b6 10             	movzbl (%rax),%edx
    808a:	83 e2 7f             	and    $0x7f,%edx
    808d:	80 fa 7f             	cmp    $0x7f,%dl
    8090:	75 ee                	jne    8080 <DevicePathSize+0x10>
    8092:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    8096:	75 e8                	jne    8080 <DevicePathSize+0x10>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    8098:	48 29 f8             	sub    %rdi,%rax
    809b:	48 83 c0 04          	add    $0x4,%rax
}
    809f:	c3                   	ret    

00000000000080a0 <DuplicateDevicePath>:
{
    80a0:	f3 0f 1e fa          	endbr64 
    80a4:	41 55                	push   %r13
    80a6:	48 89 f8             	mov    %rdi,%rax
    80a9:	49 89 fd             	mov    %rdi,%r13
    80ac:	41 54                	push   %r12
    80ae:	53                   	push   %rbx
    80af:	48 83 ec 20          	sub    $0x20,%rsp
    80b3:	eb 0a                	jmp    80bf <DuplicateDevicePath+0x1f>
    80b5:	0f 1f 00             	nopl   (%rax)
        DevPath = NextDevicePathNode(DevPath);
    80b8:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
    80bc:	48 01 c8             	add    %rcx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    80bf:	0f b6 08             	movzbl (%rax),%ecx
    80c2:	83 e1 7f             	and    $0x7f,%ecx
    80c5:	80 f9 7f             	cmp    $0x7f,%cl
    80c8:	75 ee                	jne    80b8 <DuplicateDevicePath+0x18>
    80ca:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    80ce:	75 e8                	jne    80b8 <DuplicateDevicePath+0x18>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    80d0:	4c 29 e8             	sub    %r13,%rax
    80d3:	48 8d 58 04          	lea    0x4(%rax),%rbx
    NewDevPath = AllocatePool (Size);
    80d7:	48 89 df             	mov    %rbx,%rdi
    80da:	e8 d1 b7 ff ff       	call   38b0 <AllocatePool>
    80df:	49 89 c4             	mov    %rax,%r12
    if (NewDevPath) {
    80e2:	48 85 c0             	test   %rax,%rax
    80e5:	74 0e                	je     80f5 <DuplicateDevicePath+0x55>
        CopyMem (NewDevPath, DevPath, Size);
    80e7:	49 89 d8             	mov    %rbx,%r8
    80ea:	4c 89 ea             	mov    %r13,%rdx
    80ed:	48 89 c1             	mov    %rax,%rcx
    80f0:	e8 bb b9 ff ff       	call   3ab0 <CopyMem>
}
    80f5:	48 83 c4 20          	add    $0x20,%rsp
    80f9:	4c 89 e0             	mov    %r12,%rax
    80fc:	5b                   	pop    %rbx
    80fd:	41 5c                	pop    %r12
    80ff:	41 5d                	pop    %r13
    8101:	c3                   	ret    
    8102:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8109:	00 00 00 00 
    810d:	0f 1f 00             	nopl   (%rax)

0000000000008110 <AppendDevicePath>:
{
    8110:	f3 0f 1e fa          	endbr64 
    8114:	41 57                	push   %r15
    8116:	41 56                	push   %r14
    8118:	41 55                	push   %r13
    811a:	49 89 f5             	mov    %rsi,%r13
    811d:	41 54                	push   %r12
    811f:	55                   	push   %rbp
    8120:	53                   	push   %rbx
    8121:	48 83 ec 48          	sub    $0x48,%rsp
    8125:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
    if (!Src1) {
    812a:	48 85 ff             	test   %rdi,%rdi
    812d:	0f 84 3e 01 00 00    	je     8271 <AppendDevicePath+0x161>
    8133:	49 89 f8             	mov    %rdi,%r8
    if (!Src2) {
    8136:	48 89 f8             	mov    %rdi,%rax
    8139:	48 85 f6             	test   %rsi,%rsi
    813c:	75 11                	jne    814f <AppendDevicePath+0x3f>
    813e:	e9 22 01 00 00       	jmp    8265 <AppendDevicePath+0x155>
    8143:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        DevPath = NextDevicePathNode(DevPath);
    8148:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    814c:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    814f:	0f b6 10             	movzbl (%rax),%edx
    8152:	83 e2 7f             	and    $0x7f,%edx
    8155:	80 fa 7f             	cmp    $0x7f,%dl
    8158:	75 ee                	jne    8148 <AppendDevicePath+0x38>
    815a:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    815e:	75 e8                	jne    8148 <AppendDevicePath+0x38>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    8160:	4c 29 c0             	sub    %r8,%rax
    8163:	4c 89 44 24 30       	mov    %r8,0x30(%rsp)
    Count = 0;
    8168:	31 db                	xor    %ebx,%ebx
    816a:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    816f:	4c 8d 70 04          	lea    0x4(%rax),%r14
DevicePathInstanceCount (
    8173:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    8178:	eb 0a                	jmp    8184 <AppendDevicePath+0x74>
    817a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        Count += 1;
    8180:	48 83 c3 01          	add    $0x1,%rbx
    while (DevicePathInstance(&DevicePath, &Size)) {
    8184:	48 89 ee             	mov    %rbp,%rsi
    8187:	4c 89 e7             	mov    %r12,%rdi
    818a:	e8 f1 fd ff ff       	call   7f80 <DevicePathInstance>
    818f:	48 85 c0             	test   %rax,%rax
    8192:	75 ec                	jne    8180 <AppendDevicePath+0x70>
    Src1Inst = DevicePathInstanceCount(Src1);
    8194:	4c 89 e8             	mov    %r13,%rax
    8197:	eb 0e                	jmp    81a7 <AppendDevicePath+0x97>
    8199:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        DevPath = NextDevicePathNode(DevPath);
    81a0:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    81a4:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    81a7:	0f b6 10             	movzbl (%rax),%edx
    81aa:	83 e2 7f             	and    $0x7f,%edx
    81ad:	80 fa 7f             	cmp    $0x7f,%dl
    81b0:	75 ee                	jne    81a0 <AppendDevicePath+0x90>
    81b2:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    81b6:	75 e8                	jne    81a0 <AppendDevicePath+0x90>
    Size = Src1Size * Src1Inst + Src2Size;
    81b8:	49 0f af de          	imul   %r14,%rbx
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    81bc:	4c 29 e8             	sub    %r13,%rax
    81bf:	4c 8d 74 24 28       	lea    0x28(%rsp),%r14
    81c4:	4c 8d 60 04          	lea    0x4(%rax),%r12
            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
    81c8:	4c 8d 3d e1 32 00 00 	lea    0x32e1(%rip),%r15        # b4b0 <EndInstanceDevicePath>
    Size = Src1Size * Src1Inst + Src2Size;
    81cf:	4a 8d 3c 23          	lea    (%rbx,%r12,1),%rdi
    81d3:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    Dst = AllocatePool (Size);
    81d8:	e8 d3 b6 ff ff       	call   38b0 <AllocatePool>
    81dd:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    if (Dst) {
    81e2:	48 89 c3             	mov    %rax,%rbx
    81e5:	48 85 c0             	test   %rax,%rax
    81e8:	75 3e                	jne    8228 <AppendDevicePath+0x118>
    81ea:	eb 65                	jmp    8251 <AppendDevicePath+0x141>
    81ec:	0f 1f 40 00          	nopl   0x0(%rax)
            CopyMem(DstPos, Inst, Size);
    81f0:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
    81f5:	48 89 d9             	mov    %rbx,%rcx
    81f8:	e8 b3 b8 ff ff       	call   3ab0 <CopyMem>
            DstPos += Size;
    81fd:	48 03 5c 24 38       	add    0x38(%rsp),%rbx
            CopyMem(DstPos, Src2, Src2Size);
    8202:	4d 89 e0             	mov    %r12,%r8
    8205:	4c 89 ea             	mov    %r13,%rdx
    8208:	48 89 d9             	mov    %rbx,%rcx
            DstPos += Src2Size;
    820b:	4c 01 e3             	add    %r12,%rbx
            CopyMem(DstPos, Src2, Src2Size);
    820e:	e8 9d b8 ff ff       	call   3ab0 <CopyMem>
            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
    8213:	48 89 d9             	mov    %rbx,%rcx
    8216:	4c 89 fa             	mov    %r15,%rdx
            DstPos += sizeof(EFI_DEVICE_PATH);
    8219:	48 83 c3 04          	add    $0x4,%rbx
            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
    821d:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    8223:	e8 88 b8 ff ff       	call   3ab0 <CopyMem>
        while ((Inst = DevicePathInstance (&Src1, &Size))) {
    8228:	48 89 ee             	mov    %rbp,%rsi
    822b:	4c 89 f7             	mov    %r14,%rdi
    822e:	e8 4d fd ff ff       	call   7f80 <DevicePathInstance>
    8233:	48 89 c2             	mov    %rax,%rdx
    8236:	48 85 c0             	test   %rax,%rax
    8239:	75 b5                	jne    81f0 <AppendDevicePath+0xe0>
        DstPos -= sizeof(EFI_DEVICE_PATH);
    823b:	48 8d 4b fc          	lea    -0x4(%rbx),%rcx
        CopyMem(DstPos, EndDevicePath, sizeof(EFI_DEVICE_PATH));
    823f:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    8245:	48 8d 15 68 32 00 00 	lea    0x3268(%rip),%rdx        # b4b4 <EndDevicePath>
    824c:	e8 5f b8 ff ff       	call   3ab0 <CopyMem>
}
    8251:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    8256:	48 83 c4 48          	add    $0x48,%rsp
    825a:	5b                   	pop    %rbx
    825b:	5d                   	pop    %rbp
    825c:	41 5c                	pop    %r12
    825e:	41 5d                	pop    %r13
    8260:	41 5e                	pop    %r14
    8262:	41 5f                	pop    %r15
    8264:	c3                   	ret    
        return DuplicateDevicePath (Src1);
    8265:	e8 36 fe ff ff       	call   80a0 <DuplicateDevicePath>
    826a:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    826f:	eb e0                	jmp    8251 <AppendDevicePath+0x141>
        return DuplicateDevicePath (Src2);
    8271:	48 89 f7             	mov    %rsi,%rdi
    8274:	e8 27 fe ff ff       	call   80a0 <DuplicateDevicePath>
    8279:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    827e:	eb d1                	jmp    8251 <AppendDevicePath+0x141>

0000000000008280 <AppendDevicePathNode>:
{
    8280:	f3 0f 1e fa          	endbr64 
    8284:	41 55                	push   %r13
    8286:	49 89 fd             	mov    %rdi,%r13
    8289:	41 54                	push   %r12
    828b:	49 89 f4             	mov    %rsi,%r12
    828e:	55                   	push   %rbp
    828f:	53                   	push   %rbx
    8290:	48 83 ec 28          	sub    $0x28,%rsp
    Length = DevicePathNodeLength(Src2);
    8294:	0f b7 5e 02          	movzwl 0x2(%rsi),%ebx
    Temp = AllocatePool (Length + sizeof(EFI_DEVICE_PATH));
    8298:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
    829c:	e8 0f b6 ff ff       	call   38b0 <AllocatePool>
    if (!Temp) {
    82a1:	48 85 c0             	test   %rax,%rax
    82a4:	74 4a                	je     82f0 <AppendDevicePathNode+0x70>
    82a6:	48 89 c5             	mov    %rax,%rbp
    CopyMem (Temp, Src2, Length);
    82a9:	49 89 d8             	mov    %rbx,%r8
    82ac:	4c 89 e2             	mov    %r12,%rdx
    82af:	48 89 c1             	mov    %rax,%rcx
    82b2:	e8 f9 b7 ff ff       	call   3ab0 <CopyMem>
    Eop = NextDevicePathNode(Temp);
    82b7:	0f b7 45 02          	movzwl 0x2(%rbp),%eax
    Src1 = AppendDevicePath (Src1, Temp);
    82bb:	48 89 ee             	mov    %rbp,%rsi
    82be:	4c 89 ef             	mov    %r13,%rdi
    SetDevicePathEndNode(Eop);
    82c1:	c7 44 05 00 7f ff 04 	movl   $0x4ff7f,0x0(%rbp,%rax,1)
    82c8:	00 
    Src1 = AppendDevicePath (Src1, Temp);
    82c9:	e8 42 fe ff ff       	call   8110 <AppendDevicePath>
    FreePool (Temp);
    82ce:	48 89 ef             	mov    %rbp,%rdi
    Src1 = AppendDevicePath (Src1, Temp);
    82d1:	49 89 c4             	mov    %rax,%r12
    FreePool (Temp);
    82d4:	e8 f7 b6 ff ff       	call   39d0 <FreePool>
}
    82d9:	48 83 c4 28          	add    $0x28,%rsp
    82dd:	4c 89 e0             	mov    %r12,%rax
    82e0:	5b                   	pop    %rbx
    82e1:	5d                   	pop    %rbp
    82e2:	41 5c                	pop    %r12
    82e4:	41 5d                	pop    %r13
    82e6:	c3                   	ret    
    82e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    82ee:	00 00 
    82f0:	48 83 c4 28          	add    $0x28,%rsp
        return NULL;
    82f4:	45 31 e4             	xor    %r12d,%r12d
}
    82f7:	5b                   	pop    %rbx
    82f8:	4c 89 e0             	mov    %r12,%rax
    82fb:	5d                   	pop    %rbp
    82fc:	41 5c                	pop    %r12
    82fe:	41 5d                	pop    %r13
    8300:	c3                   	ret    
    8301:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8308:	00 00 00 00 
    830c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000008310 <FileDevicePath>:
{
    8310:	f3 0f 1e fa          	endbr64 
    8314:	41 56                	push   %r14
    8316:	49 89 fe             	mov    %rdi,%r14
    Size = StrSize(FileName);
    8319:	48 89 f7             	mov    %rsi,%rdi
{
    831c:	41 55                	push   %r13
    831e:	49 89 f5             	mov    %rsi,%r13
    8321:	41 54                	push   %r12
    8323:	53                   	push   %rbx
    8324:	48 83 ec 38          	sub    $0x38,%rsp
    Size = StrSize(FileName);
    8328:	e8 c3 e4 ff ff       	call   67f0 <StrSize>
    FilePath = AllocateZeroPool (Size + SIZE_OF_FILEPATH_DEVICE_PATH + sizeof(EFI_DEVICE_PATH));
    832d:	48 8d 78 08          	lea    0x8(%rax),%rdi
    Size = StrSize(FileName);
    8331:	48 89 c3             	mov    %rax,%rbx
    FilePath = AllocateZeroPool (Size + SIZE_OF_FILEPATH_DEVICE_PATH + sizeof(EFI_DEVICE_PATH));
    8334:	e8 b7 b5 ff ff       	call   38f0 <AllocateZeroPool>
    8339:	49 89 c4             	mov    %rax,%r12
    if (FilePath) {
    833c:	48 85 c0             	test   %rax,%rax
    833f:	74 7e                	je     83bf <FileDevicePath+0xaf>
        FilePath->Header.Type = MEDIA_DEVICE_PATH;
    8341:	b8 04 04 00 00       	mov    $0x404,%eax
        CopyMem (FilePath->PathName, FileName, Size);
    8346:	49 8d 4c 24 04       	lea    0x4(%r12),%rcx
    834b:	49 89 d8             	mov    %rbx,%r8
    834e:	4c 89 ea             	mov    %r13,%rdx
        FilePath->Header.Type = MEDIA_DEVICE_PATH;
    8351:	66 41 89 04 24       	mov    %ax,(%r12)
        SetDevicePathNodeLength (&FilePath->Header, Size + SIZE_OF_FILEPATH_DEVICE_PATH);
    8356:	8d 43 04             	lea    0x4(%rbx),%eax
    8359:	41 88 44 24 02       	mov    %al,0x2(%r12)
    835e:	48 8d 43 04          	lea    0x4(%rbx),%rax
    8362:	0f b6 c4             	movzbl %ah,%eax
    8365:	41 88 44 24 03       	mov    %al,0x3(%r12)
        CopyMem (FilePath->PathName, FileName, Size);
    836a:	e8 41 b7 ff ff       	call   3ab0 <CopyMem>
        Eop = NextDevicePathNode(&FilePath->Header);
    836f:	41 0f b7 44 24 02    	movzwl 0x2(%r12),%eax
        SetDevicePathEndNode(Eop);
    8375:	41 c7 04 04 7f ff 04 	movl   $0x4ff7f,(%r12,%rax,1)
    837c:	00 
        if (Device) {
    837d:	4d 85 f6             	test   %r14,%r14
    8380:	74 3d                	je     83bf <FileDevicePath+0xaf>
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    8382:	48 8b 05 37 39 00 00 	mov    0x3937(%rip),%rax        # bcc0 <BS>
    8389:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    838e:	48 8d 15 fb 30 00 00 	lea    0x30fb(%rip),%rdx        # b490 <gEfiDevicePathProtocolGuid>
    8395:	4c 89 f1             	mov    %r14,%rcx
    8398:	ff 90 98 00 00 00    	call   *0x98(%rax)
    return DevicePath;
    839e:	31 ff                	xor    %edi,%edi
            DevicePath = AppendDevicePath (
    83a0:	4c 89 e6             	mov    %r12,%rsi
    return DevicePath;
    83a3:	48 85 c0             	test   %rax,%rax
    83a6:	48 0f 49 7c 24 28    	cmovns 0x28(%rsp),%rdi
            DevicePath = AppendDevicePath (
    83ac:	e8 5f fd ff ff       	call   8110 <AppendDevicePath>
            FreePool(FilePath);
    83b1:	4c 89 e7             	mov    %r12,%rdi
            DevicePath = AppendDevicePath (
    83b4:	48 89 c3             	mov    %rax,%rbx
            FreePool(FilePath);
    83b7:	e8 14 b6 ff ff       	call   39d0 <FreePool>
            DevicePath = AppendDevicePath (
    83bc:	49 89 dc             	mov    %rbx,%r12
}
    83bf:	48 83 c4 38          	add    $0x38,%rsp
    83c3:	4c 89 e0             	mov    %r12,%rax
    83c6:	5b                   	pop    %rbx
    83c7:	41 5c                	pop    %r12
    83c9:	41 5d                	pop    %r13
    83cb:	41 5e                	pop    %r14
    83cd:	c3                   	ret    
    83ce:	66 90                	xchg   %ax,%ax

00000000000083d0 <UnpackDevicePath>:
{
    83d0:	f3 0f 1e fa          	endbr64 
    83d4:	41 56                	push   %r14
    Src = DevPath;
    83d6:	48 89 f8             	mov    %rdi,%rax
{
    83d9:	41 55                	push   %r13
    83db:	41 54                	push   %r12
    83dd:	55                   	push   %rbp
    83de:	53                   	push   %rbx
    83df:	48 89 fb             	mov    %rdi,%rbx
    Size = 0;
    83e2:	31 ff                	xor    %edi,%edi
{
    83e4:	48 83 ec 20          	sub    $0x20,%rsp
    83e8:	eb 09                	jmp    83f3 <UnpackDevicePath+0x23>
    83ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        Src = NextDevicePathNode(Src);
    83f0:	48 01 f0             	add    %rsi,%rax
        Size += DevicePathNodeLength(Src);
    83f3:	0f b7 70 02          	movzwl 0x2(%rax),%esi
    83f7:	48 01 f7             	add    %rsi,%rdi
        Size += ALIGN_SIZE(Size);
    83fa:	48 89 f9             	mov    %rdi,%rcx
    83fd:	48 8d 57 04          	lea    0x4(%rdi),%rdx
    8401:	83 e1 03             	and    $0x3,%ecx
    8404:	48 29 ca             	sub    %rcx,%rdx
    8407:	48 85 c9             	test   %rcx,%rcx
    840a:	48 0f 45 fa          	cmovne %rdx,%rdi
        if (IsDevicePathEnd(Src)) {
    840e:	0f b6 10             	movzbl (%rax),%edx
    8411:	83 e2 7f             	and    $0x7f,%edx
    8414:	80 fa 7f             	cmp    $0x7f,%dl
    8417:	75 d7                	jne    83f0 <UnpackDevicePath+0x20>
    8419:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    841d:	75 d1                	jne    83f0 <UnpackDevicePath+0x20>
    NewPath = AllocateZeroPool (Size);
    841f:	e8 cc b4 ff ff       	call   38f0 <AllocateZeroPool>
    8424:	49 89 c5             	mov    %rax,%r13
    if (NewPath) {
    8427:	48 85 c0             	test   %rax,%rax
    842a:	74 5b                	je     8487 <UnpackDevicePath+0xb7>
    842c:	48 89 c5             	mov    %rax,%rbp
    842f:	eb 0e                	jmp    843f <UnpackDevicePath+0x6f>
    8431:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            Src = NextDevicePathNode(Src);
    8438:	0f b7 43 02          	movzwl 0x2(%rbx),%eax
    843c:	48 01 c3             	add    %rax,%rbx
            Size = DevicePathNodeLength(Src);
    843f:	44 0f b7 63 02       	movzwl 0x2(%rbx),%r12d
            CopyMem (Dest, Src, Size);
    8444:	48 89 da             	mov    %rbx,%rdx
    8447:	48 89 e9             	mov    %rbp,%rcx
    844a:	4d 89 e0             	mov    %r12,%r8
    844d:	4d 89 e6             	mov    %r12,%r14
    8450:	e8 5b b6 ff ff       	call   3ab0 <CopyMem>
            Size += ALIGN_SIZE(Size);
    8455:	44 89 e0             	mov    %r12d,%eax
    8458:	83 e0 03             	and    $0x3,%eax
    845b:	41 83 e6 03          	and    $0x3,%r14d
    845f:	74 0a                	je     846b <UnpackDevicePath+0x9b>
    8461:	49 83 c4 04          	add    $0x4,%r12
    8465:	0f b7 c0             	movzwl %ax,%eax
    8468:	49 29 c4             	sub    %rax,%r12
            Dest->Type |= EFI_DP_TYPE_UNPACKED;
    846b:	80 4d 00 80          	orb    $0x80,0x0(%rbp)
            SetDevicePathNodeLength (Dest, Size);
    846f:	66 44 89 65 02       	mov    %r12w,0x2(%rbp)
            if (IsDevicePathEnd(Src)) {
    8474:	0f b6 03             	movzbl (%rbx),%eax
            Dest = (EFI_DEVICE_PATH *) (((UINT8 *) Dest) + Size);
    8477:	4c 01 e5             	add    %r12,%rbp
            if (IsDevicePathEnd(Src)) {
    847a:	83 e0 7f             	and    $0x7f,%eax
    847d:	3c 7f                	cmp    $0x7f,%al
    847f:	75 b7                	jne    8438 <UnpackDevicePath+0x68>
    8481:	80 7b 01 ff          	cmpb   $0xff,0x1(%rbx)
    8485:	75 b1                	jne    8438 <UnpackDevicePath+0x68>
}
    8487:	48 83 c4 20          	add    $0x20,%rsp
    848b:	4c 89 e8             	mov    %r13,%rax
    848e:	5b                   	pop    %rbx
    848f:	5d                   	pop    %rbp
    8490:	41 5c                	pop    %r12
    8492:	41 5d                	pop    %r13
    8494:	41 5e                	pop    %r14
    8496:	c3                   	ret    
    8497:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    849e:	00 00 

00000000000084a0 <AppendDevicePathInstance>:
{
    84a0:	f3 0f 1e fa          	endbr64 
    84a4:	41 56                	push   %r14
    84a6:	48 89 f8             	mov    %rdi,%rax
    84a9:	41 55                	push   %r13
    84ab:	49 89 fd             	mov    %rdi,%r13
    84ae:	41 54                	push   %r12
    84b0:	49 89 f4             	mov    %rsi,%r12
    84b3:	55                   	push   %rbp
    84b4:	53                   	push   %rbx
    84b5:	48 83 ec 20          	sub    $0x20,%rsp
    if (Src == NULL) {
    84b9:	48 85 ff             	test   %rdi,%rdi
    84bc:	75 11                	jne    84cf <AppendDevicePathInstance+0x2f>
    84be:	e9 ab 00 00 00       	jmp    856e <AppendDevicePathInstance+0xce>
    84c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        DevPath = NextDevicePathNode(DevPath);
    84c8:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    84cc:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    84cf:	0f b6 10             	movzbl (%rax),%edx
    84d2:	83 e2 7f             	and    $0x7f,%edx
    84d5:	80 fa 7f             	cmp    $0x7f,%dl
    84d8:	75 ee                	jne    84c8 <AppendDevicePathInstance+0x28>
    84da:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    84de:	75 e8                	jne    84c8 <AppendDevicePathInstance+0x28>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    84e0:	4c 29 e8             	sub    %r13,%rax
    84e3:	48 8d 68 04          	lea    0x4(%rax),%rbp
    84e7:	4c 89 e0             	mov    %r12,%rax
    84ea:	eb 0b                	jmp    84f7 <AppendDevicePathInstance+0x57>
    84ec:	0f 1f 40 00          	nopl   0x0(%rax)
        DevPath = NextDevicePathNode(DevPath);
    84f0:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    84f4:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    84f7:	0f b6 10             	movzbl (%rax),%edx
    84fa:	83 e2 7f             	and    $0x7f,%edx
    84fd:	80 fa 7f             	cmp    $0x7f,%dl
    8500:	75 ee                	jne    84f0 <AppendDevicePathInstance+0x50>
    8502:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    8506:	75 e8                	jne    84f0 <AppendDevicePathInstance+0x50>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    8508:	4c 29 e0             	sub    %r12,%rax
    850b:	48 8d 58 04          	lea    0x4(%rax),%rbx
    Ptr = AllocatePool (SrcSize + InstanceSize);
    850f:	48 8d 3c 2b          	lea    (%rbx,%rbp,1),%rdi
    8513:	e8 98 b3 ff ff       	call   38b0 <AllocatePool>
    CopyMem (Ptr, Src, SrcSize);
    8518:	49 89 e8             	mov    %rbp,%r8
    851b:	4c 89 ea             	mov    %r13,%rdx
    Ptr = AllocatePool (SrcSize + InstanceSize);
    851e:	49 89 c6             	mov    %rax,%r14
    CopyMem (Ptr, Src, SrcSize);
    8521:	48 89 c1             	mov    %rax,%rcx
    8524:	e8 87 b5 ff ff       	call   3ab0 <CopyMem>
    DevPath = (EFI_DEVICE_PATH *)Ptr;
    8529:	4c 89 f1             	mov    %r14,%rcx
    while (!IsDevicePathEnd(DevPath)) {
    852c:	eb 09                	jmp    8537 <AppendDevicePathInstance+0x97>
    852e:	66 90                	xchg   %ax,%ax
        DevPath = NextDevicePathNode(DevPath);
    8530:	0f b7 51 02          	movzwl 0x2(%rcx),%edx
    8534:	48 01 d1             	add    %rdx,%rcx
    while (!IsDevicePathEnd(DevPath)) {
    8537:	0f b6 11             	movzbl (%rcx),%edx
    853a:	83 e2 7f             	and    $0x7f,%edx
    853d:	80 fa 7f             	cmp    $0x7f,%dl
    8540:	75 ee                	jne    8530 <AppendDevicePathInstance+0x90>
    8542:	80 79 01 ff          	cmpb   $0xff,0x1(%rcx)
    8546:	75 e8                	jne    8530 <AppendDevicePathInstance+0x90>
    DevPath = NextDevicePathNode(DevPath);
    8548:	0f b7 41 02          	movzwl 0x2(%rcx),%eax
    DevPath->SubType = END_INSTANCE_DEVICE_PATH_SUBTYPE;
    854c:	c6 41 01 01          	movb   $0x1,0x1(%rcx)
    CopyMem (DevPath, Instance, InstanceSize);
    8550:	49 89 d8             	mov    %rbx,%r8
    8553:	4c 89 e2             	mov    %r12,%rdx
    DevPath = NextDevicePathNode(DevPath);
    8556:	48 01 c1             	add    %rax,%rcx
    CopyMem (DevPath, Instance, InstanceSize);
    8559:	e8 52 b5 ff ff       	call   3ab0 <CopyMem>
}
    855e:	48 83 c4 20          	add    $0x20,%rsp
    8562:	4c 89 f0             	mov    %r14,%rax
    8565:	5b                   	pop    %rbx
    8566:	5d                   	pop    %rbp
    8567:	41 5c                	pop    %r12
    8569:	41 5d                	pop    %r13
    856b:	41 5e                	pop    %r14
    856d:	c3                   	ret    
    856e:	48 83 c4 20          	add    $0x20,%rsp
        return DuplicateDevicePath (Instance);
    8572:	48 89 f7             	mov    %rsi,%rdi
}
    8575:	5b                   	pop    %rbx
    8576:	5d                   	pop    %rbp
    8577:	41 5c                	pop    %r12
    8579:	41 5d                	pop    %r13
    857b:	41 5e                	pop    %r14
        return DuplicateDevicePath (Instance);
    857d:	e9 1e fb ff ff       	jmp    80a0 <DuplicateDevicePath>
    8582:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8589:	00 00 00 00 
    858d:	0f 1f 00             	nopl   (%rax)

0000000000008590 <LibDevicePathToInterface>:
{
    8590:	f3 0f 1e fa          	endbr64 
    8594:	41 54                	push   %r12
    Status = uefi_call_wrapper(BS->LocateDevicePath, 3, Protocol, &FilePath, &Device);
    8596:	48 89 f9             	mov    %rdi,%rcx
{
    8599:	49 89 fc             	mov    %rdi,%r12
    859c:	53                   	push   %rbx
    859d:	48 89 d3             	mov    %rdx,%rbx
    85a0:	48 83 ec 48          	sub    $0x48,%rsp
    Status = uefi_call_wrapper(BS->LocateDevicePath, 3, Protocol, &FilePath, &Device);
    85a4:	48 8b 05 15 37 00 00 	mov    0x3715(%rip),%rax        # bcc0 <BS>
{
    85ab:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    Status = uefi_call_wrapper(BS->LocateDevicePath, 3, Protocol, &FilePath, &Device);
    85b0:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
    85b5:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    85ba:	ff 90 b8 00 00 00    	call   *0xb8(%rax)
    if (!EFI_ERROR(Status)) {
    85c0:	48 85 c0             	test   %rax,%rax
    85c3:	78 1a                	js     85df <LibDevicePathToInterface+0x4f>
        if (IsDevicePathEnd(FilePath)) {
    85c5:	48 b8 0e 00 00 00 00 	movabs $0x800000000000000e,%rax
    85cc:	00 00 80 
    85cf:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    85d4:	0f b6 11             	movzbl (%rcx),%edx
    85d7:	83 e2 7f             	and    $0x7f,%edx
    85da:	80 fa 7f             	cmp    $0x7f,%dl
    85dd:	74 11                	je     85f0 <LibDevicePathToInterface+0x60>
        *Interface = NULL;
    85df:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
    85e6:	48 83 c4 48          	add    $0x48,%rsp
    85ea:	5b                   	pop    %rbx
    85eb:	41 5c                	pop    %r12
    85ed:	c3                   	ret    
    85ee:	66 90                	xchg   %ax,%ax
        if (IsDevicePathEnd(FilePath)) {
    85f0:	80 79 01 ff          	cmpb   $0xff,0x1(%rcx)
    85f4:	75 e9                	jne    85df <LibDevicePathToInterface+0x4f>
            Status =uefi_call_wrapper(BS->HandleProtocol, 3, Device, Protocol, Interface);
    85f6:	48 8b 05 c3 36 00 00 	mov    0x36c3(%rip),%rax        # bcc0 <BS>
    85fd:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    8602:	49 89 d8             	mov    %rbx,%r8
    8605:	4c 89 e2             	mov    %r12,%rdx
    8608:	ff 90 98 00 00 00    	call   *0x98(%rax)
    if (EFI_ERROR(Status)) {
    860e:	48 85 c0             	test   %rax,%rax
    8611:	78 cc                	js     85df <LibDevicePathToInterface+0x4f>
}
    8613:	48 83 c4 48          	add    $0x48,%rsp
    8617:	5b                   	pop    %rbx
    8618:	41 5c                	pop    %r12
    861a:	c3                   	ret    
    861b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000008620 <DevicePathToStr>:
    Turns the Device Path into a printable string.  Allcoates
    the string from pool.  The caller must FreePool the returned
    string.

--*/
{
    8620:	f3 0f 1e fa          	endbr64 
    8624:	41 57                	push   %r15
    POOL_PRINT          Str;
    EFI_DEVICE_PATH     *DevPathNode;
    VOID                (*DumpNode)(POOL_PRINT *, VOID *);
    UINTN               Index, NewSize;

    ZeroMem(&Str, sizeof(Str));
    8626:	be 18 00 00 00       	mov    $0x18,%esi
{
    862b:	41 56                	push   %r14
    862d:	41 55                	push   %r13
        //
        //  Put a path seperator in if needed
        //

        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
            CatPrint (&Str, L"/");
    862f:	4c 8d 2d 50 68 00 00 	lea    0x6850(%rip),%r13        # ee86 <_DYNAMIC+0x2e86>
{
    8636:	41 54                	push   %r12
            DumpNode = _DevPathNodeUnknown;
    8638:	4c 8d 25 51 f1 ff ff 	lea    -0xeaf(%rip),%r12        # 7790 <_DevPathNodeUnknown>
{
    863f:	55                   	push   %rbp
    8640:	48 89 fd             	mov    %rdi,%rbp
    8643:	53                   	push   %rbx
    8644:	48 83 ec 38          	sub    $0x38,%rsp
    ZeroMem(&Str, sizeof(Str));
    8648:	48 8d 5c 24 10       	lea    0x10(%rsp),%rbx
    864d:	48 89 df             	mov    %rbx,%rdi
    8650:	e8 9b b3 ff ff       	call   39f0 <ZeroMem>
    DevPath = UnpackDevicePath(DevPath);
    8655:	48 89 ef             	mov    %rbp,%rdi
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    8658:	48 8d 2d c1 ea ff ff 	lea    -0x153f(%rip),%rbp        # 7120 <_DevPathEndInstance>
    DevPath = UnpackDevicePath(DevPath);
    865f:	e8 6c fd ff ff       	call   83d0 <UnpackDevicePath>
    DevPathNode = DevPath;
    8664:	49 89 c6             	mov    %rax,%r14
    DevPath = UnpackDevicePath(DevPath);
    8667:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    while (!IsDevicePathEnd(DevPathNode)) {
    866c:	41 0f b6 16          	movzbl (%r14),%edx
    8670:	83 e2 7f             	and    $0x7f,%edx
    8673:	80 fa 7f             	cmp    $0x7f,%dl
    8676:	74 71                	je     86e9 <DevicePathToStr+0xc9>
    8678:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    867f:	00 
        for (Index = 0; DevPathTable[Index].Function; Index += 1) {
    8680:	4c 8b 3d 61 31 00 00 	mov    0x3161(%rip),%r15        # b7e8 <DevPathTable+0x8>
    8687:	48 8d 05 52 31 00 00 	lea    0x3152(%rip),%rax        # b7e0 <DevPathTable>
    868e:	4d 85 ff             	test   %r15,%r15
    8691:	75 1e                	jne    86b1 <DevicePathToStr+0x91>
    8693:	e9 a0 00 00 00       	jmp    8738 <DevicePathToStr+0x118>
    8698:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    869f:	00 
    86a0:	4c 8b 78 18          	mov    0x18(%rax),%r15
    86a4:	48 83 c0 10          	add    $0x10,%rax
    86a8:	4d 85 ff             	test   %r15,%r15
    86ab:	0f 84 87 00 00 00    	je     8738 <DevicePathToStr+0x118>
            if (DevicePathType(DevPathNode) == DevPathTable[Index].Type &&
    86b1:	38 10                	cmp    %dl,(%rax)
    86b3:	75 eb                	jne    86a0 <DevicePathToStr+0x80>
    86b5:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    86b9:	41 38 4e 01          	cmp    %cl,0x1(%r14)
    86bd:	75 e1                	jne    86a0 <DevicePathToStr+0x80>
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    86bf:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
    86c5:	74 05                	je     86cc <DevicePathToStr+0xac>
    86c7:	49 39 ef             	cmp    %rbp,%r15
    86ca:	75 77                	jne    8743 <DevicePathToStr+0x123>

        //
        // Print this node of the device path
        //

        DumpNode (&Str, DevPathNode);
    86cc:	4c 89 f6             	mov    %r14,%rsi
    86cf:	48 89 df             	mov    %rbx,%rdi
    86d2:	41 ff d7             	call   *%r15

        //
        // Next device path node
        //

        DevPathNode = NextDevicePathNode(DevPathNode);
    86d5:	41 0f b7 46 02       	movzwl 0x2(%r14),%eax
    86da:	49 01 c6             	add    %rax,%r14
    while (!IsDevicePathEnd(DevPathNode)) {
    86dd:	41 0f b6 16          	movzbl (%r14),%edx
    86e1:	83 e2 7f             	and    $0x7f,%edx
    86e4:	80 fa 7f             	cmp    $0x7f,%dl
    86e7:	75 97                	jne    8680 <DevicePathToStr+0x60>
    86e9:	41 80 7e 01 ff       	cmpb   $0xff,0x1(%r14)
    86ee:	75 90                	jne    8680 <DevicePathToStr+0x60>

    //
    // Shrink pool used for string allocation
    //

    FreePool (DevPath);
    86f0:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    86f5:	e8 d6 b2 ff ff       	call   39d0 <FreePool>
    NewSize = (Str.len + 1) * sizeof(CHAR16);
    86fa:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    86ff:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    NewSize = (Str.len + 1) * sizeof(CHAR16);
    8704:	48 8d 74 00 02       	lea    0x2(%rax,%rax,1),%rsi
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    8709:	48 89 f2             	mov    %rsi,%rdx
    870c:	e8 2f b2 ff ff       	call   3940 <ReallocatePool>
    Str.str[Str.len] = 0;
    8711:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    8716:	31 c9                	xor    %ecx,%ecx
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    8718:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    Str.str[Str.len] = 0;
    871d:	66 89 0c 50          	mov    %cx,(%rax,%rdx,2)
    return Str.str;
    8721:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
}
    8726:	48 83 c4 38          	add    $0x38,%rsp
    872a:	5b                   	pop    %rbx
    872b:	5d                   	pop    %rbp
    872c:	41 5c                	pop    %r12
    872e:	41 5d                	pop    %r13
    8730:	41 5e                	pop    %r14
    8732:	41 5f                	pop    %r15
    8734:	c3                   	ret    
    8735:	0f 1f 00             	nopl   (%rax)
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    8738:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
            DumpNode = _DevPathNodeUnknown;
    873e:	4d 89 e7             	mov    %r12,%r15
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    8741:	74 89                	je     86cc <DevicePathToStr+0xac>
            CatPrint (&Str, L"/");
    8743:	4c 89 ee             	mov    %r13,%rsi
    8746:	48 89 df             	mov    %rbx,%rdi
    8749:	31 c0                	xor    %eax,%eax
    874b:	e8 10 d4 ff ff       	call   5b60 <CatPrint>
    8750:	e9 77 ff ff ff       	jmp    86cc <DevicePathToStr+0xac>
    8755:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    875c:	00 00 00 00 

0000000000008760 <LibMatchDevicePaths>:
BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    )
{
    8760:	f3 0f 1e fa          	endbr64 
    EFI_DEVICE_PATH     *DevicePath, *DevicePathInst;
    UINTN               Size;

    if (!Multi || !Single) {
    8764:	48 85 ff             	test   %rdi,%rdi
    8767:	74 67                	je     87d0 <LibMatchDevicePaths+0x70>
{
    8769:	41 54                	push   %r12
    876b:	55                   	push   %rbp
    876c:	53                   	push   %rbx
    876d:	48 89 f3             	mov    %rsi,%rbx
    8770:	48 83 ec 10          	sub    $0x10,%rsp
    if (!Multi || !Single) {
    8774:	48 85 f6             	test   %rsi,%rsi
    8777:	74 3c                	je     87b5 <LibMatchDevicePaths+0x55>
        return FALSE;
    }

    DevicePath = Multi;
    8779:	48 89 3c 24          	mov    %rdi,(%rsp)
    while ((DevicePathInst = DevicePathInstance (&DevicePath, &Size))) {
    877d:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
    8782:	48 89 e5             	mov    %rsp,%rbp
    8785:	eb 1b                	jmp    87a2 <LibMatchDevicePaths+0x42>
    8787:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    878e:	00 00 
        if (CompareMem (Single, DevicePathInst, Size) == 0) {
    8790:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    8795:	48 89 df             	mov    %rbx,%rdi
    8798:	e8 c3 b3 ff ff       	call   3b60 <CompareMem>
    879d:	48 85 c0             	test   %rax,%rax
    87a0:	74 1e                	je     87c0 <LibMatchDevicePaths+0x60>
    while ((DevicePathInst = DevicePathInstance (&DevicePath, &Size))) {
    87a2:	4c 89 e6             	mov    %r12,%rsi
    87a5:	48 89 ef             	mov    %rbp,%rdi
    87a8:	e8 d3 f7 ff ff       	call   7f80 <DevicePathInstance>
    87ad:	48 89 c6             	mov    %rax,%rsi
    87b0:	48 85 c0             	test   %rax,%rax
    87b3:	75 db                	jne    8790 <LibMatchDevicePaths+0x30>
            return TRUE;
        }
    }
    return FALSE;
}
    87b5:	48 83 c4 10          	add    $0x10,%rsp
        return FALSE;
    87b9:	31 c0                	xor    %eax,%eax
}
    87bb:	5b                   	pop    %rbx
    87bc:	5d                   	pop    %rbp
    87bd:	41 5c                	pop    %r12
    87bf:	c3                   	ret    
    87c0:	48 83 c4 10          	add    $0x10,%rsp
            return TRUE;
    87c4:	b8 01 00 00 00       	mov    $0x1,%eax
}
    87c9:	5b                   	pop    %rbx
    87ca:	5d                   	pop    %rbp
    87cb:	41 5c                	pop    %r12
    87cd:	c3                   	ret    
    87ce:	66 90                	xchg   %ax,%ax
        return FALSE;
    87d0:	31 c0                	xor    %eax,%eax
}
    87d2:	c3                   	ret    
    87d3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    87da:	00 00 00 00 
    87de:	66 90                	xchg   %ax,%ax

00000000000087e0 <LibDuplicateDevicePathInstance>:

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    87e0:	f3 0f 1e fa          	endbr64 
    87e4:	41 55                	push   %r13
    87e6:	41 54                	push   %r12
    DevicePathInst = DevicePathInstance (&Temp, &Size);

    //
    // Make a copy and set proper end type
    //
    NewDevPath = NULL;
    87e8:	45 31 e4             	xor    %r12d,%r12d
{
    87eb:	48 83 ec 38          	sub    $0x38,%rsp
    Temp = DevPath;
    87ef:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
    DevicePathInst = DevicePathInstance (&Temp, &Size);
    87f4:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
    87f9:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    UINTN               Size = 0;
    87fe:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    8805:	00 00 
    DevicePathInst = DevicePathInstance (&Temp, &Size);
    8807:	e8 74 f7 ff ff       	call   7f80 <DevicePathInstance>
    if (Size) {
    880c:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    8811:	48 85 ff             	test   %rdi,%rdi
    8814:	74 50                	je     8866 <LibDuplicateDevicePathInstance+0x86>
        NewDevPath = AllocatePool (Size + sizeof(EFI_DEVICE_PATH));
    8816:	48 83 c7 04          	add    $0x4,%rdi
    881a:	49 89 c5             	mov    %rax,%r13
    881d:	e8 8e b0 ff ff       	call   38b0 <AllocatePool>
    8822:	49 89 c4             	mov    %rax,%r12
    }

    if (NewDevPath) {
    8825:	48 85 c0             	test   %rax,%rax
    8828:	74 3c                	je     8866 <LibDuplicateDevicePathInstance+0x86>
        CopyMem (NewDevPath, DevicePathInst, Size);
    882a:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
    882f:	48 89 c1             	mov    %rax,%rcx
    8832:	4c 89 ea             	mov    %r13,%rdx
    8835:	e8 76 b2 ff ff       	call   3ab0 <CopyMem>
        Temp = NextDevicePathNode(NewDevPath);
    883a:	41 0f b7 44 24 02    	movzwl 0x2(%r12),%eax
    8840:	4c 01 e0             	add    %r12,%rax
    8843:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
        SetDevicePathEndNode(Temp);
    8848:	c6 00 7f             	movb   $0x7f,(%rax)
    884b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    8850:	c6 40 01 ff          	movb   $0xff,0x1(%rax)
    8854:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    8859:	c6 40 02 04          	movb   $0x4,0x2(%rax)
    885d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    8862:	c6 40 03 00          	movb   $0x0,0x3(%rax)
    }

    return NewDevPath;
}
    8866:	48 83 c4 38          	add    $0x38,%rsp
    886a:	4c 89 e0             	mov    %r12,%rax
    886d:	41 5c                	pop    %r12
    886f:	41 5d                	pop    %r13
    8871:	c3                   	ret    
    8872:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    8879:	00 00 00 
    887c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000008880 <InitializeGuid>:

VOID
InitializeGuid (
    VOID
    )
{
    8880:	f3 0f 1e fa          	endbr64 
}
    8884:	c3                   	ret    
    8885:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    888c:	00 00 00 00 

0000000000008890 <CompareGuid>:

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    8890:	f3 0f 1e fa          	endbr64 
    return RtCompareGuid (Guid1, Guid2);
    8894:	e9 77 e4 ff ff       	jmp    6d10 <RtCompareGuid>
    8899:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000088a0 <GuidToString>:
VOID
GuidToString (
    OUT CHAR16      *Buffer,
    IN EFI_GUID     *Guid
    )
{
    88a0:	f3 0f 1e fa          	endbr64 
    88a4:	41 55                	push   %r13
    88a6:	49 89 f5             	mov    %rsi,%r13

    //
    // Else, (for now) use additional internal function for mapping guids
    //

    for (Index=0; KnownGuids[Index].Guid; Index++) {
    88a9:	48 8d 35 00 34 00 00 	lea    0x3400(%rip),%rsi        # bcb0 <NullGuid>
{
    88b0:	41 54                	push   %r12
    88b2:	49 89 fc             	mov    %rdi,%r12
    88b5:	55                   	push   %rbp
    for (Index=0; KnownGuids[Index].Guid; Index++) {
    88b6:	31 ed                	xor    %ebp,%ebp
{
    88b8:	53                   	push   %rbx
    88b9:	48 8d 1d 50 31 00 00 	lea    0x3150(%rip),%rbx        # ba10 <KnownGuids+0x10>
    88c0:	48 83 ec 48          	sub    $0x48,%rsp
    88c4:	eb 1a                	jmp    88e0 <GuidToString+0x40>
    88c6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    88cd:	00 00 00 
    for (Index=0; KnownGuids[Index].Guid; Index++) {
    88d0:	48 8b 33             	mov    (%rbx),%rsi
    88d3:	48 83 c3 10          	add    $0x10,%rbx
    88d7:	48 83 c5 01          	add    $0x1,%rbp
    88db:	48 85 f6             	test   %rsi,%rsi
    88de:	74 38                	je     8918 <GuidToString+0x78>
    return RtCompareGuid (Guid1, Guid2);
    88e0:	4c 89 ef             	mov    %r13,%rdi
    88e3:	e8 28 e4 ff ff       	call   6d10 <RtCompareGuid>
        if (CompareGuid(Guid, KnownGuids[Index].Guid) == 0) {
    88e8:	48 85 c0             	test   %rax,%rax
    88eb:	75 e3                	jne    88d0 <GuidToString+0x30>
            UnicodeSPrint (Buffer, 0, KnownGuids[Index].GuidName);
    88ed:	48 c1 e5 04          	shl    $0x4,%rbp
    88f1:	48 8d 05 08 31 00 00 	lea    0x3108(%rip),%rax        # ba00 <KnownGuids>
    88f8:	4c 89 e7             	mov    %r12,%rdi
    88fb:	31 f6                	xor    %esi,%esi
    88fd:	48 8b 54 28 08       	mov    0x8(%rax,%rbp,1),%rdx
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]
        );
}
    8902:	48 83 c4 48          	add    $0x48,%rsp
            UnicodeSPrint (Buffer, 0, KnownGuids[Index].GuidName);
    8906:	31 c0                	xor    %eax,%eax
}
    8908:	5b                   	pop    %rbx
    8909:	5d                   	pop    %rbp
    890a:	41 5c                	pop    %r12
    890c:	41 5d                	pop    %r13
            UnicodeSPrint (Buffer, 0, KnownGuids[Index].GuidName);
    890e:	e9 cd d3 ff ff       	jmp    5ce0 <UnicodeSPrint>
    8913:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    UnicodeSPrint (Buffer, 0, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    8918:	41 0f b6 45 0f       	movzbl 0xf(%r13),%eax
    891d:	45 0f b7 4d 06       	movzwl 0x6(%r13),%r9d
    8922:	4c 89 e7             	mov    %r12,%rdi
    8925:	48 8d 15 64 65 00 00 	lea    0x6564(%rip),%rdx        # ee90 <CSWTCH.43+0x6>
    892c:	45 0f b7 45 04       	movzwl 0x4(%r13),%r8d
    8931:	41 8b 4d 00          	mov    0x0(%r13),%ecx
    8935:	89 44 24 38          	mov    %eax,0x38(%rsp)
    8939:	41 0f b6 45 0e       	movzbl 0xe(%r13),%eax
    893e:	89 44 24 30          	mov    %eax,0x30(%rsp)
    8942:	41 0f b6 45 0d       	movzbl 0xd(%r13),%eax
    8947:	89 44 24 28          	mov    %eax,0x28(%rsp)
    894b:	41 0f b6 45 0c       	movzbl 0xc(%r13),%eax
    8950:	89 44 24 20          	mov    %eax,0x20(%rsp)
    8954:	41 0f b6 45 0b       	movzbl 0xb(%r13),%eax
    8959:	89 44 24 18          	mov    %eax,0x18(%rsp)
    895d:	41 0f b6 45 0a       	movzbl 0xa(%r13),%eax
    8962:	89 44 24 10          	mov    %eax,0x10(%rsp)
    8966:	41 0f b6 45 09       	movzbl 0x9(%r13),%eax
    896b:	89 44 24 08          	mov    %eax,0x8(%rsp)
    896f:	41 0f b6 45 08       	movzbl 0x8(%r13),%eax
    8974:	89 04 24             	mov    %eax,(%rsp)
    8977:	31 c0                	xor    %eax,%eax
    8979:	e8 62 d3 ff ff       	call   5ce0 <UnicodeSPrint>
}
    897e:	48 83 c4 48          	add    $0x48,%rsp
    8982:	5b                   	pop    %rbx
    8983:	5d                   	pop    %rbp
    8984:	41 5c                	pop    %r12
    8986:	41 5d                	pop    %r13
    8988:	c3                   	ret    
    8989:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000008990 <LibLocateHandle>:
    IN VOID                         *SearchKey OPTIONAL,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    )

{
    8990:	f3 0f 1e fa          	endbr64 
    8994:	41 57                	push   %r15
    8996:	41 56                	push   %r14
    8998:	41 55                	push   %r13
    899a:	41 89 fd             	mov    %edi,%r13d
    899d:	41 54                	push   %r12
    899f:	49 89 f4             	mov    %rsi,%r12
    89a2:	55                   	push   %rbp
    89a3:	48 89 d5             	mov    %rdx,%rbp

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    89a6:	ba 90 01 00 00       	mov    $0x190,%edx
{
    89ab:	53                   	push   %rbx
    89ac:	4c 89 c3             	mov    %r8,%rbx
    89af:	48 83 ec 58          	sub    $0x58,%rsp
    *Buffer = NULL;
    89b3:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
{
    89ba:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    89bf:	4c 8d 74 24 40       	lea    0x40(%rsp),%r14

        Status = uefi_call_wrapper(
    89c4:	4c 8d 7c 24 48       	lea    0x48(%rsp),%r15
    Status = EFI_SUCCESS;
    89c9:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    89d0:	00 00 
    BufferSize = 50 * sizeof(EFI_HANDLE);
    89d2:	48 c7 44 24 48 90 01 	movq   $0x190,0x48(%rsp)
    89d9:	00 00 
    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    89db:	eb 2e                	jmp    8a0b <LibLocateHandle+0x7b>
    89dd:	0f 1f 00             	nopl   (%rax)
        Status = uefi_call_wrapper(
    89e0:	48 8b 03             	mov    (%rbx),%rax
    89e3:	4c 89 e2             	mov    %r12,%rdx
    89e6:	4d 89 f9             	mov    %r15,%r9
    89e9:	49 89 e8             	mov    %rbp,%r8
    89ec:	44 89 e9             	mov    %r13d,%ecx
    89ef:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    89f4:	48 8b 05 c5 32 00 00 	mov    0x32c5(%rip),%rax        # bcc0 <BS>
    89fb:	ff 90 b0 00 00 00    	call   *0xb0(%rax)
    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    8a01:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
        Status = uefi_call_wrapper(
    8a06:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    8a0b:	48 89 de             	mov    %rbx,%rsi
    8a0e:	4c 89 f7             	mov    %r14,%rdi
    8a11:	e8 5a b1 ff ff       	call   3b70 <GrowBuffer>
    8a16:	84 c0                	test   %al,%al
    8a18:	75 c6                	jne    89e0 <LibLocateHandle+0x50>
                        );

    }

    *NoHandles = BufferSize / sizeof (EFI_HANDLE);
    if (EFI_ERROR(Status)) {
    8a1a:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
    *NoHandles = BufferSize / sizeof (EFI_HANDLE);
    8a1f:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    8a24:	31 d2                	xor    %edx,%edx
    8a26:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    8a2b:	48 c1 e8 03          	shr    $0x3,%rax
    8a2f:	4d 85 c0             	test   %r8,%r8
    8a32:	48 0f 48 c2          	cmovs  %rdx,%rax
    8a36:	48 89 01             	mov    %rax,(%rcx)
        *NoHandles = 0;
    }

    return Status;
}
    8a39:	48 83 c4 58          	add    $0x58,%rsp
    8a3d:	4c 89 c0             	mov    %r8,%rax
    8a40:	5b                   	pop    %rbx
    8a41:	5d                   	pop    %rbp
    8a42:	41 5c                	pop    %r12
    8a44:	41 5d                	pop    %r13
    8a46:	41 5e                	pop    %r14
    8a48:	41 5f                	pop    %r15
    8a4a:	c3                   	ret    
    8a4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000008a50 <LibLocateProtocol>:
{
    8a50:	f3 0f 1e fa          	endbr64 
    8a54:	41 55                	push   %r13
    Status = LibLocateHandle (ByProtocol, ProtocolGuid, NULL, &NumberHandles, &Handles);
    8a56:	31 d2                	xor    %edx,%edx
{
    8a58:	41 54                	push   %r12
    8a5a:	49 89 f4             	mov    %rsi,%r12
    8a5d:	55                   	push   %rbp
    8a5e:	48 89 fd             	mov    %rdi,%rbp
    8a61:	53                   	push   %rbx
    8a62:	48 83 ec 48          	sub    $0x48,%rsp
    *Interface = NULL;
    8a66:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
    Status = LibLocateHandle (ByProtocol, ProtocolGuid, NULL, &NumberHandles, &Handles);
    8a6d:	48 89 fe             	mov    %rdi,%rsi
    8a70:	bf 02 00 00 00       	mov    $0x2,%edi
    8a75:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
    8a7a:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    8a7f:	e8 0c ff ff ff       	call   8990 <LibLocateHandle>
    if (EFI_ERROR(Status)) {
    8a84:	48 85 c0             	test   %rax,%rax
    8a87:	78 5a                	js     8ae3 <LibLocateProtocol+0x93>
    for (Index=0; Index < NumberHandles; Index++) {
    8a89:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13
    8a8e:	4d 85 ed             	test   %r13,%r13
    8a91:	74 37                	je     8aca <LibLocateProtocol+0x7a>
    8a93:	31 db                	xor    %ebx,%ebx
    8a95:	eb 12                	jmp    8aa9 <LibLocateProtocol+0x59>
    8a97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    8a9e:	00 00 
    8aa0:	48 83 c3 01          	add    $0x1,%rbx
    8aa4:	4c 39 eb             	cmp    %r13,%rbx
    8aa7:	74 21                	je     8aca <LibLocateProtocol+0x7a>
        Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handles[Index], ProtocolGuid, Interface);
    8aa9:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    8aae:	4d 89 e0             	mov    %r12,%r8
    8ab1:	48 89 ea             	mov    %rbp,%rdx
    8ab4:	48 8b 0c d8          	mov    (%rax,%rbx,8),%rcx
    8ab8:	48 8b 05 01 32 00 00 	mov    0x3201(%rip),%rax        # bcc0 <BS>
    8abf:	ff 90 98 00 00 00    	call   *0x98(%rax)
        if (!EFI_ERROR(Status)) {
    8ac5:	48 85 c0             	test   %rax,%rax
    8ac8:	78 d6                	js     8aa0 <LibLocateProtocol+0x50>
    if (Handles) {
    8aca:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    8acf:	48 85 ff             	test   %rdi,%rdi
    8ad2:	74 0f                	je     8ae3 <LibLocateProtocol+0x93>
    8ad4:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
        FreePool (Handles);
    8ad9:	e8 f2 ae ff ff       	call   39d0 <FreePool>
    8ade:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
}
    8ae3:	48 83 c4 48          	add    $0x48,%rsp
    8ae7:	5b                   	pop    %rbx
    8ae8:	5d                   	pop    %rbp
    8ae9:	41 5c                	pop    %r12
    8aeb:	41 5d                	pop    %r13
    8aed:	c3                   	ret    
    8aee:	66 90                	xchg   %ax,%ax

0000000000008af0 <LibLocateHandleByDiskSignature>:
    IN VOID                         *Signature,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    )

{
    8af0:	f3 0f 1e fa          	endbr64 
    8af4:	41 57                	push   %r15

        //
        // Get list of device handles that support the BLOCK_IO Protocol.
        //

        Status = uefi_call_wrapper(
    8af6:	4c 8d 3d 23 29 00 00 	lea    0x2923(%rip),%r15        # b420 <gEfiBlockIoProtocolGuid>
{
    8afd:	41 56                	push   %r14
    8aff:	41 55                	push   %r13
    8b01:	41 54                	push   %r12
    8b03:	55                   	push   %rbp
    8b04:	53                   	push   %rbx
    8b05:	48 89 cb             	mov    %rcx,%rbx
    8b08:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    8b0f:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
    8b14:	4c 8d 64 24 70       	lea    0x70(%rsp),%r12
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    8b19:	ba 90 01 00 00       	mov    $0x190,%edx
    8b1e:	48 8d 6c 24 60       	lea    0x60(%rsp),%rbp
{
    8b23:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
    8b28:	40 88 7c 24 40       	mov    %dil,0x40(%rsp)
    8b2d:	40 88 74 24 5d       	mov    %sil,0x5d(%rsp)
    Status = EFI_SUCCESS;
    8b32:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
    8b39:	00 00 
    BlockIoBuffer = NULL;
    8b3b:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
    8b42:	00 00 
    BufferSize = 50 * sizeof(EFI_HANDLE);
    8b44:	48 c7 44 24 68 90 01 	movq   $0x190,0x68(%rsp)
    8b4b:	00 00 
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    8b4d:	eb 32                	jmp    8b81 <LibLocateHandleByDiskSignature+0x91>
    8b4f:	90                   	nop
        Status = uefi_call_wrapper(
    8b50:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
    8b55:	4c 89 fa             	mov    %r15,%rdx
    8b58:	4c 8d 4c 24 68       	lea    0x68(%rsp),%r9
    8b5d:	45 31 c0             	xor    %r8d,%r8d
    8b60:	b9 02 00 00 00       	mov    $0x2,%ecx
    8b65:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    8b6a:	48 8b 05 4f 31 00 00 	mov    0x314f(%rip),%rax        # bcc0 <BS>
    8b71:	ff 90 b0 00 00 00    	call   *0xb0(%rax)
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    8b77:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
        Status = uefi_call_wrapper(
    8b7c:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    8b81:	4c 89 e6             	mov    %r12,%rsi
    8b84:	48 89 ef             	mov    %rbp,%rdi
    8b87:	e8 e4 af ff ff       	call   3b70 <GrowBuffer>
    8b8c:	84 c0                	test   %al,%al
    8b8e:	75 c0                	jne    8b50 <LibLocateHandleByDiskSignature+0x60>
                        );

    }

    NoBlockIoHandles = BufferSize / sizeof (EFI_HANDLE);
    if (EFI_ERROR(Status)) {
    8b90:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    //
    // If there was an error or there are no device handles that support 
    // the BLOCK_IO Protocol, then return.
    //

    if (NoBlockIoHandles == 0) {
    8b95:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
        Status = uefi_call_wrapper(
    8b9a:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    if (EFI_ERROR(Status)) {
    8b9f:	48 c1 e8 3f          	shr    $0x3f,%rax
    if (NoBlockIoHandles == 0) {
    8ba3:	48 c1 ed 03          	shr    $0x3,%rbp
    8ba7:	0f 94 c2             	sete   %dl
    8baa:	08 c2                	or     %al,%dl
    8bac:	0f 85 ec 01 00 00    	jne    8d9e <LibLocateHandleByDiskSignature+0x2ae>

    //
    // Loop through all the device handles that support the BLOCK_IO Protocol
    //

    *NoHandles = 0;
    8bb2:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)

    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8bb9:	45 31 ed             	xor    %r13d,%r13d
    8bbc:	4c 8d 74 24 78       	lea    0x78(%rsp),%r14
    8bc1:	4c 8d 3d c8 28 00 00 	lea    0x28c8(%rip),%r15        # b490 <gEfiDevicePathProtocolGuid>
    8bc8:	eb 25                	jmp    8bef <LibLocateHandleByDiskSignature+0xff>
    8bca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            }

        }

        if (Match == FALSE) {
            BlockIoBuffer[Index] = NULL;
    8bd0:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8bd5:	49 83 c5 01          	add    $0x1,%r13
            BlockIoBuffer[Index] = NULL;
    8bd9:	4a c7 04 20 00 00 00 	movq   $0x0,(%rax,%r12,1)
    8be0:	00 
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8be1:	4c 39 ed             	cmp    %r13,%rbp
    8be4:	0f 86 38 01 00 00    	jbe    8d22 <LibLocateHandleByDiskSignature+0x232>
    8bea:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
        Status = uefi_call_wrapper(
    8bef:	48 8b 05 ca 30 00 00 	mov    0x30ca(%rip),%rax        # bcc0 <BS>
    8bf6:	4c 89 fa             	mov    %r15,%rdx
    8bf9:	4a 8b 0c ef          	mov    (%rdi,%r13,8),%rcx
    8bfd:	4d 89 f0             	mov    %r14,%r8
    8c00:	4e 8d 24 ed 00 00 00 	lea    0x0(,%r13,8),%r12
    8c07:	00 
    8c08:	ff 90 98 00 00 00    	call   *0x98(%rax)
        if (DevicePath != NULL) {
    8c0e:	48 8b 54 24 78       	mov    0x78(%rsp),%rdx
        Status = uefi_call_wrapper(
    8c13:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
        if (DevicePath != NULL) {
    8c18:	48 85 d2             	test   %rdx,%rdx
    8c1b:	74 b3                	je     8bd0 <LibLocateHandleByDiskSignature+0xe0>
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c1d:	0f b6 02             	movzbl (%rdx),%eax
            PreviousNodeIsHardDriveDevicePath = FALSE;
    8c20:	31 c9                	xor    %ecx,%ecx
        Match = FALSE;
    8c22:	45 31 c0             	xor    %r8d,%r8d
    8c25:	0f 1f 00             	nopl   (%rax)
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c28:	83 e0 7f             	and    $0x7f,%eax
    8c2b:	3c 04                	cmp    $0x4,%al
    8c2d:	74 17                	je     8c46 <LibLocateHandleByDiskSignature+0x156>
                    PreviousNodeIsHardDriveDevicePath = FALSE;
    8c2f:	31 c9                	xor    %ecx,%ecx
                if (IsDevicePathEnd(DevPath)) {
    8c31:	3c 7f                	cmp    $0x7f,%al
    8c33:	74 2b                	je     8c60 <LibLocateHandleByDiskSignature+0x170>
    8c35:	0f b7 72 02          	movzwl 0x2(%rdx),%esi
                DevPath = NextDevicePathNode(DevPath);
    8c39:	48 01 f2             	add    %rsi,%rdx
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c3c:	0f b6 02             	movzbl (%rdx),%eax
    8c3f:	83 e0 7f             	and    $0x7f,%eax
    8c42:	3c 04                	cmp    $0x4,%al
    8c44:	75 e9                	jne    8c2f <LibLocateHandleByDiskSignature+0x13f>
                        Next = NextDevicePathNode(DevPath);
    8c46:	0f b7 72 02          	movzwl 0x2(%rdx),%esi
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c4a:	80 7a 01 01          	cmpb   $0x1,0x1(%rdx)
                        Next = NextDevicePathNode(DevPath);
    8c4e:	48 8d 3c 32          	lea    (%rdx,%rsi,1),%rdi
                        if (IsDevicePathEndType(Next)) {
    8c52:	0f b6 07             	movzbl (%rdi),%eax
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c55:	74 29                	je     8c80 <LibLocateHandleByDiskSignature+0x190>
                    PreviousNodeIsHardDriveDevicePath = FALSE;
    8c57:	31 c9                	xor    %ecx,%ecx
                                    switch(SignatureType) {
    8c59:	48 89 fa             	mov    %rdi,%rdx
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c5c:	eb ca                	jmp    8c28 <LibLocateHandleByDiskSignature+0x138>
    8c5e:	66 90                	xchg   %ax,%ax
                if (IsDevicePathEnd(DevPath)) {
    8c60:	80 7a 01 ff          	cmpb   $0xff,0x1(%rdx)
    8c64:	0f 84 9e 00 00 00    	je     8d08 <LibLocateHandleByDiskSignature+0x218>
                DevPath = NextDevicePathNode(DevPath);
    8c6a:	0f b7 42 02          	movzwl 0x2(%rdx),%eax
    8c6e:	48 01 c2             	add    %rax,%rdx
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    8c71:	0f b6 02             	movzbl (%rdx),%eax
    8c74:	eb b2                	jmp    8c28 <LibLocateHandleByDiskSignature+0x138>
    8c76:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    8c7d:	00 00 00 
                    if (PreviousNodeIsHardDriveDevicePath == FALSE) {
    8c80:	84 c9                	test   %cl,%cl
    8c82:	75 d5                	jne    8c59 <LibLocateHandleByDiskSignature+0x169>
                        if (IsDevicePathEndType(Next)) {
    8c84:	41 89 c1             	mov    %eax,%r9d
                    PreviousNodeIsHardDriveDevicePath = TRUE;
    8c87:	b9 01 00 00 00       	mov    $0x1,%ecx
                        if (IsDevicePathEndType(Next)) {
    8c8c:	41 83 e1 7f          	and    $0x7f,%r9d
    8c90:	41 80 f9 7f          	cmp    $0x7f,%r9b
    8c94:	75 c3                	jne    8c59 <LibLocateHandleByDiskSignature+0x169>
                            if ((HardDriveDevicePath->MBRType == MBRType) &&
    8c96:	44 0f b6 54 24 40    	movzbl 0x40(%rsp),%r10d
    8c9c:	44 38 52 28          	cmp    %r10b,0x28(%rdx)
    8ca0:	75 b7                	jne    8c59 <LibLocateHandleByDiskSignature+0x169>
    8ca2:	44 0f b6 5c 24 5d    	movzbl 0x5d(%rsp),%r11d
    8ca8:	44 38 5a 29          	cmp    %r11b,0x29(%rdx)
    8cac:	75 ab                	jne    8c59 <LibLocateHandleByDiskSignature+0x169>
                                    switch(SignatureType) {
    8cae:	41 80 fb 01          	cmp    $0x1,%r11b
    8cb2:	0f 84 3c 01 00 00    	je     8df4 <LibLocateHandleByDiskSignature+0x304>
    8cb8:	41 80 fb 02          	cmp    $0x2,%r11b
    8cbc:	0f 85 77 ff ff ff    	jne    8c39 <LibLocateHandleByDiskSignature+0x149>
                                            if (CompareGuid((EFI_GUID *)Signature,(EFI_GUID *)(&(HardDriveDevicePath->Signature[0]))) == 0) {
    8cc2:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    8cc7:	48 8d 72 18          	lea    0x18(%rdx),%rsi
    8ccb:	88 4c 24 5f          	mov    %cl,0x5f(%rsp)
    8ccf:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    8cd4:	44 88 44 24 5e       	mov    %r8b,0x5e(%rsp)
    8cd9:	e8 b2 fb ff ff       	call   8890 <CompareGuid>
    8cde:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    8ce3:	0f b6 4c 24 5f       	movzbl 0x5f(%rsp),%ecx
    8ce8:	48 85 c0             	test   %rax,%rax
    8ceb:	0f b6 02             	movzbl (%rdx),%eax
    8cee:	0f 85 f2 00 00 00    	jne    8de6 <LibLocateHandleByDiskSignature+0x2f6>
                                                Match = TRUE;
    8cf4:	83 e0 7f             	and    $0x7f,%eax
    8cf7:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    8cfd:	e9 2f ff ff ff       	jmp    8c31 <LibLocateHandleByDiskSignature+0x141>
    8d02:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if (Match == FALSE) {
    8d08:	45 84 c0             	test   %r8b,%r8b
    8d0b:	0f 84 bf fe ff ff    	je     8bd0 <LibLocateHandleByDiskSignature+0xe0>
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8d11:	49 83 c5 01          	add    $0x1,%r13
        } else {
            *NoHandles = *NoHandles + 1;
    8d15:	48 83 03 01          	addq   $0x1,(%rbx)
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8d19:	4c 39 ed             	cmp    %r13,%rbp
    8d1c:	0f 87 c8 fe ff ff    	ja     8bea <LibLocateHandleByDiskSignature+0xfa>

    //
    // If there are no matches, then return
    //

    if (*NoHandles == 0) {
    8d22:	48 8b 03             	mov    (%rbx),%rax
    8d25:	48 85 c0             	test   %rax,%rax
    8d28:	0f 84 8f 00 00 00    	je     8dbd <LibLocateHandleByDiskSignature+0x2cd>

    //
    // Allocate space for the return buffer of device handles.
    //

    *Buffer = AllocatePool(*NoHandles * sizeof(EFI_HANDLE));
    8d2e:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    8d35:	00 
    8d36:	e8 75 ab ff ff       	call   38b0 <AllocatePool>
    8d3b:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    8d40:	48 89 07             	mov    %rax,(%rdi)

    if (*Buffer == NULL) {
    8d43:	48 85 c0             	test   %rax,%rax
    8d46:	0f 84 c0 00 00 00    	je     8e0c <LibLocateHandleByDiskSignature+0x31c>

    //
    // Build list of matching device handles.
    //

    *NoHandles = 0;
    8d4c:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        FreePool(BlockIoBuffer);
    8d53:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8d58:	31 c0                	xor    %eax,%eax
    8d5a:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
    8d5f:	90                   	nop
        if (BlockIoBuffer[Index] != NULL) {
    8d60:	48 8b 14 c7          	mov    (%rdi,%rax,8),%rdx
    8d64:	48 85 d2             	test   %rdx,%rdx
    8d67:	74 13                	je     8d7c <LibLocateHandleByDiskSignature+0x28c>
            (*Buffer)[*NoHandles] = BlockIoBuffer[Index];
    8d69:	48 8b 33             	mov    (%rbx),%rsi
    8d6c:	49 8b 08             	mov    (%r8),%rcx
    8d6f:	48 89 14 f1          	mov    %rdx,(%rcx,%rsi,8)
            *NoHandles = *NoHandles + 1;
        }
    }

    FreePool(BlockIoBuffer);
    8d73:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
            *NoHandles = *NoHandles + 1;
    8d78:	48 83 03 01          	addq   $0x1,(%rbx)
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    8d7c:	48 83 c0 01          	add    $0x1,%rax
    8d80:	48 39 c5             	cmp    %rax,%rbp
    8d83:	77 db                	ja     8d60 <LibLocateHandleByDiskSignature+0x270>
    FreePool(BlockIoBuffer);
    8d85:	e8 46 ac ff ff       	call   39d0 <FreePool>

    return EFI_SUCCESS;
    8d8a:	31 c0                	xor    %eax,%eax
}
    8d8c:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    8d93:	5b                   	pop    %rbx
    8d94:	5d                   	pop    %rbp
    8d95:	41 5c                	pop    %r12
    8d97:	41 5d                	pop    %r13
    8d99:	41 5e                	pop    %r14
    8d9b:	41 5f                	pop    %r15
    8d9d:	c3                   	ret    
        FreePool(BlockIoBuffer);
    8d9e:	e8 2d ac ff ff       	call   39d0 <FreePool>
        *Buffer = NULL;
    8da3:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        *NoHandles = 0;
    8da8:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *Buffer = NULL;
    8daf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return Status;
    8db6:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    8dbb:	eb cf                	jmp    8d8c <LibLocateHandleByDiskSignature+0x29c>
        FreePool(BlockIoBuffer);
    8dbd:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    8dc2:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    8dc7:	e8 04 ac ff ff       	call   39d0 <FreePool>
        *Buffer = NULL;
    8dcc:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        *NoHandles = 0;
    8dd1:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *Buffer = NULL;
    8dd8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return EFI_SUCCESS;
    8ddf:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    8de4:	eb a6                	jmp    8d8c <LibLocateHandleByDiskSignature+0x29c>
    8de6:	44 0f b6 44 24 5e    	movzbl 0x5e(%rsp),%r8d
    8dec:	83 e0 7f             	and    $0x7f,%eax
    8def:	e9 3d fe ff ff       	jmp    8c31 <LibLocateHandleByDiskSignature+0x141>
                    PreviousNodeIsHardDriveDevicePath = TRUE;
    8df4:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    8df9:	8b 52 18             	mov    0x18(%rdx),%edx
    8dfc:	39 16                	cmp    %edx,(%rsi)
    8dfe:	0f b6 74 24 5d       	movzbl 0x5d(%rsp),%esi
    8e03:	44 0f 44 c6          	cmove  %esi,%r8d
    8e07:	e9 4d fe ff ff       	jmp    8c59 <LibLocateHandleByDiskSignature+0x169>
        FreePool(BlockIoBuffer);
    8e0c:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    8e11:	e8 ba ab ff ff       	call   39d0 <FreePool>
        *Buffer = NULL;
    8e16:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        *NoHandles = 0;
    8e1b:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *Buffer = NULL;
    8e22:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return EFI_OUT_OF_RESOURCES;
    8e29:	48 b8 09 00 00 00 00 	movabs $0x8000000000000009,%rax
    8e30:	00 00 80 
    8e33:	e9 54 ff ff ff       	jmp    8d8c <LibLocateHandleByDiskSignature+0x29c>
    8e38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    8e3f:	00 

0000000000008e40 <LibOpenRoot>:

EFI_FILE_HANDLE
LibOpenRoot (
    IN EFI_HANDLE               DeviceHandle
    )
{
    8e40:	f3 0f 1e fa          	endbr64 
    8e44:	48 83 ec 38          	sub    $0x38,%rsp

    //
    // File the file system interface to the device
    //

    Status = uefi_call_wrapper(BS->HandleProtocol, 3, DeviceHandle, &FileSystemProtocol, (VOID*)&Volume);
    8e48:	48 8b 05 71 2e 00 00 	mov    0x2e71(%rip),%rax        # bcc0 <BS>
{
    8e4f:	48 89 f9             	mov    %rdi,%rcx
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, DeviceHandle, &FileSystemProtocol, (VOID*)&Volume);
    8e52:	48 8d 15 87 25 00 00 	lea    0x2587(%rip),%rdx        # b3e0 <gEfiSimpleFileSystemProtocolGuid>
    8e59:	4c 8d 44 24 20       	lea    0x20(%rsp),%r8
    8e5e:	ff 90 98 00 00 00    	call   *0x98(%rax)

    //
    // Open the root directory of the volume 
    //

    if (!EFI_ERROR(Status)) {
    8e64:	48 85 c0             	test   %rax,%rax
    8e67:	78 27                	js     8e90 <LibOpenRoot+0x50>
        Status = uefi_call_wrapper(Volume->OpenVolume, 2, Volume, &File);
    8e69:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    8e6e:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
    8e73:	48 89 c1             	mov    %rax,%rcx
    8e76:	ff 50 08             	call   *0x8(%rax)

    //
    // Done
    //

    return EFI_ERROR(Status) ? NULL : File;
    8e79:	48 85 c0             	test   %rax,%rax
    8e7c:	78 12                	js     8e90 <LibOpenRoot+0x50>
    8e7e:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
}
    8e83:	48 83 c4 38          	add    $0x38,%rsp
    8e87:	c3                   	ret    
    8e88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    8e8f:	00 
    return EFI_ERROR(Status) ? NULL : File;
    8e90:	31 c0                	xor    %eax,%eax
}
    8e92:	48 83 c4 38          	add    $0x38,%rsp
    8e96:	c3                   	ret    
    8e97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    8e9e:	00 00 

0000000000008ea0 <LibFileInfo>:

EFI_FILE_INFO *
LibFileInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    8ea0:	f3 0f 1e fa          	endbr64 
    8ea4:	41 55                	push   %r13

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8ea6:	ba 18 01 00 00       	mov    $0x118,%edx
        Status = uefi_call_wrapper(
    8eab:	4c 8d 2d ee 23 00 00 	lea    0x23ee(%rip),%r13        # b2a0 <gEfiFileInfoGuid>
{
    8eb2:	41 54                	push   %r12
    8eb4:	55                   	push   %rbp
    8eb5:	53                   	push   %rbx
    8eb6:	48 89 fb             	mov    %rdi,%rbx
    8eb9:	48 83 ec 48          	sub    $0x48,%rsp
    Status = EFI_SUCCESS;
    8ebd:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    8ec4:	00 00 
    Buffer = NULL;
    8ec6:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    8ecb:	48 8d 6c 24 28       	lea    0x28(%rsp),%rbp
    8ed0:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    8ed7:	00 00 
    BufferSize = SIZE_OF_EFI_FILE_INFO + 200;
    8ed9:	48 c7 44 24 38 18 01 	movq   $0x118,0x38(%rsp)
    8ee0:	00 00 
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8ee2:	eb 21                	jmp    8f05 <LibFileInfo+0x65>
    8ee4:	0f 1f 40 00          	nopl   0x0(%rax)
        Status = uefi_call_wrapper(
    8ee8:	4c 89 ea             	mov    %r13,%rdx
    8eeb:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    8ef0:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    8ef5:	48 89 d9             	mov    %rbx,%rcx
    8ef8:	ff 53 40             	call   *0x40(%rbx)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8efb:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
        Status = uefi_call_wrapper(
    8f00:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8f05:	4c 89 e6             	mov    %r12,%rsi
    8f08:	48 89 ef             	mov    %rbp,%rdi
    8f0b:	e8 60 ac ff ff       	call   3b70 <GrowBuffer>
    8f10:	84 c0                	test   %al,%al
    8f12:	75 d4                	jne    8ee8 <LibFileInfo+0x48>
                    Buffer
                    );
    }

    return Buffer;
}
    8f14:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    8f19:	48 83 c4 48          	add    $0x48,%rsp
    8f1d:	5b                   	pop    %rbx
    8f1e:	5d                   	pop    %rbp
    8f1f:	41 5c                	pop    %r12
    8f21:	41 5d                	pop    %r13
    8f23:	c3                   	ret    
    8f24:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8f2b:	00 00 00 00 
    8f2f:	90                   	nop

0000000000008f30 <LibFileSystemInfo>:
    
EFI_FILE_SYSTEM_INFO *
LibFileSystemInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    8f30:	f3 0f 1e fa          	endbr64 
    8f34:	41 55                	push   %r13

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8f36:	ba ec 00 00 00       	mov    $0xec,%edx
        Status = uefi_call_wrapper(
    8f3b:	4c 8d 2d 4e 23 00 00 	lea    0x234e(%rip),%r13        # b290 <gEfiFileSystemInfoGuid>
{
    8f42:	41 54                	push   %r12
    8f44:	55                   	push   %rbp
    8f45:	53                   	push   %rbx
    8f46:	48 89 fb             	mov    %rdi,%rbx
    8f49:	48 83 ec 48          	sub    $0x48,%rsp
    Status = EFI_SUCCESS;
    8f4d:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    8f54:	00 00 
    Buffer = NULL;
    8f56:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    8f5b:	48 8d 6c 24 28       	lea    0x28(%rsp),%rbp
    8f60:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    8f67:	00 00 
    BufferSize = SIZE_OF_EFI_FILE_SYSTEM_INFO + 200;
    8f69:	48 c7 44 24 38 ec 00 	movq   $0xec,0x38(%rsp)
    8f70:	00 00 
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8f72:	eb 21                	jmp    8f95 <LibFileSystemInfo+0x65>
    8f74:	0f 1f 40 00          	nopl   0x0(%rax)
        Status = uefi_call_wrapper(
    8f78:	4c 89 ea             	mov    %r13,%rdx
    8f7b:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    8f80:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    8f85:	48 89 d9             	mov    %rbx,%rcx
    8f88:	ff 53 40             	call   *0x40(%rbx)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8f8b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
        Status = uefi_call_wrapper(
    8f90:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8f95:	4c 89 e6             	mov    %r12,%rsi
    8f98:	48 89 ef             	mov    %rbp,%rdi
    8f9b:	e8 d0 ab ff ff       	call   3b70 <GrowBuffer>
    8fa0:	84 c0                	test   %al,%al
    8fa2:	75 d4                	jne    8f78 <LibFileSystemInfo+0x48>
                    Buffer
                    );
    }

    return Buffer;
}
    8fa4:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    8fa9:	48 83 c4 48          	add    $0x48,%rsp
    8fad:	5b                   	pop    %rbx
    8fae:	5d                   	pop    %rbp
    8faf:	41 5c                	pop    %r12
    8fb1:	41 5d                	pop    %r13
    8fb3:	c3                   	ret    
    8fb4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8fbb:	00 00 00 00 
    8fbf:	90                   	nop

0000000000008fc0 <LibFileSystemVolumeLabelInfo>:

EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
LibFileSystemVolumeLabelInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    8fc0:	f3 0f 1e fa          	endbr64 
    8fc4:	41 55                	push   %r13

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    8fc6:	ba c8 00 00 00       	mov    $0xc8,%edx
        Status = uefi_call_wrapper(
    8fcb:	4c 8d 2d ae 22 00 00 	lea    0x22ae(%rip),%r13        # b280 <gEfiFileSystemVolumeLabelInfoIdGuid>
{
    8fd2:	41 54                	push   %r12
    8fd4:	55                   	push   %rbp
    8fd5:	53                   	push   %rbx
    8fd6:	48 89 fb             	mov    %rdi,%rbx
    8fd9:	48 83 ec 48          	sub    $0x48,%rsp
    Status = EFI_SUCCESS;
    8fdd:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    8fe4:	00 00 
    Buffer = NULL;
    8fe6:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    8feb:	48 8d 6c 24 28       	lea    0x28(%rsp),%rbp
    8ff0:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    8ff7:	00 00 
    BufferSize = SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO + 200;
    8ff9:	48 c7 44 24 38 c8 00 	movq   $0xc8,0x38(%rsp)
    9000:	00 00 
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    9002:	eb 21                	jmp    9025 <LibFileSystemVolumeLabelInfo+0x65>
    9004:	0f 1f 40 00          	nopl   0x0(%rax)
        Status = uefi_call_wrapper(
    9008:	4c 89 ea             	mov    %r13,%rdx
    900b:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    9010:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    9015:	48 89 d9             	mov    %rbx,%rcx
    9018:	ff 53 40             	call   *0x40(%rbx)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    901b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
        Status = uefi_call_wrapper(
    9020:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    9025:	4c 89 e6             	mov    %r12,%rsi
    9028:	48 89 ef             	mov    %rbp,%rdi
    902b:	e8 40 ab ff ff       	call   3b70 <GrowBuffer>
    9030:	84 c0                	test   %al,%al
    9032:	75 d4                	jne    9008 <LibFileSystemVolumeLabelInfo+0x48>
                    Buffer
                    );
    }

    return Buffer;
}
    9034:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    9039:	48 83 c4 48          	add    $0x48,%rsp
    903d:	5b                   	pop    %rbx
    903e:	5d                   	pop    %rbp
    903f:	41 5c                	pop    %r12
    9041:	41 5d                	pop    %r13
    9043:	c3                   	ret    
    9044:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    904b:	00 00 00 00 
    904f:	90                   	nop

0000000000009050 <LibInstallProtocolInterfaces>:
EFI_STATUS
LibInstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    )
{
    9050:	f3 0f 1e fa          	endbr64 
    9054:	41 56                	push   %r14
    //
    // Install the protocol interfaces
    //

    Index = 0;
    Status = EFI_SUCCESS;
    9056:	45 31 f6             	xor    %r14d,%r14d
{
    9059:	41 55                	push   %r13
    905b:	41 54                	push   %r12
    905d:	55                   	push   %rbp
    905e:	48 89 fd             	mov    %rdi,%rbp
    9061:	53                   	push   %rbx
    Index = 0;
    9062:	31 db                	xor    %ebx,%ebx
{
    9064:	48 83 ec 70          	sub    $0x70,%rsp
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    9068:	48 8b 05 51 2c 00 00 	mov    0x2c51(%rip),%rax        # bcc0 <BS>
{
    906f:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    9074:	b9 10 00 00 00       	mov    $0x10,%ecx
{
    9079:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    907e:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    9083:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    9088:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    908d:	ff 50 18             	call   *0x18(%rax)
    va_start (args, Handle);
    9090:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    9097:	00 
    OldHandle = *Handle;
    9098:	4c 8b 6d 00          	mov    0x0(%rbp),%r13
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    909c:	49 89 c4             	mov    %rax,%r12
    va_start (args, Handle);
    909f:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    90a6:	00 
    90a7:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    90ac:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    90b1:	48 89 44 24 38       	mov    %rax,0x38(%rsp)

    while (!EFI_ERROR(Status)) {
    90b6:	eb 57                	jmp    910f <LibInstallProtocolInterfaces+0xbf>
    90b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    90bf:	00 

        //
        // If protocol is NULL, then it's the end of the list
        //

        Protocol = va_arg(args, EFI_GUID *);
    90c0:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    90c5:	89 d1                	mov    %edx,%ecx
    90c7:	8d 42 08             	lea    0x8(%rdx),%eax
    90ca:	89 44 24 28          	mov    %eax,0x28(%rsp)
    90ce:	4c 8b 14 0e          	mov    (%rsi,%rcx,1),%r10
        if (!Protocol) {
    90d2:	4d 85 d2             	test   %r10,%r10
    90d5:	74 6d                	je     9144 <LibInstallProtocolInterfaces+0xf4>
            break;
        }

        Interface = va_arg(args, VOID *);
    90d7:	83 f8 2f             	cmp    $0x2f,%eax
    90da:	0f 87 19 01 00 00    	ja     91f9 <LibInstallProtocolInterfaces+0x1a9>
    90e0:	83 c2 10             	add    $0x10,%edx
    90e3:	48 01 f0             	add    %rsi,%rax
    90e6:	89 54 24 28          	mov    %edx,0x28(%rsp)
        //
        // Install it
        //

        DEBUG((D_INFO, "LibInstallProtocolInterface: %d %x\n", Protocol, Interface));
        Status = uefi_call_wrapper(BS->InstallProtocolInterface, 4, Handle, Protocol, EFI_NATIVE_INTERFACE, Interface);
    90ea:	4c 8b 08             	mov    (%rax),%r9
    90ed:	48 8b 05 cc 2b 00 00 	mov    0x2bcc(%rip),%rax        # bcc0 <BS>
    90f4:	45 31 c0             	xor    %r8d,%r8d
    90f7:	4c 89 d2             	mov    %r10,%rdx
    90fa:	48 89 e9             	mov    %rbp,%rcx
    90fd:	ff 90 80 00 00 00    	call   *0x80(%rax)
    9103:	49 89 c6             	mov    %rax,%r14
        if (EFI_ERROR(Status)) {
    9106:	48 85 c0             	test   %rax,%rax
    9109:	78 5d                	js     9168 <LibInstallProtocolInterfaces+0x118>
            break;
        }

        Index += 1;
    910b:	48 83 c3 01          	add    $0x1,%rbx
        Protocol = va_arg(args, EFI_GUID *);
    910f:	8b 54 24 28          	mov    0x28(%rsp),%edx
    9113:	83 fa 2f             	cmp    $0x2f,%edx
    9116:	76 a8                	jbe    90c0 <LibInstallProtocolInterfaces+0x70>
    9118:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    911d:	48 89 c2             	mov    %rax,%rdx
    9120:	48 83 c0 08          	add    $0x8,%rax
    9124:	4c 8b 12             	mov    (%rdx),%r10
    9127:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
        if (!Protocol) {
    912c:	4d 85 d2             	test   %r10,%r10
    912f:	74 13                	je     9144 <LibInstallProtocolInterfaces+0xf4>
        Interface = va_arg(args, VOID *);
    9131:	48 8d 50 08          	lea    0x8(%rax),%rdx
    9135:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    913a:	eb ae                	jmp    90ea <LibInstallProtocolInterfaces+0x9a>
    913c:	0f 1f 40 00          	nopl   0x0(%rax)
            uefi_call_wrapper(BS->UninstallProtocolInterface, 3, *Handle, Protocol, Interface);

            Index -= 1;
        }        

        *Handle = OldHandle;
    9140:	4c 89 6d 00          	mov    %r13,0x0(%rbp)

    //
    // Done
    //

    uefi_call_wrapper(BS->RestoreTPL, 1, OldTpl);
    9144:	48 8b 05 75 2b 00 00 	mov    0x2b75(%rip),%rax        # bcc0 <BS>
    914b:	4c 89 e1             	mov    %r12,%rcx
    914e:	ff 50 20             	call   *0x20(%rax)
    return Status;
}
    9151:	48 83 c4 70          	add    $0x70,%rsp
    9155:	4c 89 f0             	mov    %r14,%rax
    9158:	5b                   	pop    %rbx
    9159:	5d                   	pop    %rbp
    915a:	41 5c                	pop    %r12
    915c:	41 5d                	pop    %r13
    915e:	41 5e                	pop    %r14
    9160:	c3                   	ret    
    9161:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        va_start (args, Handle);
    9168:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    916f:	00 
    9170:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    9177:	00 
    9178:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    917d:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    9182:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        while (Index) {
    9187:	48 85 db             	test   %rbx,%rbx
    918a:	75 46                	jne    91d2 <LibInstallProtocolInterfaces+0x182>
    918c:	eb b2                	jmp    9140 <LibInstallProtocolInterfaces+0xf0>
    918e:	66 90                	xchg   %ax,%ax
            Protocol = va_arg(args, EFI_GUID *);
    9190:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    9195:	8d 48 08             	lea    0x8(%rax),%ecx
    9198:	89 c6                	mov    %eax,%esi
    919a:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
    919e:	4c 8b 0c 32          	mov    (%rdx,%rsi,1),%r9
            Interface = va_arg(args, VOID *);
    91a2:	83 f9 2f             	cmp    $0x2f,%ecx
    91a5:	77 4b                	ja     91f2 <LibInstallProtocolInterfaces+0x1a2>
    91a7:	83 c0 10             	add    $0x10,%eax
    91aa:	48 01 ca             	add    %rcx,%rdx
    91ad:	89 44 24 28          	mov    %eax,0x28(%rsp)
            uefi_call_wrapper(BS->UninstallProtocolInterface, 3, *Handle, Protocol, Interface);
    91b1:	48 8b 05 08 2b 00 00 	mov    0x2b08(%rip),%rax        # bcc0 <BS>
    91b8:	4c 8b 02             	mov    (%rdx),%r8
    91bb:	4c 89 ca             	mov    %r9,%rdx
    91be:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
    91c2:	ff 90 90 00 00 00    	call   *0x90(%rax)
        while (Index) {
    91c8:	48 83 eb 01          	sub    $0x1,%rbx
    91cc:	0f 84 6e ff ff ff    	je     9140 <LibInstallProtocolInterfaces+0xf0>
            Protocol = va_arg(args, EFI_GUID *);
    91d2:	8b 44 24 28          	mov    0x28(%rsp),%eax
    91d6:	83 f8 2f             	cmp    $0x2f,%eax
    91d9:	76 b5                	jbe    9190 <LibInstallProtocolInterfaces+0x140>
    91db:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    91e0:	4c 8b 08             	mov    (%rax),%r9
    91e3:	48 8d 50 08          	lea    0x8(%rax),%rdx
            Interface = va_arg(args, VOID *);
    91e7:	48 8d 42 08          	lea    0x8(%rdx),%rax
    91eb:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    91f0:	eb bf                	jmp    91b1 <LibInstallProtocolInterfaces+0x161>
            Protocol = va_arg(args, EFI_GUID *);
    91f2:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    91f7:	eb ee                	jmp    91e7 <LibInstallProtocolInterfaces+0x197>
    91f9:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    91fe:	e9 2e ff ff ff       	jmp    9131 <LibInstallProtocolInterfaces+0xe1>
    9203:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    920a:	00 00 00 00 
    920e:	66 90                	xchg   %ax,%ax

0000000000009210 <LibUninstallProtocolInterfaces>:
VOID
LibUninstallProtocolInterfaces (
    IN EFI_HANDLE           Handle,
    ...
    )
{
    9210:	f3 0f 1e fa          	endbr64 
    9214:	53                   	push   %rbx
    9215:	48 89 fb             	mov    %rdi,%rbx
    9218:	48 83 ec 70          	sub    $0x70,%rsp
    EFI_STATUS      Status;
    EFI_GUID        *Protocol;
    VOID            *Interface;

    
    va_start (args, Handle);
    921c:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
    9223:	00 
{
    9224:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    va_start (args, Handle);
    9229:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    922e:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
{
    9233:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    9238:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    923d:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    9242:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    va_start (args, Handle);
    9247:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    924e:	00 
    924f:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    9254:	eb 46                	jmp    929c <LibUninstallProtocolInterfaces+0x8c>
    9256:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    925d:	00 00 00 

        //
        // If protocol is NULL, then it's the end of the list
        //

        Protocol = va_arg(args, EFI_GUID *);
    9260:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    9265:	89 c6                	mov    %eax,%esi
    9267:	8d 48 08             	lea    0x8(%rax),%ecx
    926a:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
    926e:	4c 8b 0c 32          	mov    (%rdx,%rsi,1),%r9
        if (!Protocol) {
    9272:	4d 85 c9             	test   %r9,%r9
    9275:	74 59                	je     92d0 <LibUninstallProtocolInterfaces+0xc0>
            break;
        }

        Interface = va_arg(args, VOID *);
    9277:	83 f9 2f             	cmp    $0x2f,%ecx
    927a:	77 5a                	ja     92d6 <LibUninstallProtocolInterfaces+0xc6>
    927c:	83 c0 10             	add    $0x10,%eax
    927f:	48 01 ca             	add    %rcx,%rdx
    9282:	89 44 24 28          	mov    %eax,0x28(%rsp)

        //
        // Uninstall it
        //

        Status = uefi_call_wrapper(BS->UninstallProtocolInterface, 3, Handle, Protocol, Interface);
    9286:	48 8b 05 33 2a 00 00 	mov    0x2a33(%rip),%rax        # bcc0 <BS>
    928d:	4c 8b 02             	mov    (%rdx),%r8
    9290:	48 89 d9             	mov    %rbx,%rcx
    9293:	4c 89 ca             	mov    %r9,%rdx
    9296:	ff 90 90 00 00 00    	call   *0x90(%rax)
        Protocol = va_arg(args, EFI_GUID *);
    929c:	8b 44 24 28          	mov    0x28(%rsp),%eax
    92a0:	83 f8 2f             	cmp    $0x2f,%eax
    92a3:	76 bb                	jbe    9260 <LibUninstallProtocolInterfaces+0x50>
    92a5:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    92aa:	4c 8b 08             	mov    (%rax),%r9
    92ad:	48 8d 50 08          	lea    0x8(%rax),%rdx
    92b1:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
        if (!Protocol) {
    92b6:	4d 85 c9             	test   %r9,%r9
    92b9:	74 15                	je     92d0 <LibUninstallProtocolInterfaces+0xc0>
        Interface = va_arg(args, VOID *);
    92bb:	48 8d 42 08          	lea    0x8(%rdx),%rax
    92bf:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    92c4:	eb c0                	jmp    9286 <LibUninstallProtocolInterfaces+0x76>
    92c6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    92cd:	00 00 00 
        if (EFI_ERROR(Status)) {
            DEBUG((D_ERROR, "LibUninstallProtocolInterfaces: failed %g, %r\n", Protocol, Handle));
        }
    }
    va_end (args);
}    
    92d0:	48 83 c4 70          	add    $0x70,%rsp
    92d4:	5b                   	pop    %rbx
    92d5:	c3                   	ret    
        Protocol = va_arg(args, EFI_GUID *);
    92d6:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    92db:	eb de                	jmp    92bb <LibUninstallProtocolInterfaces+0xab>
    92dd:	0f 1f 00             	nopl   (%rax)

00000000000092e0 <LibReinstallProtocolInterfaces>:
EFI_STATUS
LibReinstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    )
{
    92e0:	f3 0f 1e fa          	endbr64 
    92e4:	41 55                	push   %r13
    //
    // Install the protocol interfaces
    //

    Index = 0;
    Status = EFI_SUCCESS;
    92e6:	45 31 ed             	xor    %r13d,%r13d
{
    92e9:	41 54                	push   %r12
    92eb:	55                   	push   %rbp
    92ec:	48 89 fd             	mov    %rdi,%rbp
    92ef:	53                   	push   %rbx
    Index = 0;
    92f0:	31 db                	xor    %ebx,%ebx
{
    92f2:	48 83 ec 78          	sub    $0x78,%rsp
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    92f6:	48 8b 05 c3 29 00 00 	mov    0x29c3(%rip),%rax        # bcc0 <BS>
{
    92fd:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    9302:	b9 10 00 00 00       	mov    $0x10,%ecx
{
    9307:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    930c:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    9311:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    9316:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    931b:	ff 50 18             	call   *0x18(%rax)
    va_start (args, Handle);
    931e:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    9325:	00 
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    9326:	49 89 c4             	mov    %rax,%r12
    va_start (args, Handle);
    9329:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    9330:	00 
    9331:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    9336:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    933b:	48 89 44 24 38       	mov    %rax,0x38(%rsp)

    while (!EFI_ERROR(Status)) {
    9340:	eb 6a                	jmp    93ac <LibReinstallProtocolInterfaces+0xcc>
    9342:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

        //
        // If protocol is NULL, then it's the end of the list
        //

        Protocol = va_arg(args, EFI_GUID *);
    9348:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    934d:	89 c6                	mov    %eax,%esi
    934f:	8d 48 08             	lea    0x8(%rax),%ecx
    9352:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
    9356:	4c 8b 14 32          	mov    (%rdx,%rsi,1),%r10
        if (!Protocol) {
    935a:	4d 85 d2             	test   %r10,%r10
    935d:	0f 84 7d 00 00 00    	je     93e0 <LibReinstallProtocolInterfaces+0x100>
            break;
        }

        OldInterface = va_arg(args, VOID *);
    9363:	83 f9 2f             	cmp    $0x2f,%ecx
    9366:	0f 87 54 01 00 00    	ja     94c0 <LibReinstallProtocolInterfaces+0x1e0>
    936c:	8d 70 10             	lea    0x10(%rax),%esi
    936f:	4c 8b 04 0a          	mov    (%rdx,%rcx,1),%r8
    9373:	89 74 24 28          	mov    %esi,0x28(%rsp)
        NewInterface = va_arg(args, VOID *);
    9377:	83 fe 2f             	cmp    $0x2f,%esi
    937a:	0f 87 36 01 00 00    	ja     94b6 <LibReinstallProtocolInterfaces+0x1d6>
    9380:	83 c0 18             	add    $0x18,%eax
    9383:	48 01 f2             	add    %rsi,%rdx
    9386:	89 44 24 28          	mov    %eax,0x28(%rsp)

        //
        // Reinstall it
        //

        Status = uefi_call_wrapper(BS->ReinstallProtocolInterface, 4, Handle, Protocol, OldInterface, NewInterface);
    938a:	48 8b 05 2f 29 00 00 	mov    0x292f(%rip),%rax        # bcc0 <BS>
    9391:	4c 8b 0a             	mov    (%rdx),%r9
    9394:	48 89 e9             	mov    %rbp,%rcx
    9397:	4c 89 d2             	mov    %r10,%rdx
    939a:	ff 90 88 00 00 00    	call   *0x88(%rax)
    93a0:	49 89 c5             	mov    %rax,%r13
        if (EFI_ERROR(Status)) {
    93a3:	48 85 c0             	test   %rax,%rax
    93a6:	78 58                	js     9400 <LibReinstallProtocolInterfaces+0x120>
            break;
        }

        Index += 1;
    93a8:	48 83 c3 01          	add    $0x1,%rbx
        Protocol = va_arg(args, EFI_GUID *);
    93ac:	8b 44 24 28          	mov    0x28(%rsp),%eax
    93b0:	83 f8 2f             	cmp    $0x2f,%eax
    93b3:	76 93                	jbe    9348 <LibReinstallProtocolInterfaces+0x68>
    93b5:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    93ba:	48 89 c2             	mov    %rax,%rdx
    93bd:	48 83 c0 08          	add    $0x8,%rax
    93c1:	4c 8b 12             	mov    (%rdx),%r10
    93c4:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
        if (!Protocol) {
    93c9:	4d 85 d2             	test   %r10,%r10
    93cc:	74 12                	je     93e0 <LibReinstallProtocolInterfaces+0x100>
        OldInterface = va_arg(args, VOID *);
    93ce:	4c 8b 00             	mov    (%rax),%r8
    93d1:	48 8d 50 08          	lea    0x8(%rax),%rdx
        NewInterface = va_arg(args, VOID *);
    93d5:	48 8d 42 08          	lea    0x8(%rdx),%rax
    93d9:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    93de:	eb aa                	jmp    938a <LibReinstallProtocolInterfaces+0xaa>

    //
    // Done
    //

    uefi_call_wrapper(BS->RestoreTPL, 1, OldTpl);
    93e0:	48 8b 05 d9 28 00 00 	mov    0x28d9(%rip),%rax        # bcc0 <BS>
    93e7:	4c 89 e1             	mov    %r12,%rcx
    93ea:	ff 50 20             	call   *0x20(%rax)
    return Status;
}
    93ed:	48 83 c4 78          	add    $0x78,%rsp
    93f1:	4c 89 e8             	mov    %r13,%rax
    93f4:	5b                   	pop    %rbx
    93f5:	5d                   	pop    %rbp
    93f6:	41 5c                	pop    %r12
    93f8:	41 5d                	pop    %r13
    93fa:	c3                   	ret    
    93fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        va_start (args, Handle);
    9400:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    9407:	00 
    9408:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    940f:	00 
    9410:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    9415:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    941a:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        while (Index) {
    941f:	48 85 db             	test   %rbx,%rbx
    9422:	75 5d                	jne    9481 <LibReinstallProtocolInterfaces+0x1a1>
    9424:	eb ba                	jmp    93e0 <LibReinstallProtocolInterfaces+0x100>
    9426:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    942d:	00 00 00 
            Protocol = va_arg(args, EFI_GUID *);
    9430:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    9435:	8d 70 08             	lea    0x8(%rax),%esi
    9438:	89 c1                	mov    %eax,%ecx
    943a:	89 74 24 28          	mov    %esi,0x28(%rsp)
    943e:	4c 8b 14 0a          	mov    (%rdx,%rcx,1),%r10
            OldInterface = va_arg(args, VOID *);
    9442:	83 fe 2f             	cmp    $0x2f,%esi
    9445:	77 61                	ja     94a8 <LibReinstallProtocolInterfaces+0x1c8>
    9447:	8d 48 10             	lea    0x10(%rax),%ecx
    944a:	4c 8b 0c 32          	mov    (%rdx,%rsi,1),%r9
    944e:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
            NewInterface = va_arg(args, VOID *);
    9452:	83 f9 2f             	cmp    $0x2f,%ecx
    9455:	77 58                	ja     94af <LibReinstallProtocolInterfaces+0x1cf>
    9457:	83 c0 18             	add    $0x18,%eax
    945a:	48 01 ca             	add    %rcx,%rdx
    945d:	89 44 24 28          	mov    %eax,0x28(%rsp)
            uefi_call_wrapper(BS->ReinstallProtocolInterface, 4, Handle, Protocol, NewInterface, OldInterface);
    9461:	48 8b 05 58 28 00 00 	mov    0x2858(%rip),%rax        # bcc0 <BS>
    9468:	4c 8b 02             	mov    (%rdx),%r8
    946b:	48 89 e9             	mov    %rbp,%rcx
    946e:	4c 89 d2             	mov    %r10,%rdx
    9471:	ff 90 88 00 00 00    	call   *0x88(%rax)
        while (Index) {
    9477:	48 83 eb 01          	sub    $0x1,%rbx
    947b:	0f 84 5f ff ff ff    	je     93e0 <LibReinstallProtocolInterfaces+0x100>
            Protocol = va_arg(args, EFI_GUID *);
    9481:	8b 44 24 28          	mov    0x28(%rsp),%eax
    9485:	83 f8 2f             	cmp    $0x2f,%eax
    9488:	76 a6                	jbe    9430 <LibReinstallProtocolInterfaces+0x150>
    948a:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    948f:	4c 8b 12             	mov    (%rdx),%r10
    9492:	48 8d 42 08          	lea    0x8(%rdx),%rax
            OldInterface = va_arg(args, VOID *);
    9496:	4c 8b 08             	mov    (%rax),%r9
    9499:	48 8d 50 08          	lea    0x8(%rax),%rdx
            NewInterface = va_arg(args, VOID *);
    949d:	48 8d 42 08          	lea    0x8(%rdx),%rax
    94a1:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    94a6:	eb b9                	jmp    9461 <LibReinstallProtocolInterfaces+0x181>
            Protocol = va_arg(args, EFI_GUID *);
    94a8:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    94ad:	eb e7                	jmp    9496 <LibReinstallProtocolInterfaces+0x1b6>
    94af:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    94b4:	eb e7                	jmp    949d <LibReinstallProtocolInterfaces+0x1bd>
        OldInterface = va_arg(args, VOID *);
    94b6:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    94bb:	e9 15 ff ff ff       	jmp    93d5 <LibReinstallProtocolInterfaces+0xf5>
    94c0:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    94c5:	e9 04 ff ff ff       	jmp    93ce <LibReinstallProtocolInterfaces+0xee>
    94ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000094d0 <_relocate>:
#include <elf.h>

EFI_STATUS _relocate (long ldbase, Elf64_Dyn *dyn,
		      EFI_HANDLE image EFI_UNUSED,
		      EFI_SYSTEM_TABLE *systab EFI_UNUSED)
{
    94d0:	f3 0f 1e fa          	endbr64 
	long relsz = 0, relent = 0;
	Elf64_Rel *rel = 0;
	unsigned long *addr;
	int i;

	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
    94d4:	48 8b 06             	mov    (%rsi),%rax
    94d7:	48 85 c0             	test   %rax,%rax
    94da:	74 7e                	je     955a <_relocate+0x8a>
    94dc:	48 83 c6 08          	add    $0x8,%rsi
	Elf64_Rel *rel = 0;
    94e0:	31 d2                	xor    %edx,%edx
	long relsz = 0, relent = 0;
    94e2:	45 31 c0             	xor    %r8d,%r8d
    94e5:	31 c9                	xor    %ecx,%ecx
    94e7:	eb 1a                	jmp    9503 <_relocate+0x33>
    94e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		switch (dyn[i].d_tag) {
    94f0:	48 83 f8 07          	cmp    $0x7,%rax
    94f4:	74 72                	je     9568 <_relocate+0x98>
	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
    94f6:	48 8b 46 08          	mov    0x8(%rsi),%rax
    94fa:	48 83 c6 10          	add    $0x10,%rsi
    94fe:	48 85 c0             	test   %rax,%rax
    9501:	74 1c                	je     951f <_relocate+0x4f>
		switch (dyn[i].d_tag) {
    9503:	48 83 f8 08          	cmp    $0x8,%rax
    9507:	74 57                	je     9560 <_relocate+0x90>
    9509:	48 83 f8 09          	cmp    $0x9,%rax
    950d:	75 e1                	jne    94f0 <_relocate+0x20>
			case DT_RELASZ:
				relsz = dyn[i].d_un.d_val;
				break;

			case DT_RELAENT:
				relent = dyn[i].d_un.d_val;
    950f:	4c 8b 06             	mov    (%rsi),%r8
	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
    9512:	48 8b 46 08          	mov    0x8(%rsi),%rax
    9516:	48 83 c6 10          	add    $0x10,%rsi
    951a:	48 85 c0             	test   %rax,%rax
    951d:	75 e4                	jne    9503 <_relocate+0x33>
			default:
				break;
		}
	}

        if (!rel && relent == 0)
    951f:	48 89 d0             	mov    %rdx,%rax
    9522:	4c 09 c0             	or     %r8,%rax
    9525:	74 33                	je     955a <_relocate+0x8a>
                return EFI_SUCCESS;

	if (!rel || relent == 0)
    9527:	48 85 d2             	test   %rdx,%rdx
    952a:	74 44                	je     9570 <_relocate+0xa0>
    952c:	4d 85 c0             	test   %r8,%r8
    952f:	74 3f                	je     9570 <_relocate+0xa0>
		return EFI_LOAD_ERROR;

	while (relsz > 0) {
    9531:	48 85 c9             	test   %rcx,%rcx
    9534:	7e 24                	jle    955a <_relocate+0x8a>
    9536:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    953d:	00 00 00 
		/* apply the relocs */
		switch (ELF64_R_TYPE (rel->r_info)) {
    9540:	83 7a 08 08          	cmpl   $0x8,0x8(%rdx)
    9544:	75 09                	jne    954f <_relocate+0x7f>
			case R_X86_64_NONE:
				break;

			case R_X86_64_RELATIVE:
				addr = (unsigned long *)
					(ldbase + rel->r_offset);
    9546:	48 8b 02             	mov    (%rdx),%rax
    9549:	48 01 f8             	add    %rdi,%rax
				*addr += ldbase;
    954c:	48 01 38             	add    %rdi,(%rax)

			default:
				break;
		}
		rel = (Elf64_Rel*) ((char *) rel + relent);
		relsz -= relent;
    954f:	4c 29 c1             	sub    %r8,%rcx
		rel = (Elf64_Rel*) ((char *) rel + relent);
    9552:	4c 01 c2             	add    %r8,%rdx
	while (relsz > 0) {
    9555:	48 85 c9             	test   %rcx,%rcx
    9558:	7f e6                	jg     9540 <_relocate+0x70>
                return EFI_SUCCESS;
    955a:	31 c0                	xor    %eax,%eax
    955c:	c3                   	ret    
    955d:	0f 1f 00             	nopl   (%rax)
				relsz = dyn[i].d_un.d_val;
    9560:	48 8b 0e             	mov    (%rsi),%rcx
				break;
    9563:	eb 91                	jmp    94f6 <_relocate+0x26>
    9565:	0f 1f 00             	nopl   (%rax)
					 + ldbase);
    9568:	48 8b 16             	mov    (%rsi),%rdx
    956b:	48 01 fa             	add    %rdi,%rdx
				break;
    956e:	eb 86                	jmp    94f6 <_relocate+0x26>
		return EFI_LOAD_ERROR;
    9570:	48 b8 01 00 00 00 00 	movabs $0x8000000000000001,%rax
    9577:	00 00 80 
	}
	return EFI_SUCCESS;
}
    957a:	c3                   	ret    
    957b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
