
forth.so:     file format elf64-x86-64


Disassembly of section .text:

0000000000003000 <_start>:
	.align 4

	.globl _start
	.type _start,%function
_start:
	subq $8, %rsp
    3000:	48 83 ec 08          	sub    $0x8,%rsp
	pushq %rcx
    3004:	51                   	push   %rcx
	pushq %rdx
    3005:	52                   	push   %rdx

0:
	lea ImageBase(%rip), %rdi
    3006:	48 8d 3d f3 cf ff ff 	lea    -0x300d(%rip),%rdi        # 0 <ImageBase>
	lea _DYNAMIC(%rip), %rsi
    300d:	48 8d 35 ec af 01 00 	lea    0x1afec(%rip),%rsi        # 1e000 <_DYNAMIC>

	popq %rcx
    3014:	59                   	pop    %rcx
	popq %rdx
    3015:	5a                   	pop    %rdx
	pushq %rcx
    3016:	51                   	push   %rcx
	pushq %rdx
    3017:	52                   	push   %rdx
	call _relocate
    3018:	e8 33 68 00 00       	call   9850 <_relocate>

	popq %rdi
    301d:	5f                   	pop    %rdi
	popq %rsi
    301e:	5e                   	pop    %rsi

	call _entry
    301f:	e8 9c 06 00 00       	call   36c0 <_entry>
	addq $8, %rsp
    3024:	48 83 c4 08          	add    $0x8,%rsp

0000000000003028 <.exit>:

.exit:	
  	ret
    3028:	c3                   	ret    
    3029:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003030 <m_loop>:
	return rc;
}

VOID
m_loop()
{        CHAR16   cc;
    3030:	f3 0f 1e fa          	endbr64 
    3034:	53                   	push   %rbx
    3035:	0f 1f 00             	nopl   (%rax)
	do
	{
	   cc=getch ();
    3038:	e8 c3 05 00 00       	call   3600 <getch>
    303d:	0f b7 f8             	movzwl %ax,%edi
    3040:	89 fb                	mov    %edi,%ebx
	   putch(cc);
    3042:	e8 49 06 00 00       	call   3690 <putch>
	   putch('^');
    3047:	bf 5e 00 00 00       	mov    $0x5e,%edi
    304c:	e8 3f 06 00 00       	call   3690 <putch>
	   putch('&');
    3051:	bf 26 00 00 00       	mov    $0x26,%edi
    3056:	e8 35 06 00 00       	call   3690 <putch>
	} while(cc!=L' ');
    305b:	66 83 fb 20          	cmp    $0x20,%bx
    305f:	75 d7                	jne    3038 <m_loop+0x8>
}
    3061:	5b                   	pop    %rbx
    3062:	c3                   	ret    
    3063:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    306a:	00 00 00 00 
    306e:	66 90                	xchg   %ax,%ax

0000000000003070 <C_HALT>:
VOID
C_HALT( EFI_STATUS st );

VOID
C_HALT( EFI_STATUS st )
{	Exit(st, 0, NULL);
    3070:	f3 0f 1e fa          	endbr64 
    3074:	31 d2                	xor    %edx,%edx
    3076:	31 f6                	xor    %esi,%esi
    3078:	e9 a3 09 00 00       	jmp    3a20 <Exit>
    307d:	0f 1f 00             	nopl   (%rax)

0000000000003080 <GetVolume>:
}

EFI_FILE_HANDLE GetVolume(EFI_HANDLE image)
{
    3080:	f3 0f 1e fa          	endbr64 
    3084:	48 83 ec 68          	sub    $0x68,%rsp
    3088:	48 89 f9             	mov    %rdi,%rcx
  EFI_LOADED_IMAGE *loaded_image = NULL;                  /* image interface */
  EFI_GUID lipGuid = EFI_LOADED_IMAGE_PROTOCOL_GUID;      /* image interface GUID */
    308b:	48 b8 a1 31 1b 5b 62 	movabs $0x11d295625b1b31a1,%rax
    3092:	95 d2 11 
    3095:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  EFI_FILE_IO_INTERFACE *IOVolume;                        /* file system interface */
  EFI_GUID fsGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID; /* file system interface GUID */
  EFI_FILE_HANDLE Volume;                                 /* the volume's interface */
 
  /* get the loaded image protocol interface for our "image" */
  uefi_call_wrapper(BS->HandleProtocol, 3, image, &lipGuid, (void **) &loaded_image);
    309a:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
  EFI_GUID lipGuid = EFI_LOADED_IMAGE_PROTOCOL_GUID;      /* image interface GUID */
    309f:	48 b8 8e 3f 00 a0 c9 	movabs $0x3b7269c9a0003f8e,%rax
    30a6:	69 72 3b 
  uefi_call_wrapper(BS->HandleProtocol, 3, image, &lipGuid, (void **) &loaded_image);
    30a9:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
  EFI_GUID lipGuid = EFI_LOADED_IMAGE_PROTOCOL_GUID;      /* image interface GUID */
    30ae:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
  EFI_GUID fsGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID; /* file system interface GUID */
    30b3:	48 b8 22 5b 4e 96 59 	movabs $0x11d26459964e5b22,%rax
    30ba:	64 d2 11 
    30bd:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
    30c2:	48 b8 8e 39 00 a0 c9 	movabs $0x3b7269c9a000398e,%rax
    30c9:	69 72 3b 
    30cc:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  uefi_call_wrapper(BS->HandleProtocol, 3, image, &lipGuid, (void **) &loaded_image);
    30d1:	48 8b 05 58 a5 01 00 	mov    0x1a558(%rip),%rax        # 1d630 <BS>
  EFI_LOADED_IMAGE *loaded_image = NULL;                  /* image interface */
    30d8:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    30df:	00 00 
  uefi_call_wrapper(BS->HandleProtocol, 3, image, &lipGuid, (void **) &loaded_image);
    30e1:	ff 90 98 00 00 00    	call   *0x98(%rax)
  /* get the volume handle */
  uefi_call_wrapper(BS->HandleProtocol, 3, loaded_image->DeviceHandle, &fsGuid, (VOID*)&IOVolume);
    30e7:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    30ec:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
    30f1:	4c 8d 44 24 30       	lea    0x30(%rsp),%r8
    30f6:	48 8b 48 18          	mov    0x18(%rax),%rcx
    30fa:	48 8b 05 2f a5 01 00 	mov    0x1a52f(%rip),%rax        # 1d630 <BS>
    3101:	ff 90 98 00 00 00    	call   *0x98(%rax)
  uefi_call_wrapper(IOVolume->OpenVolume, 2, IOVolume, &Volume);
    3107:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    310c:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
    3111:	48 89 c1             	mov    %rax,%rcx
    3114:	ff 50 08             	call   *0x8(%rax)
  return Volume;
}
    3117:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    311c:	48 83 c4 68          	add    $0x68,%rsp
    3120:	c3                   	ret    
    3121:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3128:	00 00 00 00 
    312c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000003130 <GCCFileSize>:
EFI_FILE_HANDLE Volume;

UINT64 GCCFileSize(EFI_FILE_HANDLE FileHandle)
{
    3130:	f3 0f 1e fa          	endbr64 
    3134:	41 54                	push   %r12
  UINT64 ret;
  EFI_FILE_INFO       *FileInfo;         /* file information structure */
  /* get the file's size */
  FileInfo = LibFileInfo(FileHandle);
    3136:	e8 25 0e 00 00       	call   3f60 <LibFileInfo>
  ret = FileInfo->FileSize;
    313b:	4c 8b 60 08          	mov    0x8(%rax),%r12
  FileInfo = LibFileInfo(FileHandle);
    313f:	48 89 c7             	mov    %rax,%rdi
  FreePool(FileInfo);
    3142:	e8 19 18 00 00       	call   4960 <FreePool>
  return ret;
}
    3147:	4c 89 e0             	mov    %r12,%rax
    314a:	41 5c                	pop    %r12
    314c:	c3                   	ret    
    314d:	0f 1f 00             	nopl   (%rax)

0000000000003150 <GCCOpenFile>:

EFI_STATUS
GCCOpenFile(EFI_FILE_HANDLE * FileHandle, CHAR16 *FileName, UINT64 flg )
{   
    3150:	f3 0f 1e fa          	endbr64 
    3154:	48 83 ec 38          	sub    $0x38,%rsp
   return uefi_call_wrapper(Volume->Open, 5, Volume, FileHandle, FileName, flg , EFI_FILE_VALID_ATTR );
    3158:	48 8b 05 b1 a4 01 00 	mov    0x1a4b1(%rip),%rax        # 1d610 <Volume>
{   
    315f:	49 89 d1             	mov    %rdx,%r9
    3162:	49 89 f0             	mov    %rsi,%r8
   return uefi_call_wrapper(Volume->Open, 5, Volume, FileHandle, FileName, flg , EFI_FILE_VALID_ATTR );
    3165:	48 c7 44 24 20 37 00 	movq   $0x37,0x20(%rsp)
    316c:	00 00 
    316e:	48 89 fa             	mov    %rdi,%rdx
    3171:	48 89 c1             	mov    %rax,%rcx
    3174:	ff 50 08             	call   *0x8(%rax)
}
    3177:	48 83 c4 38          	add    $0x38,%rsp
    317b:	c3                   	ret    
    317c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000003180 <GCCReadFile>:

EFI_STATUS
GCCReadFile(EFI_FILE_HANDLE FileHandle,UINT64 * ReadSize, VOID *Buffer )
{
    3180:	f3 0f 1e fa          	endbr64 
    3184:	48 83 ec 28          	sub    $0x28,%rsp
    3188:	49 89 d0             	mov    %rdx,%r8
//  Print(L"FileHandle = %llx ReadSize = %llx Buffer  = %llx\n", FileHandle, * ReadSize, Buffer  );
 return uefi_call_wrapper(FileHandle->Read, 3, FileHandle, ReadSize, Buffer);
    318b:	48 89 f9             	mov    %rdi,%rcx
    318e:	48 89 f2             	mov    %rsi,%rdx
    3191:	ff 57 20             	call   *0x20(%rdi)
}
    3194:	48 83 c4 28          	add    $0x28,%rsp
    3198:	c3                   	ret    
    3199:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000031a0 <GCCSetPosition>:

EFI_STATUS
GCCSetPosition(EFI_FILE_HANDLE FileHandle, UINTN Offset )
{
    31a0:	f3 0f 1e fa          	endbr64 
    31a4:	48 83 ec 28          	sub    $0x28,%rsp
    31a8:	48 89 f2             	mov    %rsi,%rdx
   return uefi_call_wrapper(FileHandle->SetPosition, 2, FileHandle, Offset);
    31ab:	48 89 f9             	mov    %rdi,%rcx
    31ae:	ff 57 38             	call   *0x38(%rdi)
}
    31b1:	48 83 c4 28          	add    $0x28,%rsp
    31b5:	c3                   	ret    
    31b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    31bd:	00 00 00 

00000000000031c0 <GCCGetPosition>:

EFI_STATUS
GCCGetPosition(EFI_FILE_HANDLE FileHandle, UINTN * Offset )
{
    31c0:	f3 0f 1e fa          	endbr64 
    31c4:	48 83 ec 28          	sub    $0x28,%rsp
    31c8:	48 89 f2             	mov    %rsi,%rdx
   return uefi_call_wrapper(FileHandle->GetPosition, 2, FileHandle, Offset);
    31cb:	48 89 f9             	mov    %rdi,%rcx
    31ce:	ff 57 30             	call   *0x30(%rdi)
}
    31d1:	48 83 c4 28          	add    $0x28,%rsp
    31d5:	c3                   	ret    
    31d6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    31dd:	00 00 00 

00000000000031e0 <GCCCloseFile>:

VOID
GCCCloseFile(EFI_FILE_HANDLE FileHandle)
{  uefi_call_wrapper(FileHandle->Close, 1, FileHandle);
    31e0:	f3 0f 1e fa          	endbr64 
    31e4:	48 83 ec 28          	sub    $0x28,%rsp
    31e8:	48 89 f9             	mov    %rdi,%rcx
    31eb:	ff 57 10             	call   *0x10(%rdi)
}
    31ee:	48 83 c4 28          	add    $0x28,%rsp
    31f2:	c3                   	ret    
    31f3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    31fa:	00 00 00 00 
    31fe:	66 90                	xchg   %ax,%ax

0000000000003200 <GCCSetAttribute>:

VOID
GCCSetAttribute(UINTN color )
{	uefi_call_wrapper(ST->ConOut->SetAttribute, 2, ST->ConOut, color);
    3200:	f3 0f 1e fa          	endbr64 
    3204:	48 83 ec 28          	sub    $0x28,%rsp
    3208:	48 8b 05 29 a4 01 00 	mov    0x1a429(%rip),%rax        # 1d638 <ST>
    320f:	48 89 fa             	mov    %rdi,%rdx
    3212:	48 8b 40 40          	mov    0x40(%rax),%rax
    3216:	48 89 c1             	mov    %rax,%rcx
    3219:	ff 50 28             	call   *0x28(%rax)
}
    321c:	48 83 c4 28          	add    $0x28,%rsp
    3220:	c3                   	ret    
    3221:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3228:	00 00 00 00 
    322c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000003230 <getkey>:
} EFI_INPUT_KEY_M;


EFI_INPUT_KEY_M
getkey ()
{
    3230:	f3 0f 1e fa          	endbr64 
    3234:	48 83 ec 38          	sub    $0x38,%rsp
	EFI_INPUT_KEY_M efi_input_key_M;
	EFI_INPUT_KEY efi_input_key;
	UINTN index;
	uefi_call_wrapper(ST->BootServices->WaitForEvent, 3, 1, &ST->ConIn->WaitForKey, &index);
    3238:	48 8b 05 f9 a3 01 00 	mov    0x1a3f9(%rip),%rax        # 1d638 <ST>
    323f:	b9 01 00 00 00       	mov    $0x1,%ecx
    3244:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    3249:	48 8b 70 30          	mov    0x30(%rax),%rsi
    324d:	48 8b 40 60          	mov    0x60(%rax),%rax
    3251:	48 8d 56 10          	lea    0x10(%rsi),%rdx
    3255:	ff 50 60             	call   *0x60(%rax)
	uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &efi_input_key);
    3258:	48 8b 05 d9 a3 01 00 	mov    0x1a3d9(%rip),%rax        # 1d638 <ST>
    325f:	48 8d 54 24 24       	lea    0x24(%rsp),%rdx
    3264:	48 8b 40 30          	mov    0x30(%rax),%rax
    3268:	48 89 c1             	mov    %rax,%rcx
    326b:	ff 50 08             	call   *0x8(%rax)
	efi_input_key_M.UnicodeChar= efi_input_key.UnicodeChar;
	efi_input_key_M.ScanCode= efi_input_key.ScanCode;
	return efi_input_key_M;
    326e:	0f b7 54 24 24       	movzwl 0x24(%rsp),%edx
    3273:	0f b7 44 24 26       	movzwl 0x26(%rsp),%eax
}
    3278:	48 83 c4 38          	add    $0x38,%rsp
	return efi_input_key_M;
    327c:	c1 e2 10             	shl    $0x10,%edx
    327f:	09 d0                	or     %edx,%eax
}
    3281:	c3                   	ret    
    3282:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3289:	00 00 00 00 
    328d:	0f 1f 00             	nopl   (%rax)

0000000000003290 <efi_main>:
VOID
start4th_m(VOID *);

EFI_STATUS
efi_main (EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *systab)
{	EFI_GUID loaded_image_protocol = LOADED_IMAGE_PROTOCOL;
    3290:	f3 0f 1e fa          	endbr64 
    3294:	48 b8 a1 31 1b 5b 62 	movabs $0x11d295625b1b31a1,%rax
    329b:	95 d2 11 
    329e:	41 54                	push   %r12
    32a0:	49 89 fc             	mov    %rdi,%r12
    32a3:	55                   	push   %rbp
    32a4:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    32ab:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    32b0:	48 b8 8e 3f 00 a0 c9 	movabs $0x3b7269c9a0003f8e,%rax
    32b7:	69 72 3b 
    32ba:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
	EFI_STATUS efi_status;
	EFI_LOADED_IMAGE *li;
	VOID *void_li_p;

	InitializeLib(image_handle, systab);
    32bf:	e8 1c 14 00 00       	call   46e0 <InitializeLib>
        Volume = GetVolume(image_handle);
    32c4:	4c 89 e7             	mov    %r12,%rdi
    32c7:	e8 b4 fd ff ff       	call   3080 <GetVolume>
	/*
	 * Locate loaded_image_handle instance.
	 */

	Print(L"BS->HandleProtocol()  ");
    32cc:	48 8d 3d 2d 5d 02 00 	lea    0x25d2d(%rip),%rdi        # 29000 <_DYNAMIC+0xb000>
        Volume = GetVolume(image_handle);
    32d3:	48 89 05 36 a3 01 00 	mov    %rax,0x1a336(%rip)        # 1d610 <Volume>
	Print(L"BS->HandleProtocol()  ");
    32da:	31 c0                	xor    %eax,%eax
    32dc:	e8 0f 3c 00 00       	call   6ef0 <Print>

	efi_status = uefi_call_wrapper(
    32e1:	48 8b 05 48 a3 01 00 	mov    0x1a348(%rip),%rax        # 1d630 <BS>
    32e8:	4c 89 e1             	mov    %r12,%rcx
    32eb:	4c 8d 44 24 30       	lea    0x30(%rsp),%r8
    32f0:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    32f5:	ff 90 98 00 00 00    	call   *0x98(%rax)
		BS->HandleProtocol,
		3,
		image_handle,
		&loaded_image_protocol,
		&void_li_p);
	li = void_li_p;
    32fb:	4c 8b 64 24 30       	mov    0x30(%rsp),%r12

	Print(L"%xh (%r)\n", efi_status, efi_status);
    3300:	48 8d 3d 27 5d 02 00 	lea    0x25d27(%rip),%rdi        # 2902e <_DYNAMIC+0xb02e>
    3307:	48 89 c2             	mov    %rax,%rdx
	efi_status = uefi_call_wrapper(
    330a:	48 89 c6             	mov    %rax,%rsi
	Print(L"%xh (%r)\n", efi_status, efi_status);
    330d:	31 c0                	xor    %eax,%eax
    330f:	e8 dc 3b 00 00       	call   6ef0 <Print>

	Print(L"  li: %xh\n", li);
    3314:	4c 89 e6             	mov    %r12,%rsi
    3317:	48 8d 3d 24 5d 02 00 	lea    0x25d24(%rip),%rdi        # 29042 <_DYNAMIC+0xb042>
    331e:	31 c0                	xor    %eax,%eax
    3320:	e8 cb 3b 00 00       	call   6ef0 <Print>

	Print(L"  li->FilePath:        %s\n", li->FilePath);
    3325:	49 8b 74 24 20       	mov    0x20(%r12),%rsi
    332a:	48 8d 3d 27 5d 02 00 	lea    0x25d27(%rip),%rdi        # 29058 <_DYNAMIC+0xb058>
    3331:	31 c0                	xor    %eax,%eax
    3333:	e8 b8 3b 00 00       	call   6ef0 <Print>
   return uefi_call_wrapper(Volume->Open, 5, Volume, FileHandle, FileName, flg , EFI_FILE_VALID_ATTR );
    3338:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
    333d:	48 8b 05 cc a2 01 00 	mov    0x1a2cc(%rip),%rax        # 1d610 <Volume>
    3344:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    334a:	48 c7 44 24 20 37 00 	movq   $0x37,0x20(%rsp)
    3351:	00 00 
    3353:	4c 8d 05 36 5d 02 00 	lea    0x25d36(%rip),%r8        # 29090 <_DYNAMIC+0xb090>
    335a:	48 89 c1             	mov    %rax,%rcx
    335d:	ff 50 08             	call   *0x8(%rax)

	EFI_FILE_HANDLE FileHandle;
        EFI_STATUS Status =GCCOpenFile( &FileHandle, L"ForthLib\\DATT.TXT", EFI_FILE_MODE_READ);
	
	Print(L" OpenFile = %llxh st=%x\n", FileHandle,Status);
    3360:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    3365:	48 8d 3d 4c 5d 02 00 	lea    0x25d4c(%rip),%rdi        # 290b8 <_DYNAMIC+0xb0b8>
   return uefi_call_wrapper(Volume->Open, 5, Volume, FileHandle, FileName, flg , EFI_FILE_VALID_ATTR );
    336c:	48 89 c2             	mov    %rax,%rdx
	Print(L" OpenFile = %llxh st=%x\n", FileHandle,Status);
    336f:	31 c0                	xor    %eax,%eax
    3371:	e8 7a 3b 00 00       	call   6ef0 <Print>
	if(FileHandle)
    3376:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    337b:	48 85 ff             	test   %rdi,%rdi
    337e:	74 5a                	je     33da <efi_main+0x14a>
	{
	UINT64  ReadSize = GCCFileSize(FileHandle);
    3380:	e8 ab fd ff ff       	call   3130 <GCCFileSize>
	Print(L" ReadSize = %llxh\n", ReadSize);
    3385:	48 8d 3d 64 5d 02 00 	lea    0x25d64(%rip),%rdi        # 290f0 <_DYNAMIC+0xb0f0>
	UINT64  ReadSize = GCCFileSize(FileHandle);
    338c:	48 89 c6             	mov    %rax,%rsi
    338f:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
	Print(L" ReadSize = %llxh\n", ReadSize);
    3394:	31 c0                	xor    %eax,%eax
    3396:	e8 55 3b 00 00       	call   6ef0 <Print>

	UINT16  *Buffer = AllocatePool(ReadSize);
    339b:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    33a0:	e8 9b 14 00 00       	call   4840 <AllocatePool>
 return uefi_call_wrapper(FileHandle->Read, 3, FileHandle, ReadSize, Buffer);
    33a5:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
	UINT16  *Buffer = AllocatePool(ReadSize);
    33aa:	49 89 c4             	mov    %rax,%r12
	GCCReadFile(FileHandle,&ReadSize, Buffer);
    33ad:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 return uefi_call_wrapper(FileHandle->Read, 3, FileHandle, ReadSize, Buffer);
    33b2:	4d 89 e0             	mov    %r12,%r8
    33b5:	48 89 c1             	mov    %rax,%rcx
    33b8:	ff 50 20             	call   *0x20(%rax)
//	uefi_call_wrapper(FileHandle->Read, 3, FileHandle, &ReadSize, Buffer);
	uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Buffer);
    33bb:	48 8b 05 76 a2 01 00 	mov    0x1a276(%rip),%rax        # 1d638 <ST>
    33c2:	4c 89 e2             	mov    %r12,%rdx
    33c5:	48 8b 40 40          	mov    0x40(%rax),%rax
    33c9:	48 89 c1             	mov    %rax,%rcx
    33cc:	ff 50 08             	call   *0x8(%rax)
	GCCCloseFile(FileHandle);
    33cf:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
{  uefi_call_wrapper(FileHandle->Close, 1, FileHandle);
    33d4:	48 89 c1             	mov    %rax,%rcx
    33d7:	ff 50 10             	call   *0x10(%rax)
	}

	uefi_call_wrapper(ST->ConOut->EnableCursor, 2, ST->ConOut, 1);
    33da:	48 8b 05 57 a2 01 00 	mov    0x1a257(%rip),%rax        # 1d638 <ST>
    33e1:	ba 01 00 00 00       	mov    $0x1,%edx
    33e6:	48 8b 40 40          	mov    0x40(%rax),%rax
    33ea:	48 89 c1             	mov    %rax,%rcx
    33ed:	ff 50 40             	call   *0x40(%rax)
	Print(L"Forth application started\n");
    33f0:	48 8d 3d 21 5d 02 00 	lea    0x25d21(%rip),%rdi        # 29118 <_DYNAMIC+0xb118>
    33f7:	31 c0                	xor    %eax,%eax
    33f9:	e8 f2 3a 00 00       	call   6ef0 <Print>
	rc = uefi_call_wrapper(BS->SetWatchdogTimer, 4, seconds, 0x1ffff,
    33fe:	45 31 c9             	xor    %r9d,%r9d
    3401:	45 31 c0             	xor    %r8d,%r8d
    3404:	ba ff ff 01 00       	mov    $0x1ffff,%edx
    3409:	48 8b 05 20 a2 01 00 	mov    0x1a220(%rip),%rax        # 1d630 <BS>
    3410:	31 c9                	xor    %ecx,%ecx
    3412:	ff 90 00 01 00 00    	call   *0x100(%rax)
    3418:	49 89 c4             	mov    %rax,%r12
	if (EFI_ERROR(rc)) {
    341b:	48 85 c0             	test   %rax,%rax
    341e:	78 28                	js     3448 <efi_main+0x1b8>
	SetWatchdog(0);
//	WaitForSingleEvent(ST->ConIn->WaitForKey, 0);
//	uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, L"\n\n");
	VOID * DPBuff_adr =  AllocatePool(0x180000);
    3420:	bf 00 00 18 00       	mov    $0x180000,%edi
    3425:	e8 16 14 00 00       	call   4840 <AllocatePool>
    342a:	48 89 c7             	mov    %rax,%rdi
		start4th_m(DPBuff_adr);
    342d:	e8 1d 95 01 00       	call   1c94f <start4th_m>
		pek();
    3432:	e8 69 01 00 00       	call   35a0 <pek>
	return EFI_SUCCESS;
}
    3437:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    343e:	31 c0                	xor    %eax,%eax
    3440:	5d                   	pop    %rbp
    3441:	41 5c                	pop    %r12
    3443:	c3                   	ret    
    3444:	0f 1f 40 00          	nopl   0x0(%rax)
		StatusToString(Buffer, rc);
    3448:	48 8d 6c 24 50       	lea    0x50(%rsp),%rbp
    344d:	48 89 c6             	mov    %rax,%rsi
    3450:	48 89 ef             	mov    %rbp,%rdi
    3453:	e8 68 03 00 00       	call   37c0 <StatusToString>
		Print(L"Bad response from QueryMode: %s (%d)\n", Buffer, rc);
    3458:	4c 89 e2             	mov    %r12,%rdx
    345b:	48 89 ee             	mov    %rbp,%rsi
    345e:	31 c0                	xor    %eax,%eax
    3460:	48 8d 3d e9 5c 02 00 	lea    0x25ce9(%rip),%rdi        # 29150 <_DYNAMIC+0xb150>
    3467:	e8 84 3a 00 00       	call   6ef0 <Print>
    346c:	eb b2                	jmp    3420 <efi_main+0x190>
    346e:	66 90                	xchg   %ax,%ax

0000000000003470 <Output>:
VOID
Output (
    IN CHAR16   *Str
    )
// Write a string to the console at the current cursor location
{
    3470:	f3 0f 1e fa          	endbr64 
    3474:	48 83 ec 28          	sub    $0x28,%rsp
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Str);
    3478:	48 8b 05 b9 a1 01 00 	mov    0x1a1b9(%rip),%rax        # 1d638 <ST>
{
    347f:	48 89 fa             	mov    %rdi,%rdx
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Str);
    3482:	48 8b 40 40          	mov    0x40(%rax),%rax
    3486:	48 89 c1             	mov    %rax,%rcx
    3489:	ff 50 08             	call   *0x8(%rax)
}
    348c:	48 83 c4 28          	add    $0x28,%rsp
    3490:	c3                   	ret    
    3491:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3498:	00 00 00 00 
    349c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000034a0 <IInput>:
    IN CHAR16                           *Prompt OPTIONAL,
    OUT CHAR16                          *InStr,
    IN UINTN                            StrLen
    )
// Input a string at the current cursor location, for StrLen
{
    34a0:	f3 0f 1e fa          	endbr64 
    34a4:	41 57                	push   %r15
    34a6:	49 89 f7             	mov    %rsi,%r15
    34a9:	41 56                	push   %r14
    34ab:	4d 89 c6             	mov    %r8,%r14
    34ae:	41 55                	push   %r13
    34b0:	49 89 cd             	mov    %rcx,%r13
    34b3:	41 54                	push   %r12
    34b5:	49 89 fc             	mov    %rdi,%r12
    34b8:	55                   	push   %rbp
    34b9:	53                   	push   %rbx
    34ba:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_INPUT_KEY                   Key;
    EFI_STATUS                      Status;
    UINTN                           Len;

    if (Prompt) {
    34be:	48 85 d2             	test   %rdx,%rdx
    34c1:	74 06                	je     34c9 <IInput+0x29>
        ConOut->OutputString (ConOut, Prompt);
    34c3:	48 89 f9             	mov    %rdi,%rcx
    34c6:	ff 57 08             	call   *0x8(%rdi)
{
    34c9:	31 db                	xor    %ebx,%ebx
    34cb:	48 8d 6c 24 2c       	lea    0x2c(%rsp),%rbp
    }

    Len = 0;
    for (; ;) {
        WaitForSingleEvent (ConIn->WaitForKey, 0);
    34d0:	49 8b 7f 10          	mov    0x10(%r15),%rdi
    34d4:	31 f6                	xor    %esi,%esi
    34d6:	e8 c5 03 00 00       	call   38a0 <WaitForSingleEvent>

        Status = uefi_call_wrapper(ConIn->ReadKeyStroke, 2, ConIn, &Key);
    34db:	48 89 ea             	mov    %rbp,%rdx
    34de:	4c 89 f9             	mov    %r15,%rcx
    34e1:	41 ff 57 08          	call   *0x8(%r15)
        if (EFI_ERROR(Status)) {
    34e5:	48 85 c0             	test   %rax,%rax
    34e8:	78 6e                	js     3558 <IInput+0xb8>
            DEBUG((D_ERROR, "Input: error return from ReadKey %x\n", Status));
            break;
        }

        if (Key.UnicodeChar == '\n' ||
    34ea:	0f b7 44 24 2e       	movzwl 0x2e(%rsp),%eax
    34ef:	66 83 f8 0a          	cmp    $0xa,%ax
    34f3:	74 63                	je     3558 <IInput+0xb8>
    34f5:	66 83 f8 0d          	cmp    $0xd,%ax
    34f9:	74 5d                	je     3558 <IInput+0xb8>
            Key.UnicodeChar == '\r') {
            break;
        }
        
        if (Key.UnicodeChar == '\b') {
    34fb:	66 83 f8 08          	cmp    $0x8,%ax
    34ff:	74 37                	je     3538 <IInput+0x98>
                Len -= 1;
            }
            continue;
        }

        if (Key.UnicodeChar >= ' ') {
    3501:	66 83 f8 1f          	cmp    $0x1f,%ax
    3505:	76 c9                	jbe    34d0 <IInput+0x30>
            if (Len < StrLen-1) {
    3507:	49 8d 56 ff          	lea    -0x1(%r14),%rdx
    350b:	48 39 da             	cmp    %rbx,%rdx
    350e:	76 c0                	jbe    34d0 <IInput+0x30>
                InStr[Len] = Key.UnicodeChar;
    3510:	48 8d 0c 1b          	lea    (%rbx,%rbx,1),%rcx

                InStr[Len+1] = 0;
    3514:	31 f6                	xor    %esi,%esi
    3516:	48 83 c3 01          	add    $0x1,%rbx
                InStr[Len] = Key.UnicodeChar;
    351a:	49 8d 54 0d 00       	lea    0x0(%r13,%rcx,1),%rdx
    351f:	66 89 02             	mov    %ax,(%rdx)
                InStr[Len+1] = 0;
    3522:	66 41 89 74 0d 02    	mov    %si,0x2(%r13,%rcx,1)
                uefi_call_wrapper(ConOut->OutputString, 2, ConOut, &InStr[Len]);
    3528:	4c 89 e1             	mov    %r12,%rcx
    352b:	41 ff 54 24 08       	call   *0x8(%r12)

                Len += 1;
    3530:	eb 9e                	jmp    34d0 <IInput+0x30>
    3532:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            if (Len) {
    3538:	48 85 db             	test   %rbx,%rbx
    353b:	74 93                	je     34d0 <IInput+0x30>
                uefi_call_wrapper(ConOut->OutputString, 2, ConOut, L"\b \b");
    353d:	48 8d 15 5c 5c 02 00 	lea    0x25c5c(%rip),%rdx        # 291a0 <_DYNAMIC+0xb1a0>
    3544:	4c 89 e1             	mov    %r12,%rcx
                Len -= 1;
    3547:	48 83 eb 01          	sub    $0x1,%rbx
                uefi_call_wrapper(ConOut->OutputString, 2, ConOut, L"\b \b");
    354b:	41 ff 54 24 08       	call   *0x8(%r12)
                Len -= 1;
    3550:	e9 7b ff ff ff       	jmp    34d0 <IInput+0x30>
    3555:	0f 1f 00             	nopl   (%rax)
            }
            continue;
        }
    }

    InStr[Len] = 0;
    3558:	31 c0                	xor    %eax,%eax
    355a:	66 41 89 44 5d 00    	mov    %ax,0x0(%r13,%rbx,2)
}
    3560:	48 83 c4 38          	add    $0x38,%rsp
    3564:	5b                   	pop    %rbx
    3565:	5d                   	pop    %rbp
    3566:	41 5c                	pop    %r12
    3568:	41 5d                	pop    %r13
    356a:	41 5e                	pop    %r14
    356c:	41 5f                	pop    %r15
    356e:	c3                   	ret    
    356f:	90                   	nop

0000000000003570 <Input>:
{
    3570:	f3 0f 1e fa          	endbr64 
        ST->ConIn,
    3574:	48 8b 05 bd a0 01 00 	mov    0x1a0bd(%rip),%rax        # 1d638 <ST>
{
    357b:	49 89 f9             	mov    %rdi,%r9
    357e:	48 89 f1             	mov    %rsi,%rcx
    3581:	49 89 d0             	mov    %rdx,%r8
    IInput (
    3584:	4c 89 ca             	mov    %r9,%rdx
    3587:	48 8b 70 30          	mov    0x30(%rax),%rsi
    358b:	48 8b 78 40          	mov    0x40(%rax),%rdi
    358f:	e9 0c ff ff ff       	jmp    34a0 <IInput>
    3594:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    359b:	00 00 00 00 
    359f:	90                   	nop

00000000000035a0 <pek>:


VOID
pek ()
{
    35a0:	f3 0f 1e fa          	endbr64 
    35a4:	48 83 ec 38          	sub    $0x38,%rsp
	EFI_INPUT_KEY efi_input_key;
	UINTN index;
	uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, L"\tHit any key to continue\r\n");
    35a8:	48 8b 05 89 a0 01 00 	mov    0x1a089(%rip),%rax        # 1d638 <ST>
    35af:	48 8d 15 f2 5b 02 00 	lea    0x25bf2(%rip),%rdx        # 291a8 <_DYNAMIC+0xb1a8>
    35b6:	48 8b 40 40          	mov    0x40(%rax),%rax
    35ba:	48 89 c1             	mov    %rax,%rcx
    35bd:	ff 50 08             	call   *0x8(%rax)
	uefi_call_wrapper(ST->BootServices->WaitForEvent, 3, 1, &ST->ConIn->WaitForKey, &index);
    35c0:	48 8b 05 71 a0 01 00 	mov    0x1a071(%rip),%rax        # 1d638 <ST>
    35c7:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    35cc:	b9 01 00 00 00       	mov    $0x1,%ecx
    35d1:	48 8b 70 30          	mov    0x30(%rax),%rsi
    35d5:	48 8b 40 60          	mov    0x60(%rax),%rax
    35d9:	48 8d 56 10          	lea    0x10(%rsi),%rdx
    35dd:	ff 50 60             	call   *0x60(%rax)
	uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &efi_input_key);
    35e0:	48 8b 05 51 a0 01 00 	mov    0x1a051(%rip),%rax        # 1d638 <ST>
    35e7:	48 8d 54 24 24       	lea    0x24(%rsp),%rdx
    35ec:	48 8b 40 30          	mov    0x30(%rax),%rax
    35f0:	48 89 c1             	mov    %rax,%rcx
    35f3:	ff 50 08             	call   *0x8(%rax)
}
    35f6:	48 83 c4 38          	add    $0x38,%rsp
    35fa:	c3                   	ret    
    35fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003600 <getch>:

UINT16  LastScanCode;

CHAR16
getch ()
{
    3600:	f3 0f 1e fa          	endbr64 
    3604:	48 83 ec 38          	sub    $0x38,%rsp
	EFI_INPUT_KEY efi_input_key;
	UINTN index;
	uefi_call_wrapper(ST->BootServices->WaitForEvent, 3, 1, &ST->ConIn->WaitForKey, &index);
    3608:	48 8b 05 29 a0 01 00 	mov    0x1a029(%rip),%rax        # 1d638 <ST>
    360f:	b9 01 00 00 00       	mov    $0x1,%ecx
    3614:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    3619:	48 8b 70 30          	mov    0x30(%rax),%rsi
    361d:	48 8b 40 60          	mov    0x60(%rax),%rax
    3621:	48 8d 56 10          	lea    0x10(%rsi),%rdx
    3625:	ff 50 60             	call   *0x60(%rax)
	uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &efi_input_key);
    3628:	48 8b 05 09 a0 01 00 	mov    0x1a009(%rip),%rax        # 1d638 <ST>
    362f:	48 8d 54 24 24       	lea    0x24(%rsp),%rdx
    3634:	48 8b 40 30          	mov    0x30(%rax),%rax
    3638:	48 89 c1             	mov    %rax,%rcx
    363b:	ff 50 08             	call   *0x8(%rax)
	LastScanCode = efi_input_key.ScanCode;
    363e:	0f b7 44 24 24       	movzwl 0x24(%rsp),%eax
    3643:	66 89 05 ce 9f 01 00 	mov    %ax,0x19fce(%rip)        # 1d618 <LastScanCode>
	return efi_input_key.UnicodeChar;
}
    364a:	0f b7 44 24 26       	movzwl 0x26(%rsp),%eax
    364f:	48 83 c4 38          	add    $0x38,%rsp
    3653:	c3                   	ret    
    3654:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    365b:	00 00 00 00 
    365f:	90                   	nop

0000000000003660 <kbhit>:


EFI_STATUS
kbhit ()
{
    3660:	f3 0f 1e fa          	endbr64 
    3664:	48 83 ec 38          	sub    $0x38,%rsp
	EFI_INPUT_KEY efi_input_key;
	return  	uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &efi_input_key);
    3668:	48 8b 05 c9 9f 01 00 	mov    0x19fc9(%rip),%rax        # 1d638 <ST>
    366f:	48 8d 54 24 2c       	lea    0x2c(%rsp),%rdx
    3674:	48 8b 40 30          	mov    0x30(%rax),%rax
    3678:	48 89 c1             	mov    %rax,%rcx
    367b:	ff 50 08             	call   *0x8(%rax)
}
    367e:	48 83 c4 38          	add    $0x38,%rsp
    3682:	c3                   	ret    
    3683:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    368a:	00 00 00 00 
    368e:	66 90                	xchg   %ax,%ax

0000000000003690 <putch>:

VOID
putch (CHAR16 cc)
{ CHAR16 * pcc=L"*";
    3690:	f3 0f 1e fa          	endbr64 
    3694:	48 83 ec 28          	sub    $0x28,%rsp
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Str);
    3698:	48 8b 05 99 9f 01 00 	mov    0x19f99(%rip),%rax        # 1d638 <ST>
//   Output (pcc);
   *pcc= cc;
    369f:	66 89 3d 38 5b 02 00 	mov    %di,0x25b38(%rip)        # 291de <_DYNAMIC+0xb1de>
    uefi_call_wrapper(ST->ConOut->OutputString, 2, ST->ConOut, Str);
    36a6:	48 8d 15 31 5b 02 00 	lea    0x25b31(%rip),%rdx        # 291de <_DYNAMIC+0xb1de>
    36ad:	48 8b 40 40          	mov    0x40(%rax),%rax
    36b1:	48 89 c1             	mov    %rax,%rcx
    36b4:	ff 50 08             	call   *0x8(%rax)
   Output (pcc);
}
    36b7:	48 83 c4 28          	add    $0x28,%rsp
    36bb:	c3                   	ret    
    36bc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000036c0 <_entry>:
}

extern EFI_STATUS efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab);

EFI_STATUS _entry(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
    36c0:	f3 0f 1e fa          	endbr64 
    36c4:	41 56                	push   %r14
	size_t __init_array_length = __init_array_end - __init_array_start;
    36c6:	4c 8d 35 43 9f 01 00 	lea    0x19f43(%rip),%r14        # 1d610 <Volume>
{
    36cd:	41 55                	push   %r13
    36cf:	49 89 f5             	mov    %rsi,%r13
    36d2:	41 54                	push   %r12
    36d4:	49 89 fc             	mov    %rdi,%r12
    36d7:	55                   	push   %rbp
	size_t __init_array_length = __init_array_end - __init_array_start;
    36d8:	48 8d 2d 31 9f 01 00 	lea    0x19f31(%rip),%rbp        # 1d610 <Volume>
{
    36df:	53                   	push   %rbx
	size_t __init_array_length = __init_array_end - __init_array_start;
    36e0:	4c 29 f5             	sub    %r14,%rbp
	EFI_STATUS status;
	InitializeLib(image, systab);
    36e3:	e8 f8 0f 00 00       	call   46e0 <InitializeLib>
	for (size_t i = 0; i < __init_array_length; i++) {
    36e8:	48 c1 fd 03          	sar    $0x3,%rbp
    36ec:	74 16                	je     3704 <_entry+0x44>
    36ee:	31 db                	xor    %ebx,%ebx
		funcp func = __init_array_start[i];
    36f0:	49 8b 04 de          	mov    (%r14,%rbx,8),%rax
		if (func != NULL)
    36f4:	48 85 c0             	test   %rax,%rax
    36f7:	74 02                	je     36fb <_entry+0x3b>
			func();
    36f9:	ff d0                	call   *%rax
	for (size_t i = 0; i < __init_array_length; i++) {
    36fb:	48 83 c3 01          	add    $0x1,%rbx
    36ff:	48 39 dd             	cmp    %rbx,%rbp
    3702:	75 ec                	jne    36f0 <_entry+0x30>
	size_t __CTOR_length = __CTOR_END__ - __CTOR_LIST__;
    3704:	48 8d 1d 05 9f 01 00 	lea    0x19f05(%rip),%rbx        # 1d610 <Volume>
    370b:	48 8d 05 fe 9e 01 00 	lea    0x19efe(%rip),%rax        # 1d610 <Volume>
	for (size_t i = 0; i < __CTOR_length; i++) {
    3712:	31 ed                	xor    %ebp,%ebp
	size_t __CTOR_length = __CTOR_END__ - __CTOR_LIST__;
    3714:	49 89 de             	mov    %rbx,%r14
    3717:	49 29 c6             	sub    %rax,%r14
	for (size_t i = 0; i < __CTOR_length; i++) {
    371a:	49 c1 fe 03          	sar    $0x3,%r14
    371e:	74 18                	je     3738 <_entry+0x78>
		funcp func = __CTOR_LIST__[current];
    3720:	48 8b 43 f8          	mov    -0x8(%rbx),%rax
		if (func != NULL)
    3724:	48 85 c0             	test   %rax,%rax
    3727:	74 02                	je     372b <_entry+0x6b>
			func();
    3729:	ff d0                	call   *%rax
	for (size_t i = 0; i < __CTOR_length; i++) {
    372b:	48 83 c5 01          	add    $0x1,%rbp
    372f:	48 83 eb 08          	sub    $0x8,%rbx
    3733:	49 39 ee             	cmp    %rbp,%r14
    3736:	75 e8                	jne    3720 <_entry+0x60>

	ctors();
	status = efi_main(image, systab);
    3738:	4c 89 ee             	mov    %r13,%rsi
	size_t __DTOR_length = __DTOR_END__ - __DTOR_LIST__;
    373b:	48 8d 2d ce 9e 01 00 	lea    0x19ece(%rip),%rbp        # 1d610 <Volume>
	status = efi_main(image, systab);
    3742:	4c 89 e7             	mov    %r12,%rdi
	for (size_t i = 0; i < __DTOR_length; i++) {
    3745:	31 db                	xor    %ebx,%ebx
	status = efi_main(image, systab);
    3747:	e8 44 fb ff ff       	call   3290 <efi_main>
	size_t __DTOR_length = __DTOR_END__ - __DTOR_LIST__;
    374c:	4c 8d 2d bd 9e 01 00 	lea    0x19ebd(%rip),%r13        # 1d610 <Volume>
    3753:	4c 29 ed             	sub    %r13,%rbp
	status = efi_main(image, systab);
    3756:	49 89 c4             	mov    %rax,%r12
	for (size_t i = 0; i < __DTOR_length; i++) {
    3759:	48 c1 fd 03          	sar    $0x3,%rbp
    375d:	74 16                	je     3775 <_entry+0xb5>
    375f:	90                   	nop
		funcp func = __DTOR_LIST__[i];
    3760:	49 8b 44 dd 00       	mov    0x0(%r13,%rbx,8),%rax
		if (func != NULL)
    3765:	48 85 c0             	test   %rax,%rax
    3768:	74 02                	je     376c <_entry+0xac>
			func();
    376a:	ff d0                	call   *%rax
	for (size_t i = 0; i < __DTOR_length; i++) {
    376c:	48 83 c3 01          	add    $0x1,%rbx
    3770:	48 39 dd             	cmp    %rbx,%rbp
    3773:	75 eb                	jne    3760 <_entry+0xa0>
	size_t __fini_array_length = __fini_array_end - __fini_array_start;
    3775:	48 8d 1d 94 9e 01 00 	lea    0x19e94(%rip),%rbx        # 1d610 <Volume>
    377c:	48 8d 05 8d 9e 01 00 	lea    0x19e8d(%rip),%rax        # 1d610 <Volume>
	for (size_t i = 0; i < __fini_array_length; i++) {
    3783:	31 ed                	xor    %ebp,%ebp
	size_t __fini_array_length = __fini_array_end - __fini_array_start;
    3785:	49 89 dd             	mov    %rbx,%r13
    3788:	49 29 c5             	sub    %rax,%r13
	for (size_t i = 0; i < __fini_array_length; i++) {
    378b:	49 c1 fd 03          	sar    $0x3,%r13
    378f:	74 1f                	je     37b0 <_entry+0xf0>
    3791:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		funcp func = __fini_array_start[current];
    3798:	48 8b 43 f8          	mov    -0x8(%rbx),%rax
		if (func != NULL)
    379c:	48 85 c0             	test   %rax,%rax
    379f:	74 02                	je     37a3 <_entry+0xe3>
			func();
    37a1:	ff d0                	call   *%rax
	for (size_t i = 0; i < __fini_array_length; i++) {
    37a3:	48 83 c5 01          	add    $0x1,%rbp
    37a7:	48 83 eb 08          	sub    $0x8,%rbx
    37ab:	49 39 ed             	cmp    %rbp,%r13
    37ae:	75 e8                	jne    3798 <_entry+0xd8>
	dtors();

	return status;
}
    37b0:	5b                   	pop    %rbx
    37b1:	4c 89 e0             	mov    %r12,%rax
    37b4:	5d                   	pop    %rbp
    37b5:	41 5c                	pop    %r12
    37b7:	41 5d                	pop    %r13
    37b9:	41 5e                	pop    %r14
    37bb:	c3                   	ret    
    37bc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000037c0 <StatusToString>:
VOID
StatusToString (
    OUT CHAR16          *Buffer,
    IN EFI_STATUS       Status
    )
{
    37c0:	f3 0f 1e fa          	endbr64 
    37c4:	48 89 f1             	mov    %rsi,%rcx
    UINTN           Index;

    for (Index = 0; ErrorCodeTable[Index].Desc; Index +=1) {
    37c7:	48 8b 35 ba 96 01 00 	mov    0x196ba(%rip),%rsi        # 1ce88 <ErrorCodeTable+0x8>
    37ce:	48 85 f6             	test   %rsi,%rsi
    37d1:	74 2d                	je     3800 <StatusToString+0x40>
    37d3:	48 8d 05 a6 96 01 00 	lea    0x196a6(%rip),%rax        # 1ce80 <ErrorCodeTable>
    37da:	eb 11                	jmp    37ed <StatusToString+0x2d>
    37dc:	0f 1f 40 00          	nopl   0x0(%rax)
    37e0:	48 8b 70 18          	mov    0x18(%rax),%rsi
    37e4:	48 83 c0 10          	add    $0x10,%rax
    37e8:	48 85 f6             	test   %rsi,%rsi
    37eb:	74 13                	je     3800 <StatusToString+0x40>
        if (ErrorCodeTable[Index].Code == Status) {
    37ed:	48 39 08             	cmp    %rcx,(%rax)
    37f0:	75 ee                	jne    37e0 <StatusToString+0x20>
	    StrCpy (Buffer, ErrorCodeTable[Index].Desc);
    37f2:	e9 39 3e 00 00       	jmp    7630 <StrCpy>
    37f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    37fe:	00 00 
            return;
        }
    }

    UnicodeSPrint (Buffer, 0, L"%X", Status);
    3800:	48 8d 15 e1 59 02 00 	lea    0x259e1(%rip),%rdx        # 291e8 <_DYNAMIC+0xb1e8>
    3807:	31 f6                	xor    %esi,%esi
    3809:	31 c0                	xor    %eax,%eax
    380b:	e9 60 34 00 00       	jmp    6c70 <UnicodeSPrint>

0000000000003810 <LibCreateProtocolNotifyEvent>:
    IN EFI_TPL              NotifyTpl,
    IN EFI_EVENT_NOTIFY     NotifyFunction,
    IN VOID                 *NotifyContext,
    OUT VOID                *Registration
    )
{
    3810:	f3 0f 1e fa          	endbr64 
    3814:	41 54                	push   %r12
    3816:	49 89 c9             	mov    %rcx,%r9
    3819:	49 89 fc             	mov    %rdi,%r12

    //
    // Create the event
    //

    Status = uefi_call_wrapper(
    381c:	b9 00 02 00 00       	mov    $0x200,%ecx
{
    3821:	53                   	push   %rbx
    3822:	4c 89 c3             	mov    %r8,%rbx
    Status = uefi_call_wrapper(
    3825:	49 89 d0             	mov    %rdx,%r8
    3828:	48 89 f2             	mov    %rsi,%rdx
{
    382b:	48 83 ec 48          	sub    $0x48,%rsp
    Status = uefi_call_wrapper(
    382f:	48 8d 44 24 38       	lea    0x38(%rsp),%rax
    3834:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    3839:	48 8b 05 f0 9d 01 00 	mov    0x19df0(%rip),%rax        # 1d630 <BS>
    3840:	ff 50 50             	call   *0x50(%rax)
		    NotifyTpl,
		    NotifyFunction,
		    NotifyContext,
		    &Event
		    );
    if ( EFI_ERROR( Status ) ) return NULL ;
    3843:	48 85 c0             	test   %rax,%rax
    3846:	78 40                	js     3888 <LibCreateProtocolNotifyEvent+0x78>

    //
    // Register for protocol notifactions on this event
    //

    Status = uefi_call_wrapper(
    3848:	48 8b 05 e1 9d 01 00 	mov    0x19de1(%rip),%rax        # 1d630 <BS>
    384f:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    3854:	49 89 d8             	mov    %rbx,%r8
    3857:	4c 89 e1             	mov    %r12,%rcx
    385a:	ff 90 a8 00 00 00    	call   *0xa8(%rax)
			3,
                    ProtocolGuid,
                    Event,
                    Registration
                    );
    if ( EFI_ERROR( Status ) ) return NULL ;
    3860:	48 85 c0             	test   %rax,%rax
    3863:	78 23                	js     3888 <LibCreateProtocolNotifyEvent+0x78>
    //
    // Kick the event so we will perform an initial pass of
    // current installed drivers
    //

    uefi_call_wrapper(BS->SignalEvent, 1, Event);
    3865:	48 8b 05 c4 9d 01 00 	mov    0x19dc4(%rip),%rax        # 1d630 <BS>
    386c:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    3871:	ff 50 68             	call   *0x68(%rax)
    return Event;
    3874:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
}
    3879:	48 83 c4 48          	add    $0x48,%rsp
    387d:	5b                   	pop    %rbx
    387e:	41 5c                	pop    %r12
    3880:	c3                   	ret    
    3881:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    3888:	48 83 c4 48          	add    $0x48,%rsp
    if ( EFI_ERROR( Status ) ) return NULL ;
    388c:	31 c0                	xor    %eax,%eax
}
    388e:	5b                   	pop    %rbx
    388f:	41 5c                	pop    %r12
    3891:	c3                   	ret    
    3892:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3899:	00 00 00 00 
    389d:	0f 1f 00             	nopl   (%rax)

00000000000038a0 <WaitForSingleEvent>:
EFI_STATUS
WaitForSingleEvent (
    IN EFI_EVENT        Event,
    IN UINT64           Timeout OPTIONAL
    )
{
    38a0:	f3 0f 1e fa          	endbr64 
    38a4:	41 54                	push   %r12
    38a6:	53                   	push   %rbx
    38a7:	48 83 ec 68          	sub    $0x68,%rsp
    if (Timeout) {
        //
        // Create a timer event
        //

        Status = uefi_call_wrapper(BS->CreateEvent, 5, EVT_TIMER, 0, NULL, NULL, &TimerEvent);
    38ab:	48 8b 05 7e 9d 01 00 	mov    0x19d7e(%rip),%rax        # 1d630 <BS>
{
    38b2:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    if (Timeout) {
    38b7:	48 85 f6             	test   %rsi,%rsi
    38ba:	0f 84 a0 00 00 00    	je     3960 <WaitForSingleEvent+0xc0>
        Status = uefi_call_wrapper(BS->CreateEvent, 5, EVT_TIMER, 0, NULL, NULL, &TimerEvent);
    38c0:	48 8d 54 24 48       	lea    0x48(%rsp),%rdx
    38c5:	48 89 f3             	mov    %rsi,%rbx
    38c8:	45 31 c9             	xor    %r9d,%r9d
    38cb:	45 31 c0             	xor    %r8d,%r8d
    38ce:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    38d3:	b9 00 00 00 80       	mov    $0x80000000,%ecx
    38d8:	31 d2                	xor    %edx,%edx
    38da:	ff 50 50             	call   *0x50(%rax)
    38dd:	49 89 c4             	mov    %rax,%r12
        if (!EFI_ERROR(Status)) {
    38e0:	48 85 c0             	test   %rax,%rax
    38e3:	78 6f                	js     3954 <WaitForSingleEvent+0xb4>

            //
            // Set the timer event
            //

            uefi_call_wrapper(BS->SetTimer, 3, TimerEvent, TimerRelative, Timeout);
    38e5:	48 8b 05 44 9d 01 00 	mov    0x19d44(%rip),%rax        # 1d630 <BS>
    38ec:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    38f1:	49 89 d8             	mov    %rbx,%r8
    38f4:	ba 02 00 00 00       	mov    $0x2,%edx
    38f9:	ff 50 58             	call   *0x58(%rax)

            //
            // Wait for the original event or the timer
            //

            WaitList[0] = Event;
    38fc:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
            WaitList[1] = TimerEvent;
            Status = uefi_call_wrapper(BS->WaitForEvent, 3, 2, WaitList, &Index);
    3901:	b9 02 00 00 00       	mov    $0x2,%ecx
    3906:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
    390b:	4c 8d 44 24 40       	lea    0x40(%rsp),%r8
            WaitList[0] = Event;
    3910:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
            WaitList[1] = TimerEvent;
    3915:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    391a:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
            Status = uefi_call_wrapper(BS->WaitForEvent, 3, 2, WaitList, &Index);
    391f:	48 8b 05 0a 9d 01 00 	mov    0x19d0a(%rip),%rax        # 1d630 <BS>
    3926:	ff 50 60             	call   *0x60(%rax)
            uefi_call_wrapper(BS->CloseEvent, 1, TimerEvent);
    3929:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
            Status = uefi_call_wrapper(BS->WaitForEvent, 3, 2, WaitList, &Index);
    392e:	49 89 c4             	mov    %rax,%r12
            uefi_call_wrapper(BS->CloseEvent, 1, TimerEvent);
    3931:	48 8b 05 f8 9c 01 00 	mov    0x19cf8(%rip),%rax        # 1d630 <BS>
    3938:	ff 50 70             	call   *0x70(%rax)

            //
            // If the timer expired, change the return to timed out
            //

            if (!EFI_ERROR(Status)  &&  Index == 1) {
    393b:	4d 85 e4             	test   %r12,%r12
    393e:	78 14                	js     3954 <WaitForSingleEvent+0xb4>
                Status = EFI_TIMEOUT;
    3940:	48 b8 12 00 00 00 00 	movabs $0x8000000000000012,%rax
    3947:	00 00 80 
    394a:	48 83 7c 24 40 01    	cmpq   $0x1,0x40(%rsp)
    3950:	4c 0f 44 e0          	cmove  %rax,%r12
        ASSERT (!EFI_ERROR(Status));
        ASSERT (Index == 0);
    }

    return Status;
}
    3954:	48 83 c4 68          	add    $0x68,%rsp
    3958:	4c 89 e0             	mov    %r12,%rax
    395b:	5b                   	pop    %rbx
    395c:	41 5c                	pop    %r12
    395e:	c3                   	ret    
    395f:	90                   	nop
        Status = uefi_call_wrapper(BS->WaitForEvent, 3, 1, &Event, &Index);
    3960:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
    3965:	4c 8d 44 24 40       	lea    0x40(%rsp),%r8
    396a:	b9 01 00 00 00       	mov    $0x1,%ecx
    396f:	ff 50 60             	call   *0x60(%rax)
}
    3972:	48 83 c4 68          	add    $0x68,%rsp
        Status = uefi_call_wrapper(BS->WaitForEvent, 3, 1, &Event, &Index);
    3976:	49 89 c4             	mov    %rax,%r12
}
    3979:	5b                   	pop    %rbx
    397a:	4c 89 e0             	mov    %r12,%rax
    397d:	41 5c                	pop    %r12
    397f:	c3                   	ret    

0000000000003980 <WaitForEventWithTimeout>:
    IN  UINTN           Column,
    IN  CHAR16          *String,
    IN  EFI_INPUT_KEY   TimeoutKey,
    OUT EFI_INPUT_KEY   *Key
    )
{
    3980:	f3 0f 1e fa          	endbr64 
    3984:	41 57                	push   %r15
    3986:	41 56                	push   %r14
    3988:	49 89 fe             	mov    %rdi,%r14
    398b:	41 55                	push   %r13
    398d:	49 89 d5             	mov    %rdx,%r13
    3990:	41 54                	push   %r12
    3992:	49 89 cc             	mov    %rcx,%r12
    3995:	55                   	push   %rbp
    3996:	4c 89 c5             	mov    %r8,%rbp
    3999:	53                   	push   %rbx
    399a:	48 89 f3             	mov    %rsi,%rbx
    399d:	48 83 ec 38          	sub    $0x38,%rsp
    39a1:	44 89 4c 24 2c       	mov    %r9d,0x2c(%rsp)
    39a6:	4c 8b 7c 24 70       	mov    0x70(%rsp),%r15
    39ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    EFI_STATUS      Status;

    do {
        PrintAt (Column, Row, String, Timeout);
    39b0:	4c 89 ee             	mov    %r13,%rsi
    39b3:	4c 89 e7             	mov    %r12,%rdi
    39b6:	31 c0                	xor    %eax,%eax
    39b8:	48 89 d9             	mov    %rbx,%rcx
    39bb:	48 89 ea             	mov    %rbp,%rdx
    39be:	e8 1d 36 00 00       	call   6fe0 <PrintAt>
        Status = WaitForSingleEvent (Event, 10000000);
    39c3:	be 80 96 98 00       	mov    $0x989680,%esi
    39c8:	4c 89 f7             	mov    %r14,%rdi
    39cb:	e8 d0 fe ff ff       	call   38a0 <WaitForSingleEvent>
        if (Status == EFI_SUCCESS) {
    39d0:	48 85 c0             	test   %rax,%rax
    39d3:	75 19                	jne    39ee <WaitForEventWithTimeout+0x6e>
            if (!EFI_ERROR(uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, Key))) {
    39d5:	48 8b 05 5c 9c 01 00 	mov    0x19c5c(%rip),%rax        # 1d638 <ST>
    39dc:	4c 89 fa             	mov    %r15,%rdx
    39df:	48 8b 40 30          	mov    0x30(%rax),%rax
    39e3:	48 89 c1             	mov    %rax,%rcx
    39e6:	ff 50 08             	call   *0x8(%rax)
    39e9:	48 85 c0             	test   %rax,%rax
    39ec:	79 18                	jns    3a06 <WaitForEventWithTimeout+0x86>
                return;
            }
        }
    } while (Timeout > 0);
    39ee:	48 85 db             	test   %rbx,%rbx
    39f1:	75 bd                	jne    39b0 <WaitForEventWithTimeout+0x30>
    CopyMem(Key, &TimeoutKey, sizeof(EFI_INPUT_KEY));
    39f3:	48 8d 54 24 2c       	lea    0x2c(%rsp),%rdx
    39f8:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    39fe:	4c 89 f9             	mov    %r15,%rcx
    3a01:	e8 3a 10 00 00       	call   4a40 <CopyMem>
}
    3a06:	48 83 c4 38          	add    $0x38,%rsp
    3a0a:	5b                   	pop    %rbx
    3a0b:	5d                   	pop    %rbp
    3a0c:	41 5c                	pop    %r12
    3a0e:	41 5d                	pop    %r13
    3a10:	41 5e                	pop    %r14
    3a12:	41 5f                	pop    %r15
    3a14:	c3                   	ret    
    3a15:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    3a1c:	00 00 00 
    3a1f:	90                   	nop

0000000000003a20 <Exit>:
Exit(
    IN EFI_STATUS   ExitStatus,
    IN UINTN        ExitDataSize,
    IN CHAR16       *ExitData OPTIONAL
    )
{
    3a20:	f3 0f 1e fa          	endbr64 
    3a24:	50                   	push   %rax
    3a25:	58                   	pop    %rax
    3a26:	48 83 ec 28          	sub    $0x28,%rsp
    uefi_call_wrapper(BS->Exit,
    3a2a:	48 8b 05 ff 9b 01 00 	mov    0x19bff(%rip),%rax        # 1d630 <BS>
{
    3a31:	49 89 d1             	mov    %rdx,%r9
    uefi_call_wrapper(BS->Exit,
    3a34:	48 8b 0d 05 9c 01 00 	mov    0x19c05(%rip),%rcx        # 1d640 <LibImageHandle>
{
    3a3b:	49 89 f0             	mov    %rsi,%r8
    uefi_call_wrapper(BS->Exit,
    3a3e:	48 89 fa             	mov    %rdi,%rdx
    3a41:	ff 90 d8 00 00 00    	call   *0xd8(%rax)
            ExitStatus,
            ExitDataSize,
            ExitData);

    // Uh oh, Exit() returned?!
    for (;;) { }
    3a47:	eb fe                	jmp    3a47 <Exit+0x27>
    3a49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003a50 <LibLocateHandle>:
    IN VOID                         *SearchKey OPTIONAL,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    )

{
    3a50:	f3 0f 1e fa          	endbr64 
    3a54:	41 57                	push   %r15
    3a56:	41 56                	push   %r14
    3a58:	41 55                	push   %r13
    3a5a:	41 89 fd             	mov    %edi,%r13d
    3a5d:	41 54                	push   %r12
    3a5f:	49 89 f4             	mov    %rsi,%r12
    3a62:	55                   	push   %rbp
    3a63:	48 89 d5             	mov    %rdx,%rbp

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    3a66:	ba 90 01 00 00       	mov    $0x190,%edx
{
    3a6b:	53                   	push   %rbx
    3a6c:	4c 89 c3             	mov    %r8,%rbx
    3a6f:	48 83 ec 58          	sub    $0x58,%rsp
    *Buffer = NULL;
    3a73:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
{
    3a7a:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    3a7f:	4c 8d 74 24 40       	lea    0x40(%rsp),%r14

        Status = uefi_call_wrapper(
    3a84:	4c 8d 7c 24 48       	lea    0x48(%rsp),%r15
    Status = EFI_SUCCESS;
    3a89:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    3a90:	00 00 
    BufferSize = 50 * sizeof(EFI_HANDLE);
    3a92:	48 c7 44 24 48 90 01 	movq   $0x190,0x48(%rsp)
    3a99:	00 00 
    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    3a9b:	eb 2e                	jmp    3acb <LibLocateHandle+0x7b>
    3a9d:	0f 1f 00             	nopl   (%rax)
        Status = uefi_call_wrapper(
    3aa0:	48 8b 03             	mov    (%rbx),%rax
    3aa3:	4c 89 e2             	mov    %r12,%rdx
    3aa6:	4d 89 f9             	mov    %r15,%r9
    3aa9:	49 89 e8             	mov    %rbp,%r8
    3aac:	44 89 e9             	mov    %r13d,%ecx
    3aaf:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    3ab4:	48 8b 05 75 9b 01 00 	mov    0x19b75(%rip),%rax        # 1d630 <BS>
    3abb:	ff 90 b0 00 00 00    	call   *0xb0(%rax)
    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    3ac1:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
        Status = uefi_call_wrapper(
    3ac6:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    while (GrowBuffer (&Status, (VOID **) Buffer, BufferSize)) {
    3acb:	48 89 de             	mov    %rbx,%rsi
    3ace:	4c 89 f7             	mov    %r14,%rdi
    3ad1:	e8 2a 10 00 00       	call   4b00 <GrowBuffer>
    3ad6:	84 c0                	test   %al,%al
    3ad8:	75 c6                	jne    3aa0 <LibLocateHandle+0x50>
                        );

    }

    *NoHandles = BufferSize / sizeof (EFI_HANDLE);
    if (EFI_ERROR(Status)) {
    3ada:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
    *NoHandles = BufferSize / sizeof (EFI_HANDLE);
    3adf:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    3ae4:	31 d2                	xor    %edx,%edx
    3ae6:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    3aeb:	48 c1 e8 03          	shr    $0x3,%rax
    3aef:	4d 85 c0             	test   %r8,%r8
    3af2:	48 0f 48 c2          	cmovs  %rdx,%rax
    3af6:	48 89 01             	mov    %rax,(%rcx)
        *NoHandles = 0;
    }

    return Status;
}
    3af9:	48 83 c4 58          	add    $0x58,%rsp
    3afd:	4c 89 c0             	mov    %r8,%rax
    3b00:	5b                   	pop    %rbx
    3b01:	5d                   	pop    %rbp
    3b02:	41 5c                	pop    %r12
    3b04:	41 5d                	pop    %r13
    3b06:	41 5e                	pop    %r14
    3b08:	41 5f                	pop    %r15
    3b0a:	c3                   	ret    
    3b0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003b10 <LibLocateProtocol>:
{
    3b10:	f3 0f 1e fa          	endbr64 
    3b14:	41 55                	push   %r13
    Status = LibLocateHandle (ByProtocol, ProtocolGuid, NULL, &NumberHandles, &Handles);
    3b16:	31 d2                	xor    %edx,%edx
{
    3b18:	41 54                	push   %r12
    3b1a:	49 89 f4             	mov    %rsi,%r12
    3b1d:	55                   	push   %rbp
    3b1e:	48 89 fd             	mov    %rdi,%rbp
    3b21:	53                   	push   %rbx
    3b22:	48 83 ec 48          	sub    $0x48,%rsp
    *Interface = NULL;
    3b26:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
    Status = LibLocateHandle (ByProtocol, ProtocolGuid, NULL, &NumberHandles, &Handles);
    3b2d:	48 89 fe             	mov    %rdi,%rsi
    3b30:	bf 02 00 00 00       	mov    $0x2,%edi
    3b35:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
    3b3a:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    3b3f:	e8 0c ff ff ff       	call   3a50 <LibLocateHandle>
    if (EFI_ERROR(Status)) {
    3b44:	48 85 c0             	test   %rax,%rax
    3b47:	78 5a                	js     3ba3 <LibLocateProtocol+0x93>
    for (Index=0; Index < NumberHandles; Index++) {
    3b49:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13
    3b4e:	4d 85 ed             	test   %r13,%r13
    3b51:	74 37                	je     3b8a <LibLocateProtocol+0x7a>
    3b53:	31 db                	xor    %ebx,%ebx
    3b55:	eb 12                	jmp    3b69 <LibLocateProtocol+0x59>
    3b57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3b5e:	00 00 
    3b60:	48 83 c3 01          	add    $0x1,%rbx
    3b64:	4c 39 eb             	cmp    %r13,%rbx
    3b67:	74 21                	je     3b8a <LibLocateProtocol+0x7a>
        Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handles[Index], ProtocolGuid, Interface);
    3b69:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    3b6e:	4d 89 e0             	mov    %r12,%r8
    3b71:	48 89 ea             	mov    %rbp,%rdx
    3b74:	48 8b 0c d8          	mov    (%rax,%rbx,8),%rcx
    3b78:	48 8b 05 b1 9a 01 00 	mov    0x19ab1(%rip),%rax        # 1d630 <BS>
    3b7f:	ff 90 98 00 00 00    	call   *0x98(%rax)
        if (!EFI_ERROR(Status)) {
    3b85:	48 85 c0             	test   %rax,%rax
    3b88:	78 d6                	js     3b60 <LibLocateProtocol+0x50>
    if (Handles) {
    3b8a:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    3b8f:	48 85 ff             	test   %rdi,%rdi
    3b92:	74 0f                	je     3ba3 <LibLocateProtocol+0x93>
    3b94:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
        FreePool (Handles);
    3b99:	e8 c2 0d 00 00       	call   4960 <FreePool>
    3b9e:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
}
    3ba3:	48 83 c4 48          	add    $0x48,%rsp
    3ba7:	5b                   	pop    %rbx
    3ba8:	5d                   	pop    %rbp
    3ba9:	41 5c                	pop    %r12
    3bab:	41 5d                	pop    %r13
    3bad:	c3                   	ret    
    3bae:	66 90                	xchg   %ax,%ax

0000000000003bb0 <LibLocateHandleByDiskSignature>:
    IN VOID                         *Signature,
    IN OUT UINTN                    *NoHandles,
    OUT EFI_HANDLE                  **Buffer
    )

{
    3bb0:	f3 0f 1e fa          	endbr64 
    3bb4:	41 57                	push   %r15

        //
        // Get list of device handles that support the BLOCK_IO Protocol.
        //

        Status = uefi_call_wrapper(
    3bb6:	4c 8d 3d c3 91 01 00 	lea    0x191c3(%rip),%r15        # 1cd80 <gEfiBlockIoProtocolGuid>
{
    3bbd:	41 56                	push   %r14
    3bbf:	41 55                	push   %r13
    3bc1:	41 54                	push   %r12
    3bc3:	55                   	push   %rbp
    3bc4:	53                   	push   %rbx
    3bc5:	48 89 cb             	mov    %rcx,%rbx
    3bc8:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    3bcf:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
    3bd4:	4c 8d 64 24 70       	lea    0x70(%rsp),%r12
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    3bd9:	ba 90 01 00 00       	mov    $0x190,%edx
    3bde:	48 8d 6c 24 60       	lea    0x60(%rsp),%rbp
{
    3be3:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
    3be8:	40 88 7c 24 40       	mov    %dil,0x40(%rsp)
    3bed:	40 88 74 24 5d       	mov    %sil,0x5d(%rsp)
    Status = EFI_SUCCESS;
    3bf2:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
    3bf9:	00 00 
    BlockIoBuffer = NULL;
    3bfb:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
    3c02:	00 00 
    BufferSize = 50 * sizeof(EFI_HANDLE);
    3c04:	48 c7 44 24 68 90 01 	movq   $0x190,0x68(%rsp)
    3c0b:	00 00 
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    3c0d:	eb 32                	jmp    3c41 <LibLocateHandleByDiskSignature+0x91>
    3c0f:	90                   	nop
        Status = uefi_call_wrapper(
    3c10:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
    3c15:	4c 89 fa             	mov    %r15,%rdx
    3c18:	4c 8d 4c 24 68       	lea    0x68(%rsp),%r9
    3c1d:	45 31 c0             	xor    %r8d,%r8d
    3c20:	b9 02 00 00 00       	mov    $0x2,%ecx
    3c25:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    3c2a:	48 8b 05 ff 99 01 00 	mov    0x199ff(%rip),%rax        # 1d630 <BS>
    3c31:	ff 90 b0 00 00 00    	call   *0xb0(%rax)
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    3c37:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
        Status = uefi_call_wrapper(
    3c3c:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    while (GrowBuffer (&Status, (VOID **)&BlockIoBuffer, BufferSize)) {
    3c41:	4c 89 e6             	mov    %r12,%rsi
    3c44:	48 89 ef             	mov    %rbp,%rdi
    3c47:	e8 b4 0e 00 00       	call   4b00 <GrowBuffer>
    3c4c:	84 c0                	test   %al,%al
    3c4e:	75 c0                	jne    3c10 <LibLocateHandleByDiskSignature+0x60>
                        );

    }

    NoBlockIoHandles = BufferSize / sizeof (EFI_HANDLE);
    if (EFI_ERROR(Status)) {
    3c50:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    //
    // If there was an error or there are no device handles that support 
    // the BLOCK_IO Protocol, then return.
    //

    if (NoBlockIoHandles == 0) {
    3c55:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
        Status = uefi_call_wrapper(
    3c5a:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    if (EFI_ERROR(Status)) {
    3c5f:	48 c1 e8 3f          	shr    $0x3f,%rax
    if (NoBlockIoHandles == 0) {
    3c63:	48 c1 ed 03          	shr    $0x3,%rbp
    3c67:	0f 94 c2             	sete   %dl
    3c6a:	08 c2                	or     %al,%dl
    3c6c:	0f 85 ec 01 00 00    	jne    3e5e <LibLocateHandleByDiskSignature+0x2ae>

    //
    // Loop through all the device handles that support the BLOCK_IO Protocol
    //

    *NoHandles = 0;
    3c72:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)

    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3c79:	45 31 ed             	xor    %r13d,%r13d
    3c7c:	4c 8d 74 24 78       	lea    0x78(%rsp),%r14
    3c81:	4c 8d 3d 68 91 01 00 	lea    0x19168(%rip),%r15        # 1cdf0 <gEfiDevicePathProtocolGuid>
    3c88:	eb 25                	jmp    3caf <LibLocateHandleByDiskSignature+0xff>
    3c8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            }

        }

        if (Match == FALSE) {
            BlockIoBuffer[Index] = NULL;
    3c90:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3c95:	49 83 c5 01          	add    $0x1,%r13
            BlockIoBuffer[Index] = NULL;
    3c99:	4a c7 04 20 00 00 00 	movq   $0x0,(%rax,%r12,1)
    3ca0:	00 
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3ca1:	4c 39 ed             	cmp    %r13,%rbp
    3ca4:	0f 86 38 01 00 00    	jbe    3de2 <LibLocateHandleByDiskSignature+0x232>
    3caa:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
        Status = uefi_call_wrapper(
    3caf:	48 8b 05 7a 99 01 00 	mov    0x1997a(%rip),%rax        # 1d630 <BS>
    3cb6:	4c 89 fa             	mov    %r15,%rdx
    3cb9:	4a 8b 0c ef          	mov    (%rdi,%r13,8),%rcx
    3cbd:	4d 89 f0             	mov    %r14,%r8
    3cc0:	4e 8d 24 ed 00 00 00 	lea    0x0(,%r13,8),%r12
    3cc7:	00 
    3cc8:	ff 90 98 00 00 00    	call   *0x98(%rax)
        if (DevicePath != NULL) {
    3cce:	48 8b 54 24 78       	mov    0x78(%rsp),%rdx
        Status = uefi_call_wrapper(
    3cd3:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
        if (DevicePath != NULL) {
    3cd8:	48 85 d2             	test   %rdx,%rdx
    3cdb:	74 b3                	je     3c90 <LibLocateHandleByDiskSignature+0xe0>
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3cdd:	0f b6 02             	movzbl (%rdx),%eax
            PreviousNodeIsHardDriveDevicePath = FALSE;
    3ce0:	31 c9                	xor    %ecx,%ecx
        Match = FALSE;
    3ce2:	45 31 c0             	xor    %r8d,%r8d
    3ce5:	0f 1f 00             	nopl   (%rax)
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3ce8:	83 e0 7f             	and    $0x7f,%eax
    3ceb:	3c 04                	cmp    $0x4,%al
    3ced:	74 17                	je     3d06 <LibLocateHandleByDiskSignature+0x156>
                    PreviousNodeIsHardDriveDevicePath = FALSE;
    3cef:	31 c9                	xor    %ecx,%ecx
                if (IsDevicePathEnd(DevPath)) {
    3cf1:	3c 7f                	cmp    $0x7f,%al
    3cf3:	74 2b                	je     3d20 <LibLocateHandleByDiskSignature+0x170>
    3cf5:	0f b7 72 02          	movzwl 0x2(%rdx),%esi
                DevPath = NextDevicePathNode(DevPath);
    3cf9:	48 01 f2             	add    %rsi,%rdx
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3cfc:	0f b6 02             	movzbl (%rdx),%eax
    3cff:	83 e0 7f             	and    $0x7f,%eax
    3d02:	3c 04                	cmp    $0x4,%al
    3d04:	75 e9                	jne    3cef <LibLocateHandleByDiskSignature+0x13f>
                        Next = NextDevicePathNode(DevPath);
    3d06:	0f b7 72 02          	movzwl 0x2(%rdx),%esi
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3d0a:	80 7a 01 01          	cmpb   $0x1,0x1(%rdx)
                        Next = NextDevicePathNode(DevPath);
    3d0e:	48 8d 3c 32          	lea    (%rdx,%rsi,1),%rdi
                        if (IsDevicePathEndType(Next)) {
    3d12:	0f b6 07             	movzbl (%rdi),%eax
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3d15:	74 29                	je     3d40 <LibLocateHandleByDiskSignature+0x190>
                    PreviousNodeIsHardDriveDevicePath = FALSE;
    3d17:	31 c9                	xor    %ecx,%ecx
                                    switch(SignatureType) {
    3d19:	48 89 fa             	mov    %rdi,%rdx
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3d1c:	eb ca                	jmp    3ce8 <LibLocateHandleByDiskSignature+0x138>
    3d1e:	66 90                	xchg   %ax,%ax
                if (IsDevicePathEnd(DevPath)) {
    3d20:	80 7a 01 ff          	cmpb   $0xff,0x1(%rdx)
    3d24:	0f 84 9e 00 00 00    	je     3dc8 <LibLocateHandleByDiskSignature+0x218>
                DevPath = NextDevicePathNode(DevPath);
    3d2a:	0f b7 42 02          	movzwl 0x2(%rdx),%eax
    3d2e:	48 01 c2             	add    %rax,%rdx
                if ((DevicePathType(DevPath) == MEDIA_DEVICE_PATH) &&
    3d31:	0f b6 02             	movzbl (%rdx),%eax
    3d34:	eb b2                	jmp    3ce8 <LibLocateHandleByDiskSignature+0x138>
    3d36:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    3d3d:	00 00 00 
                    if (PreviousNodeIsHardDriveDevicePath == FALSE) {
    3d40:	84 c9                	test   %cl,%cl
    3d42:	75 d5                	jne    3d19 <LibLocateHandleByDiskSignature+0x169>
                        if (IsDevicePathEndType(Next)) {
    3d44:	41 89 c1             	mov    %eax,%r9d
                    PreviousNodeIsHardDriveDevicePath = TRUE;
    3d47:	b9 01 00 00 00       	mov    $0x1,%ecx
                        if (IsDevicePathEndType(Next)) {
    3d4c:	41 83 e1 7f          	and    $0x7f,%r9d
    3d50:	41 80 f9 7f          	cmp    $0x7f,%r9b
    3d54:	75 c3                	jne    3d19 <LibLocateHandleByDiskSignature+0x169>
                            if ((HardDriveDevicePath->MBRType == MBRType) &&
    3d56:	44 0f b6 54 24 40    	movzbl 0x40(%rsp),%r10d
    3d5c:	44 38 52 28          	cmp    %r10b,0x28(%rdx)
    3d60:	75 b7                	jne    3d19 <LibLocateHandleByDiskSignature+0x169>
    3d62:	44 0f b6 5c 24 5d    	movzbl 0x5d(%rsp),%r11d
    3d68:	44 38 5a 29          	cmp    %r11b,0x29(%rdx)
    3d6c:	75 ab                	jne    3d19 <LibLocateHandleByDiskSignature+0x169>
                                    switch(SignatureType) {
    3d6e:	41 80 fb 01          	cmp    $0x1,%r11b
    3d72:	0f 84 3c 01 00 00    	je     3eb4 <LibLocateHandleByDiskSignature+0x304>
    3d78:	41 80 fb 02          	cmp    $0x2,%r11b
    3d7c:	0f 85 77 ff ff ff    	jne    3cf9 <LibLocateHandleByDiskSignature+0x149>
                                            if (CompareGuid((EFI_GUID *)Signature,(EFI_GUID *)(&(HardDriveDevicePath->Signature[0]))) == 0) {
    3d82:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    3d87:	48 8d 72 18          	lea    0x18(%rdx),%rsi
    3d8b:	88 4c 24 5f          	mov    %cl,0x5f(%rsp)
    3d8f:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    3d94:	44 88 44 24 5e       	mov    %r8b,0x5e(%rsp)
    3d99:	e8 b2 59 00 00       	call   9750 <CompareGuid>
    3d9e:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    3da3:	0f b6 4c 24 5f       	movzbl 0x5f(%rsp),%ecx
    3da8:	48 85 c0             	test   %rax,%rax
    3dab:	0f b6 02             	movzbl (%rdx),%eax
    3dae:	0f 85 f2 00 00 00    	jne    3ea6 <LibLocateHandleByDiskSignature+0x2f6>
                                                Match = TRUE;
    3db4:	83 e0 7f             	and    $0x7f,%eax
    3db7:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    3dbd:	e9 2f ff ff ff       	jmp    3cf1 <LibLocateHandleByDiskSignature+0x141>
    3dc2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if (Match == FALSE) {
    3dc8:	45 84 c0             	test   %r8b,%r8b
    3dcb:	0f 84 bf fe ff ff    	je     3c90 <LibLocateHandleByDiskSignature+0xe0>
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3dd1:	49 83 c5 01          	add    $0x1,%r13
        } else {
            *NoHandles = *NoHandles + 1;
    3dd5:	48 83 03 01          	addq   $0x1,(%rbx)
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3dd9:	4c 39 ed             	cmp    %r13,%rbp
    3ddc:	0f 87 c8 fe ff ff    	ja     3caa <LibLocateHandleByDiskSignature+0xfa>

    //
    // If there are no matches, then return
    //

    if (*NoHandles == 0) {
    3de2:	48 8b 03             	mov    (%rbx),%rax
    3de5:	48 85 c0             	test   %rax,%rax
    3de8:	0f 84 8f 00 00 00    	je     3e7d <LibLocateHandleByDiskSignature+0x2cd>

    //
    // Allocate space for the return buffer of device handles.
    //

    *Buffer = AllocatePool(*NoHandles * sizeof(EFI_HANDLE));
    3dee:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    3df5:	00 
    3df6:	e8 45 0a 00 00       	call   4840 <AllocatePool>
    3dfb:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    3e00:	48 89 07             	mov    %rax,(%rdi)

    if (*Buffer == NULL) {
    3e03:	48 85 c0             	test   %rax,%rax
    3e06:	0f 84 c0 00 00 00    	je     3ecc <LibLocateHandleByDiskSignature+0x31c>

    //
    // Build list of matching device handles.
    //

    *NoHandles = 0;
    3e0c:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        FreePool(BlockIoBuffer);
    3e13:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3e18:	31 c0                	xor    %eax,%eax
    3e1a:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
    3e1f:	90                   	nop
        if (BlockIoBuffer[Index] != NULL) {
    3e20:	48 8b 14 c7          	mov    (%rdi,%rax,8),%rdx
    3e24:	48 85 d2             	test   %rdx,%rdx
    3e27:	74 13                	je     3e3c <LibLocateHandleByDiskSignature+0x28c>
            (*Buffer)[*NoHandles] = BlockIoBuffer[Index];
    3e29:	48 8b 33             	mov    (%rbx),%rsi
    3e2c:	49 8b 08             	mov    (%r8),%rcx
    3e2f:	48 89 14 f1          	mov    %rdx,(%rcx,%rsi,8)
            *NoHandles = *NoHandles + 1;
        }
    }

    FreePool(BlockIoBuffer);
    3e33:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
            *NoHandles = *NoHandles + 1;
    3e38:	48 83 03 01          	addq   $0x1,(%rbx)
    for(Index=0;Index<NoBlockIoHandles;Index++) {
    3e3c:	48 83 c0 01          	add    $0x1,%rax
    3e40:	48 39 c5             	cmp    %rax,%rbp
    3e43:	77 db                	ja     3e20 <LibLocateHandleByDiskSignature+0x270>
    FreePool(BlockIoBuffer);
    3e45:	e8 16 0b 00 00       	call   4960 <FreePool>

    return EFI_SUCCESS;
    3e4a:	31 c0                	xor    %eax,%eax
}
    3e4c:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    3e53:	5b                   	pop    %rbx
    3e54:	5d                   	pop    %rbp
    3e55:	41 5c                	pop    %r12
    3e57:	41 5d                	pop    %r13
    3e59:	41 5e                	pop    %r14
    3e5b:	41 5f                	pop    %r15
    3e5d:	c3                   	ret    
        FreePool(BlockIoBuffer);
    3e5e:	e8 fd 0a 00 00       	call   4960 <FreePool>
        *Buffer = NULL;
    3e63:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        *NoHandles = 0;
    3e68:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *Buffer = NULL;
    3e6f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return Status;
    3e76:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    3e7b:	eb cf                	jmp    3e4c <LibLocateHandleByDiskSignature+0x29c>
        FreePool(BlockIoBuffer);
    3e7d:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    3e82:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    3e87:	e8 d4 0a 00 00       	call   4960 <FreePool>
        *Buffer = NULL;
    3e8c:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        *NoHandles = 0;
    3e91:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *Buffer = NULL;
    3e98:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return EFI_SUCCESS;
    3e9f:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    3ea4:	eb a6                	jmp    3e4c <LibLocateHandleByDiskSignature+0x29c>
    3ea6:	44 0f b6 44 24 5e    	movzbl 0x5e(%rsp),%r8d
    3eac:	83 e0 7f             	and    $0x7f,%eax
    3eaf:	e9 3d fe ff ff       	jmp    3cf1 <LibLocateHandleByDiskSignature+0x141>
                    PreviousNodeIsHardDriveDevicePath = TRUE;
    3eb4:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    3eb9:	8b 52 18             	mov    0x18(%rdx),%edx
    3ebc:	39 16                	cmp    %edx,(%rsi)
    3ebe:	0f b6 74 24 5d       	movzbl 0x5d(%rsp),%esi
    3ec3:	44 0f 44 c6          	cmove  %esi,%r8d
    3ec7:	e9 4d fe ff ff       	jmp    3d19 <LibLocateHandleByDiskSignature+0x169>
        FreePool(BlockIoBuffer);
    3ecc:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    3ed1:	e8 8a 0a 00 00       	call   4960 <FreePool>
        *Buffer = NULL;
    3ed6:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        *NoHandles = 0;
    3edb:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *Buffer = NULL;
    3ee2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return EFI_OUT_OF_RESOURCES;
    3ee9:	48 b8 09 00 00 00 00 	movabs $0x8000000000000009,%rax
    3ef0:	00 00 80 
    3ef3:	e9 54 ff ff ff       	jmp    3e4c <LibLocateHandleByDiskSignature+0x29c>
    3ef8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    3eff:	00 

0000000000003f00 <LibOpenRoot>:

EFI_FILE_HANDLE
LibOpenRoot (
    IN EFI_HANDLE               DeviceHandle
    )
{
    3f00:	f3 0f 1e fa          	endbr64 
    3f04:	48 83 ec 38          	sub    $0x38,%rsp

    //
    // File the file system interface to the device
    //

    Status = uefi_call_wrapper(BS->HandleProtocol, 3, DeviceHandle, &FileSystemProtocol, (VOID*)&Volume);
    3f08:	48 8b 05 21 97 01 00 	mov    0x19721(%rip),%rax        # 1d630 <BS>
{
    3f0f:	48 89 f9             	mov    %rdi,%rcx
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, DeviceHandle, &FileSystemProtocol, (VOID*)&Volume);
    3f12:	48 8d 15 27 8e 01 00 	lea    0x18e27(%rip),%rdx        # 1cd40 <gEfiSimpleFileSystemProtocolGuid>
    3f19:	4c 8d 44 24 20       	lea    0x20(%rsp),%r8
    3f1e:	ff 90 98 00 00 00    	call   *0x98(%rax)

    //
    // Open the root directory of the volume 
    //

    if (!EFI_ERROR(Status)) {
    3f24:	48 85 c0             	test   %rax,%rax
    3f27:	78 27                	js     3f50 <LibOpenRoot+0x50>
        Status = uefi_call_wrapper(Volume->OpenVolume, 2, Volume, &File);
    3f29:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    3f2e:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
    3f33:	48 89 c1             	mov    %rax,%rcx
    3f36:	ff 50 08             	call   *0x8(%rax)

    //
    // Done
    //

    return EFI_ERROR(Status) ? NULL : File;
    3f39:	48 85 c0             	test   %rax,%rax
    3f3c:	78 12                	js     3f50 <LibOpenRoot+0x50>
    3f3e:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
}
    3f43:	48 83 c4 38          	add    $0x38,%rsp
    3f47:	c3                   	ret    
    3f48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    3f4f:	00 
    return EFI_ERROR(Status) ? NULL : File;
    3f50:	31 c0                	xor    %eax,%eax
}
    3f52:	48 83 c4 38          	add    $0x38,%rsp
    3f56:	c3                   	ret    
    3f57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3f5e:	00 00 

0000000000003f60 <LibFileInfo>:

EFI_FILE_INFO *
LibFileInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    3f60:	f3 0f 1e fa          	endbr64 
    3f64:	41 55                	push   %r13

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3f66:	ba 18 01 00 00       	mov    $0x118,%edx
        Status = uefi_call_wrapper(
    3f6b:	4c 8d 2d 8e 8c 01 00 	lea    0x18c8e(%rip),%r13        # 1cc00 <gEfiFileInfoGuid>
{
    3f72:	41 54                	push   %r12
    3f74:	55                   	push   %rbp
    3f75:	53                   	push   %rbx
    3f76:	48 89 fb             	mov    %rdi,%rbx
    3f79:	48 83 ec 48          	sub    $0x48,%rsp
    Status = EFI_SUCCESS;
    3f7d:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    3f84:	00 00 
    Buffer = NULL;
    3f86:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    3f8b:	48 8d 6c 24 28       	lea    0x28(%rsp),%rbp
    3f90:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    3f97:	00 00 
    BufferSize = SIZE_OF_EFI_FILE_INFO + 200;
    3f99:	48 c7 44 24 38 18 01 	movq   $0x118,0x38(%rsp)
    3fa0:	00 00 
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3fa2:	eb 21                	jmp    3fc5 <LibFileInfo+0x65>
    3fa4:	0f 1f 40 00          	nopl   0x0(%rax)
        Status = uefi_call_wrapper(
    3fa8:	4c 89 ea             	mov    %r13,%rdx
    3fab:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    3fb0:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    3fb5:	48 89 d9             	mov    %rbx,%rcx
    3fb8:	ff 53 40             	call   *0x40(%rbx)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3fbb:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
        Status = uefi_call_wrapper(
    3fc0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3fc5:	4c 89 e6             	mov    %r12,%rsi
    3fc8:	48 89 ef             	mov    %rbp,%rdi
    3fcb:	e8 30 0b 00 00       	call   4b00 <GrowBuffer>
    3fd0:	84 c0                	test   %al,%al
    3fd2:	75 d4                	jne    3fa8 <LibFileInfo+0x48>
                    Buffer
                    );
    }

    return Buffer;
}
    3fd4:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    3fd9:	48 83 c4 48          	add    $0x48,%rsp
    3fdd:	5b                   	pop    %rbx
    3fde:	5d                   	pop    %rbp
    3fdf:	41 5c                	pop    %r12
    3fe1:	41 5d                	pop    %r13
    3fe3:	c3                   	ret    
    3fe4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    3feb:	00 00 00 00 
    3fef:	90                   	nop

0000000000003ff0 <LibFileSystemInfo>:
    
EFI_FILE_SYSTEM_INFO *
LibFileSystemInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    3ff0:	f3 0f 1e fa          	endbr64 
    3ff4:	41 55                	push   %r13

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    3ff6:	ba ec 00 00 00       	mov    $0xec,%edx
        Status = uefi_call_wrapper(
    3ffb:	4c 8d 2d ee 8b 01 00 	lea    0x18bee(%rip),%r13        # 1cbf0 <gEfiFileSystemInfoGuid>
{
    4002:	41 54                	push   %r12
    4004:	55                   	push   %rbp
    4005:	53                   	push   %rbx
    4006:	48 89 fb             	mov    %rdi,%rbx
    4009:	48 83 ec 48          	sub    $0x48,%rsp
    Status = EFI_SUCCESS;
    400d:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    4014:	00 00 
    Buffer = NULL;
    4016:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    401b:	48 8d 6c 24 28       	lea    0x28(%rsp),%rbp
    4020:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    4027:	00 00 
    BufferSize = SIZE_OF_EFI_FILE_SYSTEM_INFO + 200;
    4029:	48 c7 44 24 38 ec 00 	movq   $0xec,0x38(%rsp)
    4030:	00 00 
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    4032:	eb 21                	jmp    4055 <LibFileSystemInfo+0x65>
    4034:	0f 1f 40 00          	nopl   0x0(%rax)
        Status = uefi_call_wrapper(
    4038:	4c 89 ea             	mov    %r13,%rdx
    403b:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    4040:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    4045:	48 89 d9             	mov    %rbx,%rcx
    4048:	ff 53 40             	call   *0x40(%rbx)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    404b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
        Status = uefi_call_wrapper(
    4050:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    4055:	4c 89 e6             	mov    %r12,%rsi
    4058:	48 89 ef             	mov    %rbp,%rdi
    405b:	e8 a0 0a 00 00       	call   4b00 <GrowBuffer>
    4060:	84 c0                	test   %al,%al
    4062:	75 d4                	jne    4038 <LibFileSystemInfo+0x48>
                    Buffer
                    );
    }

    return Buffer;
}
    4064:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    4069:	48 83 c4 48          	add    $0x48,%rsp
    406d:	5b                   	pop    %rbx
    406e:	5d                   	pop    %rbp
    406f:	41 5c                	pop    %r12
    4071:	41 5d                	pop    %r13
    4073:	c3                   	ret    
    4074:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    407b:	00 00 00 00 
    407f:	90                   	nop

0000000000004080 <LibFileSystemVolumeLabelInfo>:

EFI_FILE_SYSTEM_VOLUME_LABEL_INFO *
LibFileSystemVolumeLabelInfo (
    IN EFI_FILE_HANDLE      FHand
    )
{
    4080:	f3 0f 1e fa          	endbr64 
    4084:	41 55                	push   %r13

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    4086:	ba c8 00 00 00       	mov    $0xc8,%edx
        Status = uefi_call_wrapper(
    408b:	4c 8d 2d 4e 8b 01 00 	lea    0x18b4e(%rip),%r13        # 1cbe0 <gEfiFileSystemVolumeLabelInfoIdGuid>
{
    4092:	41 54                	push   %r12
    4094:	55                   	push   %rbp
    4095:	53                   	push   %rbx
    4096:	48 89 fb             	mov    %rdi,%rbx
    4099:	48 83 ec 48          	sub    $0x48,%rsp
    Status = EFI_SUCCESS;
    409d:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    40a4:	00 00 
    Buffer = NULL;
    40a6:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    40ab:	48 8d 6c 24 28       	lea    0x28(%rsp),%rbp
    40b0:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    40b7:	00 00 
    BufferSize = SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO + 200;
    40b9:	48 c7 44 24 38 c8 00 	movq   $0xc8,0x38(%rsp)
    40c0:	00 00 
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    40c2:	eb 21                	jmp    40e5 <LibFileSystemVolumeLabelInfo+0x65>
    40c4:	0f 1f 40 00          	nopl   0x0(%rax)
        Status = uefi_call_wrapper(
    40c8:	4c 89 ea             	mov    %r13,%rdx
    40cb:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    40d0:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    40d5:	48 89 d9             	mov    %rbx,%rcx
    40d8:	ff 53 40             	call   *0x40(%rbx)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    40db:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
        Status = uefi_call_wrapper(
    40e0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    40e5:	4c 89 e6             	mov    %r12,%rsi
    40e8:	48 89 ef             	mov    %rbp,%rdi
    40eb:	e8 10 0a 00 00       	call   4b00 <GrowBuffer>
    40f0:	84 c0                	test   %al,%al
    40f2:	75 d4                	jne    40c8 <LibFileSystemVolumeLabelInfo+0x48>
                    Buffer
                    );
    }

    return Buffer;
}
    40f4:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    40f9:	48 83 c4 48          	add    $0x48,%rsp
    40fd:	5b                   	pop    %rbx
    40fe:	5d                   	pop    %rbp
    40ff:	41 5c                	pop    %r12
    4101:	41 5d                	pop    %r13
    4103:	c3                   	ret    
    4104:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    410b:	00 00 00 00 
    410f:	90                   	nop

0000000000004110 <LibInstallProtocolInterfaces>:
EFI_STATUS
LibInstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    )
{
    4110:	f3 0f 1e fa          	endbr64 
    4114:	41 56                	push   %r14
    //
    // Install the protocol interfaces
    //

    Index = 0;
    Status = EFI_SUCCESS;
    4116:	45 31 f6             	xor    %r14d,%r14d
{
    4119:	41 55                	push   %r13
    411b:	41 54                	push   %r12
    411d:	55                   	push   %rbp
    411e:	48 89 fd             	mov    %rdi,%rbp
    4121:	53                   	push   %rbx
    Index = 0;
    4122:	31 db                	xor    %ebx,%ebx
{
    4124:	48 83 ec 70          	sub    $0x70,%rsp
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    4128:	48 8b 05 01 95 01 00 	mov    0x19501(%rip),%rax        # 1d630 <BS>
{
    412f:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    4134:	b9 10 00 00 00       	mov    $0x10,%ecx
{
    4139:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    413e:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    4143:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    4148:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    414d:	ff 50 18             	call   *0x18(%rax)
    va_start (args, Handle);
    4150:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    4157:	00 
    OldHandle = *Handle;
    4158:	4c 8b 6d 00          	mov    0x0(%rbp),%r13
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    415c:	49 89 c4             	mov    %rax,%r12
    va_start (args, Handle);
    415f:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    4166:	00 
    4167:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    416c:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    4171:	48 89 44 24 38       	mov    %rax,0x38(%rsp)

    while (!EFI_ERROR(Status)) {
    4176:	eb 57                	jmp    41cf <LibInstallProtocolInterfaces+0xbf>
    4178:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    417f:	00 

        //
        // If protocol is NULL, then it's the end of the list
        //

        Protocol = va_arg(args, EFI_GUID *);
    4180:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    4185:	89 d1                	mov    %edx,%ecx
    4187:	8d 42 08             	lea    0x8(%rdx),%eax
    418a:	89 44 24 28          	mov    %eax,0x28(%rsp)
    418e:	4c 8b 14 0e          	mov    (%rsi,%rcx,1),%r10
        if (!Protocol) {
    4192:	4d 85 d2             	test   %r10,%r10
    4195:	74 6d                	je     4204 <LibInstallProtocolInterfaces+0xf4>
            break;
        }

        Interface = va_arg(args, VOID *);
    4197:	83 f8 2f             	cmp    $0x2f,%eax
    419a:	0f 87 19 01 00 00    	ja     42b9 <LibInstallProtocolInterfaces+0x1a9>
    41a0:	83 c2 10             	add    $0x10,%edx
    41a3:	48 01 f0             	add    %rsi,%rax
    41a6:	89 54 24 28          	mov    %edx,0x28(%rsp)
        //
        // Install it
        //

        DEBUG((D_INFO, "LibInstallProtocolInterface: %d %x\n", Protocol, Interface));
        Status = uefi_call_wrapper(BS->InstallProtocolInterface, 4, Handle, Protocol, EFI_NATIVE_INTERFACE, Interface);
    41aa:	4c 8b 08             	mov    (%rax),%r9
    41ad:	48 8b 05 7c 94 01 00 	mov    0x1947c(%rip),%rax        # 1d630 <BS>
    41b4:	45 31 c0             	xor    %r8d,%r8d
    41b7:	4c 89 d2             	mov    %r10,%rdx
    41ba:	48 89 e9             	mov    %rbp,%rcx
    41bd:	ff 90 80 00 00 00    	call   *0x80(%rax)
    41c3:	49 89 c6             	mov    %rax,%r14
        if (EFI_ERROR(Status)) {
    41c6:	48 85 c0             	test   %rax,%rax
    41c9:	78 5d                	js     4228 <LibInstallProtocolInterfaces+0x118>
            break;
        }

        Index += 1;
    41cb:	48 83 c3 01          	add    $0x1,%rbx
        Protocol = va_arg(args, EFI_GUID *);
    41cf:	8b 54 24 28          	mov    0x28(%rsp),%edx
    41d3:	83 fa 2f             	cmp    $0x2f,%edx
    41d6:	76 a8                	jbe    4180 <LibInstallProtocolInterfaces+0x70>
    41d8:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    41dd:	48 89 c2             	mov    %rax,%rdx
    41e0:	48 83 c0 08          	add    $0x8,%rax
    41e4:	4c 8b 12             	mov    (%rdx),%r10
    41e7:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
        if (!Protocol) {
    41ec:	4d 85 d2             	test   %r10,%r10
    41ef:	74 13                	je     4204 <LibInstallProtocolInterfaces+0xf4>
        Interface = va_arg(args, VOID *);
    41f1:	48 8d 50 08          	lea    0x8(%rax),%rdx
    41f5:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    41fa:	eb ae                	jmp    41aa <LibInstallProtocolInterfaces+0x9a>
    41fc:	0f 1f 40 00          	nopl   0x0(%rax)
            uefi_call_wrapper(BS->UninstallProtocolInterface, 3, *Handle, Protocol, Interface);

            Index -= 1;
        }        

        *Handle = OldHandle;
    4200:	4c 89 6d 00          	mov    %r13,0x0(%rbp)

    //
    // Done
    //

    uefi_call_wrapper(BS->RestoreTPL, 1, OldTpl);
    4204:	48 8b 05 25 94 01 00 	mov    0x19425(%rip),%rax        # 1d630 <BS>
    420b:	4c 89 e1             	mov    %r12,%rcx
    420e:	ff 50 20             	call   *0x20(%rax)
    return Status;
}
    4211:	48 83 c4 70          	add    $0x70,%rsp
    4215:	4c 89 f0             	mov    %r14,%rax
    4218:	5b                   	pop    %rbx
    4219:	5d                   	pop    %rbp
    421a:	41 5c                	pop    %r12
    421c:	41 5d                	pop    %r13
    421e:	41 5e                	pop    %r14
    4220:	c3                   	ret    
    4221:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        va_start (args, Handle);
    4228:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    422f:	00 
    4230:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    4237:	00 
    4238:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    423d:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    4242:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        while (Index) {
    4247:	48 85 db             	test   %rbx,%rbx
    424a:	75 46                	jne    4292 <LibInstallProtocolInterfaces+0x182>
    424c:	eb b2                	jmp    4200 <LibInstallProtocolInterfaces+0xf0>
    424e:	66 90                	xchg   %ax,%ax
            Protocol = va_arg(args, EFI_GUID *);
    4250:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    4255:	8d 48 08             	lea    0x8(%rax),%ecx
    4258:	89 c6                	mov    %eax,%esi
    425a:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
    425e:	4c 8b 0c 32          	mov    (%rdx,%rsi,1),%r9
            Interface = va_arg(args, VOID *);
    4262:	83 f9 2f             	cmp    $0x2f,%ecx
    4265:	77 4b                	ja     42b2 <LibInstallProtocolInterfaces+0x1a2>
    4267:	83 c0 10             	add    $0x10,%eax
    426a:	48 01 ca             	add    %rcx,%rdx
    426d:	89 44 24 28          	mov    %eax,0x28(%rsp)
            uefi_call_wrapper(BS->UninstallProtocolInterface, 3, *Handle, Protocol, Interface);
    4271:	48 8b 05 b8 93 01 00 	mov    0x193b8(%rip),%rax        # 1d630 <BS>
    4278:	4c 8b 02             	mov    (%rdx),%r8
    427b:	4c 89 ca             	mov    %r9,%rdx
    427e:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
    4282:	ff 90 90 00 00 00    	call   *0x90(%rax)
        while (Index) {
    4288:	48 83 eb 01          	sub    $0x1,%rbx
    428c:	0f 84 6e ff ff ff    	je     4200 <LibInstallProtocolInterfaces+0xf0>
            Protocol = va_arg(args, EFI_GUID *);
    4292:	8b 44 24 28          	mov    0x28(%rsp),%eax
    4296:	83 f8 2f             	cmp    $0x2f,%eax
    4299:	76 b5                	jbe    4250 <LibInstallProtocolInterfaces+0x140>
    429b:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    42a0:	4c 8b 08             	mov    (%rax),%r9
    42a3:	48 8d 50 08          	lea    0x8(%rax),%rdx
            Interface = va_arg(args, VOID *);
    42a7:	48 8d 42 08          	lea    0x8(%rdx),%rax
    42ab:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    42b0:	eb bf                	jmp    4271 <LibInstallProtocolInterfaces+0x161>
            Protocol = va_arg(args, EFI_GUID *);
    42b2:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    42b7:	eb ee                	jmp    42a7 <LibInstallProtocolInterfaces+0x197>
    42b9:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    42be:	e9 2e ff ff ff       	jmp    41f1 <LibInstallProtocolInterfaces+0xe1>
    42c3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    42ca:	00 00 00 00 
    42ce:	66 90                	xchg   %ax,%ax

00000000000042d0 <LibUninstallProtocolInterfaces>:
VOID
LibUninstallProtocolInterfaces (
    IN EFI_HANDLE           Handle,
    ...
    )
{
    42d0:	f3 0f 1e fa          	endbr64 
    42d4:	53                   	push   %rbx
    42d5:	48 89 fb             	mov    %rdi,%rbx
    42d8:	48 83 ec 70          	sub    $0x70,%rsp
    EFI_STATUS      Status;
    EFI_GUID        *Protocol;
    VOID            *Interface;

    
    va_start (args, Handle);
    42dc:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
    42e3:	00 
{
    42e4:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    va_start (args, Handle);
    42e9:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    42ee:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
{
    42f3:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    42f8:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    42fd:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    4302:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    va_start (args, Handle);
    4307:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    430e:	00 
    430f:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    4314:	eb 46                	jmp    435c <LibUninstallProtocolInterfaces+0x8c>
    4316:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    431d:	00 00 00 

        //
        // If protocol is NULL, then it's the end of the list
        //

        Protocol = va_arg(args, EFI_GUID *);
    4320:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    4325:	89 c6                	mov    %eax,%esi
    4327:	8d 48 08             	lea    0x8(%rax),%ecx
    432a:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
    432e:	4c 8b 0c 32          	mov    (%rdx,%rsi,1),%r9
        if (!Protocol) {
    4332:	4d 85 c9             	test   %r9,%r9
    4335:	74 59                	je     4390 <LibUninstallProtocolInterfaces+0xc0>
            break;
        }

        Interface = va_arg(args, VOID *);
    4337:	83 f9 2f             	cmp    $0x2f,%ecx
    433a:	77 5a                	ja     4396 <LibUninstallProtocolInterfaces+0xc6>
    433c:	83 c0 10             	add    $0x10,%eax
    433f:	48 01 ca             	add    %rcx,%rdx
    4342:	89 44 24 28          	mov    %eax,0x28(%rsp)

        //
        // Uninstall it
        //

        Status = uefi_call_wrapper(BS->UninstallProtocolInterface, 3, Handle, Protocol, Interface);
    4346:	48 8b 05 e3 92 01 00 	mov    0x192e3(%rip),%rax        # 1d630 <BS>
    434d:	4c 8b 02             	mov    (%rdx),%r8
    4350:	48 89 d9             	mov    %rbx,%rcx
    4353:	4c 89 ca             	mov    %r9,%rdx
    4356:	ff 90 90 00 00 00    	call   *0x90(%rax)
        Protocol = va_arg(args, EFI_GUID *);
    435c:	8b 44 24 28          	mov    0x28(%rsp),%eax
    4360:	83 f8 2f             	cmp    $0x2f,%eax
    4363:	76 bb                	jbe    4320 <LibUninstallProtocolInterfaces+0x50>
    4365:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    436a:	4c 8b 08             	mov    (%rax),%r9
    436d:	48 8d 50 08          	lea    0x8(%rax),%rdx
    4371:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
        if (!Protocol) {
    4376:	4d 85 c9             	test   %r9,%r9
    4379:	74 15                	je     4390 <LibUninstallProtocolInterfaces+0xc0>
        Interface = va_arg(args, VOID *);
    437b:	48 8d 42 08          	lea    0x8(%rdx),%rax
    437f:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    4384:	eb c0                	jmp    4346 <LibUninstallProtocolInterfaces+0x76>
    4386:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    438d:	00 00 00 
        if (EFI_ERROR(Status)) {
            DEBUG((D_ERROR, "LibUninstallProtocolInterfaces: failed %g, %r\n", Protocol, Handle));
        }
    }
    va_end (args);
}    
    4390:	48 83 c4 70          	add    $0x70,%rsp
    4394:	5b                   	pop    %rbx
    4395:	c3                   	ret    
        Protocol = va_arg(args, EFI_GUID *);
    4396:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    439b:	eb de                	jmp    437b <LibUninstallProtocolInterfaces+0xab>
    439d:	0f 1f 00             	nopl   (%rax)

00000000000043a0 <LibReinstallProtocolInterfaces>:
EFI_STATUS
LibReinstallProtocolInterfaces (
    IN OUT EFI_HANDLE           *Handle,
    ...
    )
{
    43a0:	f3 0f 1e fa          	endbr64 
    43a4:	41 55                	push   %r13
    //
    // Install the protocol interfaces
    //

    Index = 0;
    Status = EFI_SUCCESS;
    43a6:	45 31 ed             	xor    %r13d,%r13d
{
    43a9:	41 54                	push   %r12
    43ab:	55                   	push   %rbp
    43ac:	48 89 fd             	mov    %rdi,%rbp
    43af:	53                   	push   %rbx
    Index = 0;
    43b0:	31 db                	xor    %ebx,%ebx
{
    43b2:	48 83 ec 78          	sub    $0x78,%rsp
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    43b6:	48 8b 05 73 92 01 00 	mov    0x19273(%rip),%rax        # 1d630 <BS>
{
    43bd:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    43c2:	b9 10 00 00 00       	mov    $0x10,%ecx
{
    43c7:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    43cc:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    43d1:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    43d6:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    43db:	ff 50 18             	call   *0x18(%rax)
    va_start (args, Handle);
    43de:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    43e5:	00 
    OldTpl = uefi_call_wrapper(BS->RaiseTPL, 1, TPL_NOTIFY);
    43e6:	49 89 c4             	mov    %rax,%r12
    va_start (args, Handle);
    43e9:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    43f0:	00 
    43f1:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    43f6:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    43fb:	48 89 44 24 38       	mov    %rax,0x38(%rsp)

    while (!EFI_ERROR(Status)) {
    4400:	eb 6a                	jmp    446c <LibReinstallProtocolInterfaces+0xcc>
    4402:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

        //
        // If protocol is NULL, then it's the end of the list
        //

        Protocol = va_arg(args, EFI_GUID *);
    4408:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    440d:	89 c6                	mov    %eax,%esi
    440f:	8d 48 08             	lea    0x8(%rax),%ecx
    4412:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
    4416:	4c 8b 14 32          	mov    (%rdx,%rsi,1),%r10
        if (!Protocol) {
    441a:	4d 85 d2             	test   %r10,%r10
    441d:	0f 84 7d 00 00 00    	je     44a0 <LibReinstallProtocolInterfaces+0x100>
            break;
        }

        OldInterface = va_arg(args, VOID *);
    4423:	83 f9 2f             	cmp    $0x2f,%ecx
    4426:	0f 87 54 01 00 00    	ja     4580 <LibReinstallProtocolInterfaces+0x1e0>
    442c:	8d 70 10             	lea    0x10(%rax),%esi
    442f:	4c 8b 04 0a          	mov    (%rdx,%rcx,1),%r8
    4433:	89 74 24 28          	mov    %esi,0x28(%rsp)
        NewInterface = va_arg(args, VOID *);
    4437:	83 fe 2f             	cmp    $0x2f,%esi
    443a:	0f 87 36 01 00 00    	ja     4576 <LibReinstallProtocolInterfaces+0x1d6>
    4440:	83 c0 18             	add    $0x18,%eax
    4443:	48 01 f2             	add    %rsi,%rdx
    4446:	89 44 24 28          	mov    %eax,0x28(%rsp)

        //
        // Reinstall it
        //

        Status = uefi_call_wrapper(BS->ReinstallProtocolInterface, 4, Handle, Protocol, OldInterface, NewInterface);
    444a:	48 8b 05 df 91 01 00 	mov    0x191df(%rip),%rax        # 1d630 <BS>
    4451:	4c 8b 0a             	mov    (%rdx),%r9
    4454:	48 89 e9             	mov    %rbp,%rcx
    4457:	4c 89 d2             	mov    %r10,%rdx
    445a:	ff 90 88 00 00 00    	call   *0x88(%rax)
    4460:	49 89 c5             	mov    %rax,%r13
        if (EFI_ERROR(Status)) {
    4463:	48 85 c0             	test   %rax,%rax
    4466:	78 58                	js     44c0 <LibReinstallProtocolInterfaces+0x120>
            break;
        }

        Index += 1;
    4468:	48 83 c3 01          	add    $0x1,%rbx
        Protocol = va_arg(args, EFI_GUID *);
    446c:	8b 44 24 28          	mov    0x28(%rsp),%eax
    4470:	83 f8 2f             	cmp    $0x2f,%eax
    4473:	76 93                	jbe    4408 <LibReinstallProtocolInterfaces+0x68>
    4475:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    447a:	48 89 c2             	mov    %rax,%rdx
    447d:	48 83 c0 08          	add    $0x8,%rax
    4481:	4c 8b 12             	mov    (%rdx),%r10
    4484:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
        if (!Protocol) {
    4489:	4d 85 d2             	test   %r10,%r10
    448c:	74 12                	je     44a0 <LibReinstallProtocolInterfaces+0x100>
        OldInterface = va_arg(args, VOID *);
    448e:	4c 8b 00             	mov    (%rax),%r8
    4491:	48 8d 50 08          	lea    0x8(%rax),%rdx
        NewInterface = va_arg(args, VOID *);
    4495:	48 8d 42 08          	lea    0x8(%rdx),%rax
    4499:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    449e:	eb aa                	jmp    444a <LibReinstallProtocolInterfaces+0xaa>

    //
    // Done
    //

    uefi_call_wrapper(BS->RestoreTPL, 1, OldTpl);
    44a0:	48 8b 05 89 91 01 00 	mov    0x19189(%rip),%rax        # 1d630 <BS>
    44a7:	4c 89 e1             	mov    %r12,%rcx
    44aa:	ff 50 20             	call   *0x20(%rax)
    return Status;
}
    44ad:	48 83 c4 78          	add    $0x78,%rsp
    44b1:	4c 89 e8             	mov    %r13,%rax
    44b4:	5b                   	pop    %rbx
    44b5:	5d                   	pop    %rbp
    44b6:	41 5c                	pop    %r12
    44b8:	41 5d                	pop    %r13
    44ba:	c3                   	ret    
    44bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        va_start (args, Handle);
    44c0:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
    44c7:	00 
    44c8:	c7 44 24 28 08 00 00 	movl   $0x8,0x28(%rsp)
    44cf:	00 
    44d0:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    44d5:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    44da:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        while (Index) {
    44df:	48 85 db             	test   %rbx,%rbx
    44e2:	75 5d                	jne    4541 <LibReinstallProtocolInterfaces+0x1a1>
    44e4:	eb ba                	jmp    44a0 <LibReinstallProtocolInterfaces+0x100>
    44e6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    44ed:	00 00 00 
            Protocol = va_arg(args, EFI_GUID *);
    44f0:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    44f5:	8d 70 08             	lea    0x8(%rax),%esi
    44f8:	89 c1                	mov    %eax,%ecx
    44fa:	89 74 24 28          	mov    %esi,0x28(%rsp)
    44fe:	4c 8b 14 0a          	mov    (%rdx,%rcx,1),%r10
            OldInterface = va_arg(args, VOID *);
    4502:	83 fe 2f             	cmp    $0x2f,%esi
    4505:	77 61                	ja     4568 <LibReinstallProtocolInterfaces+0x1c8>
    4507:	8d 48 10             	lea    0x10(%rax),%ecx
    450a:	4c 8b 0c 32          	mov    (%rdx,%rsi,1),%r9
    450e:	89 4c 24 28          	mov    %ecx,0x28(%rsp)
            NewInterface = va_arg(args, VOID *);
    4512:	83 f9 2f             	cmp    $0x2f,%ecx
    4515:	77 58                	ja     456f <LibReinstallProtocolInterfaces+0x1cf>
    4517:	83 c0 18             	add    $0x18,%eax
    451a:	48 01 ca             	add    %rcx,%rdx
    451d:	89 44 24 28          	mov    %eax,0x28(%rsp)
            uefi_call_wrapper(BS->ReinstallProtocolInterface, 4, Handle, Protocol, NewInterface, OldInterface);
    4521:	48 8b 05 08 91 01 00 	mov    0x19108(%rip),%rax        # 1d630 <BS>
    4528:	4c 8b 02             	mov    (%rdx),%r8
    452b:	48 89 e9             	mov    %rbp,%rcx
    452e:	4c 89 d2             	mov    %r10,%rdx
    4531:	ff 90 88 00 00 00    	call   *0x88(%rax)
        while (Index) {
    4537:	48 83 eb 01          	sub    $0x1,%rbx
    453b:	0f 84 5f ff ff ff    	je     44a0 <LibReinstallProtocolInterfaces+0x100>
            Protocol = va_arg(args, EFI_GUID *);
    4541:	8b 44 24 28          	mov    0x28(%rsp),%eax
    4545:	83 f8 2f             	cmp    $0x2f,%eax
    4548:	76 a6                	jbe    44f0 <LibReinstallProtocolInterfaces+0x150>
    454a:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    454f:	4c 8b 12             	mov    (%rdx),%r10
    4552:	48 8d 42 08          	lea    0x8(%rdx),%rax
            OldInterface = va_arg(args, VOID *);
    4556:	4c 8b 08             	mov    (%rax),%r9
    4559:	48 8d 50 08          	lea    0x8(%rax),%rdx
            NewInterface = va_arg(args, VOID *);
    455d:	48 8d 42 08          	lea    0x8(%rdx),%rax
    4561:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    4566:	eb b9                	jmp    4521 <LibReinstallProtocolInterfaces+0x181>
            Protocol = va_arg(args, EFI_GUID *);
    4568:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    456d:	eb e7                	jmp    4556 <LibReinstallProtocolInterfaces+0x1b6>
    456f:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    4574:	eb e7                	jmp    455d <LibReinstallProtocolInterfaces+0x1bd>
        OldInterface = va_arg(args, VOID *);
    4576:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    457b:	e9 15 ff ff ff       	jmp    4495 <LibReinstallProtocolInterfaces+0xf5>
    4580:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    4585:	e9 04 ff ff ff       	jmp    448e <LibReinstallProtocolInterfaces+0xee>
    458a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000004590 <InitializeUnicodeSupport>:

VOID
InitializeUnicodeSupport (
    CHAR8 *LangCode
    )
{
    4590:	f3 0f 1e fa          	endbr64 
    4594:	41 57                	push   %r15

    //
    // If we don't know it, lookup the current language code
    //

    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    4596:	31 d2                	xor    %edx,%edx
{
    4598:	41 56                	push   %r14
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    459a:	4c 8d 35 6f 87 01 00 	lea    0x1876f(%rip),%r14        # 1cd10 <gEfiUnicodeCollationProtocolGuid>
{
    45a1:	41 55                	push   %r13
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    45a3:	4c 89 f6             	mov    %r14,%rsi
{
    45a6:	41 54                	push   %r12
    45a8:	55                   	push   %rbp
    45a9:	53                   	push   %rbx
    45aa:	48 89 fb             	mov    %rdi,%rbx
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    45ad:	bf 02 00 00 00       	mov    $0x2,%edi
{
    45b2:	48 83 ec 58          	sub    $0x58,%rsp
    LibLocateHandle (ByProtocol, &UnicodeCollationProtocol, NULL, &NoHandles, &Handles);
    45b6:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
    45bb:	4c 8d 44 24 48       	lea    0x48(%rsp),%r8
    45c0:	e8 8b f4 ff ff       	call   3a50 <LibLocateHandle>
    if (!LangCode || !NoHandles) {
    45c5:	48 85 db             	test   %rbx,%rbx
    45c8:	74 46                	je     4610 <InitializeUnicodeSupport+0x80>
    45ca:	48 83 7c 24 40 00    	cmpq   $0x0,0x40(%rsp)
    45d0:	74 3e                	je     4610 <InitializeUnicodeSupport+0x80>
    45d2:	48 8d 44 24 38       	lea    0x38(%rsp),%rax

    //
    // Check all driver's for a matching language code
    //

    for (Index=0; Index < NoHandles; Index++) {
    45d7:	45 31 ed             	xor    %r13d,%r13d
    45da:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
        Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handles[Index], &UnicodeCollationProtocol, (VOID*)&Ui);
    45df:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    45e4:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
    45e9:	4c 89 f2             	mov    %r14,%rdx
    45ec:	4a 8b 0c e8          	mov    (%rax,%r13,8),%rcx
    45f0:	48 8b 05 39 90 01 00 	mov    0x19039(%rip),%rax        # 1d630 <BS>
    45f7:	ff 90 98 00 00 00    	call   *0x98(%rax)
        if (EFI_ERROR(Status)) {
    45fd:	48 85 c0             	test   %rax,%rax
    4600:	79 2e                	jns    4630 <InitializeUnicodeSupport+0xa0>
    for (Index=0; Index < NoHandles; Index++) {
    4602:	49 83 c5 01          	add    $0x1,%r13
    4606:	4c 39 6c 24 40       	cmp    %r13,0x40(%rsp)
    460b:	77 d2                	ja     45df <InitializeUnicodeSupport+0x4f>
    460d:	0f 1f 00             	nopl   (%rax)
Done:
    //
    // Cleanup
    //

    if (Handles) {
    4610:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    4615:	48 85 ff             	test   %rdi,%rdi
    4618:	74 05                	je     461f <InitializeUnicodeSupport+0x8f>
        FreePool (Handles);
    461a:	e8 41 03 00 00       	call   4960 <FreePool>
    }
}
    461f:	48 83 c4 58          	add    $0x58,%rsp
    4623:	5b                   	pop    %rbx
    4624:	5d                   	pop    %rbp
    4625:	41 5c                	pop    %r12
    4627:	41 5d                	pop    %r13
    4629:	41 5e                	pop    %r14
    462b:	41 5f                	pop    %r15
    462d:	c3                   	ret    
    462e:	66 90                	xchg   %ax,%ax
        Languages = Ui->SupportedLanguages;
    4630:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    4635:	4c 8b 60 30          	mov    0x30(%rax),%r12
        Length = strlena(Languages);
    4639:	4c 89 e7             	mov    %r12,%rdi
    463c:	e8 cf 30 00 00       	call   7710 <strlena>
    4641:	48 89 c5             	mov    %rax,%rbp
        for (Position=0; Position < Length; Position += ISO_639_2_ENTRY_SIZE) {
    4644:	48 85 c0             	test   %rax,%rax
    4647:	74 b9                	je     4602 <InitializeUnicodeSupport+0x72>
    4649:	45 31 ff             	xor    %r15d,%r15d
    464c:	eb 0b                	jmp    4659 <InitializeUnicodeSupport+0xc9>
    464e:	66 90                	xchg   %ax,%ax
    4650:	49 83 c7 03          	add    $0x3,%r15
    4654:	4c 39 fd             	cmp    %r15,%rbp
    4657:	76 a9                	jbe    4602 <InitializeUnicodeSupport+0x72>
            if (CompareMem (Languages+Position, LangCode, ISO_639_2_ENTRY_SIZE) == 0) {
    4659:	4b 8d 3c 3c          	lea    (%r12,%r15,1),%rdi
    465d:	ba 03 00 00 00       	mov    $0x3,%edx
    4662:	48 89 de             	mov    %rbx,%rsi
    4665:	e8 86 04 00 00       	call   4af0 <CompareMem>
    466a:	48 85 c0             	test   %rax,%rax
    466d:	75 e1                	jne    4650 <InitializeUnicodeSupport+0xc0>
                UnicodeInterface = Ui;
    466f:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    4674:	48 89 05 a5 87 01 00 	mov    %rax,0x187a5(%rip)        # 1ce20 <UnicodeInterface>
                goto Done;
    467b:	eb 93                	jmp    4610 <InitializeUnicodeSupport+0x80>
    467d:	0f 1f 00             	nopl   (%rax)

0000000000004680 <EFIDebugVariable>:

VOID
EFIDebugVariable (
    VOID
    )
{
    4680:	f3 0f 1e fa          	endbr64 
    4684:	48 83 ec 58          	sub    $0x58,%rsp
    UINT32          Attributes;
    UINTN           DataSize;
    UINTN           NewEFIDebug;

    DataSize = sizeof(EFIDebug);
    Status = uefi_call_wrapper(RT->GetVariable, 5, L"EFIDebug", &EfiGlobalVariable, &Attributes, &DataSize, &NewEFIDebug);
    4688:	48 8d 15 71 87 01 00 	lea    0x18771(%rip),%rdx        # 1ce00 <gEfiGlobalVariableGuid>
    468f:	48 8d 0d 68 50 02 00 	lea    0x25068(%rip),%rcx        # 296fe <_DYNAMIC+0xb6fe>
    4696:	48 8d 44 24 48       	lea    0x48(%rsp),%rax
    469b:	4c 8d 4c 24 40       	lea    0x40(%rsp),%r9
    DataSize = sizeof(EFIDebug);
    46a0:	48 c7 44 24 40 08 00 	movq   $0x8,0x40(%rsp)
    46a7:	00 00 
    Status = uefi_call_wrapper(RT->GetVariable, 5, L"EFIDebug", &EfiGlobalVariable, &Attributes, &DataSize, &NewEFIDebug);
    46a9:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    46ae:	48 8b 05 bb 8f 01 00 	mov    0x18fbb(%rip),%rax        # 1d670 <RT>
    46b5:	4c 8d 44 24 3c       	lea    0x3c(%rsp),%r8
    46ba:	ff 50 48             	call   *0x48(%rax)
    if (!EFI_ERROR(Status)) {
    46bd:	48 85 c0             	test   %rax,%rax
    46c0:	78 0c                	js     46ce <EFIDebugVariable+0x4e>
        EFIDebug = NewEFIDebug;
    46c2:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    46c7:	48 89 05 62 8a 01 00 	mov    %rax,0x18a62(%rip)        # 1d130 <EFIDebug>
    }
}
    46ce:	48 83 c4 58          	add    $0x58,%rsp
    46d2:	c3                   	ret    
    46d3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    46da:	00 00 00 00 
    46de:	66 90                	xchg   %ax,%ax

00000000000046e0 <InitializeLib>:
{
    46e0:	f3 0f 1e fa          	endbr64 
    if (LibInitialized)
    46e4:	80 3d 5d 8f 01 00 00 	cmpb   $0x0,0x18f5d(%rip)        # 1d648 <LibInitialized>
    46eb:	0f 85 9f 00 00 00    	jne    4790 <InitializeLib+0xb0>
{
    46f1:	41 54                	push   %r12
    46f3:	49 89 fc             	mov    %rdi,%r12
    46f6:	55                   	push   %rbp
    46f7:	48 89 f5             	mov    %rsi,%rbp
    46fa:	48 83 ec 38          	sub    $0x38,%rsp
    BS = SystemTable->BootServices;
    46fe:	48 8b 46 60          	mov    0x60(%rsi),%rax
    RT = SystemTable->RuntimeServices;
    4702:	48 8b 56 58          	mov    0x58(%rsi),%rdx
    LibInitialized = TRUE;
    4706:	c6 05 3b 8f 01 00 01 	movb   $0x1,0x18f3b(%rip)        # 1d648 <LibInitialized>
    LibFwInstance = FALSE;
    470d:	c6 05 54 8f 01 00 00 	movb   $0x0,0x18f54(%rip)        # 1d668 <LibFwInstance>
    LibImageHandle = ImageHandle;
    4714:	48 89 3d 25 8f 01 00 	mov    %rdi,0x18f25(%rip)        # 1d640 <LibImageHandle>
    ST = SystemTable;
    471b:	48 89 35 16 8f 01 00 	mov    %rsi,0x18f16(%rip)        # 1d638 <ST>
    BS = SystemTable->BootServices;
    4722:	48 89 05 07 8f 01 00 	mov    %rax,0x18f07(%rip)        # 1d630 <BS>
    RT = SystemTable->RuntimeServices;
    4729:	48 89 15 40 8f 01 00 	mov    %rdx,0x18f40(%rip)        # 1d670 <RT>
    if (ImageHandle) {
    4730:	48 85 ff             	test   %rdi,%rdi
    4733:	74 63                	je     4798 <InitializeLib+0xb8>
	Status = uefi_call_wrapper(
    4735:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    473a:	48 8d 15 6f 86 01 00 	lea    0x1866f(%rip),%rdx        # 1cdb0 <gEfiLoadedImageProtocolGuid>
    4741:	48 89 f9             	mov    %rdi,%rcx
    4744:	ff 90 98 00 00 00    	call   *0x98(%rax)
	if (!EFI_ERROR(Status)) {
    474a:	48 85 c0             	test   %rax,%rax
    474d:	78 0e                	js     475d <InitializeLib+0x7d>
	    PoolAllocationType = LoadedImage->ImageDataType;
    474f:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    4754:	8b 40 54             	mov    0x54(%rax),%eax
    4757:	89 05 bf 86 01 00    	mov    %eax,0x186bf(%rip)        # 1ce1c <PoolAllocationType>
	EFIDebugVariable ();
    475d:	e8 1e ff ff ff       	call   4680 <EFIDebugVariable>
    InitializeGuid();
    4762:	e8 d9 4f 00 00       	call   9740 <InitializeGuid>
    InitializeLibPlatform(ImageHandle,SystemTable);
    4767:	48 89 ee             	mov    %rbp,%rsi
    476a:	4c 89 e7             	mov    %r12,%rdi
    476d:	e8 0e 38 00 00       	call   7f80 <InitializeLibPlatform>
    if (ImageHandle && UnicodeInterface == &LibStubUnicodeInterface) {
    4772:	48 8d 05 c7 86 01 00 	lea    0x186c7(%rip),%rax        # 1ce40 <LibStubUnicodeInterface>
    4779:	48 39 05 a0 86 01 00 	cmp    %rax,0x186a0(%rip)        # 1ce20 <UnicodeInterface>
    4780:	74 2e                	je     47b0 <InitializeLib+0xd0>
}
    4782:	48 83 c4 38          	add    $0x38,%rsp
    4786:	5d                   	pop    %rbp
    4787:	41 5c                	pop    %r12
    4789:	c3                   	ret    
    478a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    4790:	c3                   	ret    
    4791:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    InitializeGuid();
    4798:	e8 a3 4f 00 00       	call   9740 <InitializeGuid>
}
    479d:	48 83 c4 38          	add    $0x38,%rsp
    InitializeLibPlatform(ImageHandle,SystemTable);
    47a1:	48 89 ee             	mov    %rbp,%rsi
    47a4:	31 ff                	xor    %edi,%edi
}
    47a6:	5d                   	pop    %rbp
    47a7:	41 5c                	pop    %r12
    InitializeLibPlatform(ImageHandle,SystemTable);
    47a9:	e9 d2 37 00 00       	jmp    7f80 <InitializeLibPlatform>
    47ae:	66 90                	xchg   %ax,%ax
        LangCode = LibGetVariable (VarLanguage, &EfiGlobalVariable);
    47b0:	48 8d 3d 59 4f 02 00 	lea    0x24f59(%rip),%rdi        # 29710 <_DYNAMIC+0xb710>
    47b7:	48 8d 35 42 86 01 00 	lea    0x18642(%rip),%rsi        # 1ce00 <gEfiGlobalVariableGuid>
    47be:	e8 fd 05 00 00       	call   4dc0 <LibGetVariable>
    47c3:	48 89 c5             	mov    %rax,%rbp
        InitializeUnicodeSupport (LangCode);
    47c6:	48 89 c7             	mov    %rax,%rdi
    47c9:	e8 c2 fd ff ff       	call   4590 <InitializeUnicodeSupport>
        if (LangCode) {
    47ce:	48 85 ed             	test   %rbp,%rbp
    47d1:	74 af                	je     4782 <InitializeLib+0xa2>
            FreePool (LangCode);
    47d3:	48 89 ef             	mov    %rbp,%rdi
    47d6:	e8 85 01 00 00       	call   4960 <FreePool>
    47db:	eb a5                	jmp    4782 <InitializeLib+0xa2>
    47dd:	0f 1f 00             	nopl   (%rax)

00000000000047e0 <memset>:
#ifndef __SIZE_TYPE__
#define __SIZE_TYPE__ UINTN
#endif

void *memset(void *s, int c, __SIZE_TYPE__ n)
{
    47e0:	f3 0f 1e fa          	endbr64 
    47e4:	48 89 f8             	mov    %rdi,%rax
    47e7:	4c 8d 04 17          	lea    (%rdi,%rdx,1),%r8
    unsigned char *p = s;
    47eb:	48 89 f9             	mov    %rdi,%rcx

    while (n--)
    47ee:	48 85 d2             	test   %rdx,%rdx
    47f1:	74 12                	je     4805 <memset+0x25>
    47f3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        *p++ = c;
    47f8:	48 83 c1 01          	add    $0x1,%rcx
    47fc:	40 88 71 ff          	mov    %sil,-0x1(%rcx)
    while (n--)
    4800:	4c 39 c1             	cmp    %r8,%rcx
    4803:	75 f3                	jne    47f8 <memset+0x18>

    return s;
}
    4805:	c3                   	ret    
    4806:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    480d:	00 00 00 

0000000000004810 <memcpy>:

void *memcpy(void *dest, const void *src, __SIZE_TYPE__ n)
{
    4810:	f3 0f 1e fa          	endbr64 
    4814:	48 89 f8             	mov    %rdi,%rax
    const unsigned char *q = src;
    unsigned char *p = dest;

    while (n--)
    4817:	48 85 d2             	test   %rdx,%rdx
    481a:	74 16                	je     4832 <memcpy+0x22>
    481c:	31 c9                	xor    %ecx,%ecx
    481e:	66 90                	xchg   %ax,%ax
        *p++ = *q++;
    4820:	44 0f b6 04 0e       	movzbl (%rsi,%rcx,1),%r8d
    4825:	44 88 04 08          	mov    %r8b,(%rax,%rcx,1)
    while (n--)
    4829:	48 83 c1 01          	add    $0x1,%rcx
    482d:	48 39 d1             	cmp    %rdx,%rcx
    4830:	75 ee                	jne    4820 <memcpy+0x10>

    return dest;
}
    4832:	c3                   	ret    
    4833:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    483a:	00 00 00 
    483d:	0f 1f 00             	nopl   (%rax)

0000000000004840 <AllocatePool>:

VOID *
AllocatePool (
    IN UINTN                Size
    )
{
    4840:	f3 0f 1e fa          	endbr64 
    4844:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_STATUS              Status;
    VOID                    *p;

    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4848:	48 8b 05 e1 8d 01 00 	mov    0x18de1(%rip),%rax        # 1d630 <BS>
    484f:	8b 0d c7 85 01 00    	mov    0x185c7(%rip),%ecx        # 1ce1c <PoolAllocationType>
{
    4855:	48 89 fa             	mov    %rdi,%rdx
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4858:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    485d:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
        DEBUG((D_ERROR, "AllocatePool: out of pool  %x\n", Status));
        p = NULL;
    }
    return p;
    4860:	48 85 c0             	test   %rax,%rax
    4863:	b8 00 00 00 00       	mov    $0x0,%eax
    4868:	48 0f 49 44 24 28    	cmovns 0x28(%rsp),%rax
}
    486e:	48 83 c4 38          	add    $0x38,%rsp
    4872:	c3                   	ret    
    4873:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    487a:	00 00 00 00 
    487e:	66 90                	xchg   %ax,%ax

0000000000004880 <AllocateZeroPool>:

VOID *
AllocateZeroPool (
    IN UINTN                Size
    )
{
    4880:	f3 0f 1e fa          	endbr64 
    4884:	41 54                	push   %r12
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4886:	48 89 fa             	mov    %rdi,%rdx
    return p;
    4889:	45 31 e4             	xor    %r12d,%r12d
{
    488c:	55                   	push   %rbp
    488d:	48 89 fd             	mov    %rdi,%rbp
    4890:	48 83 ec 38          	sub    $0x38,%rsp
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4894:	48 8b 05 95 8d 01 00 	mov    0x18d95(%rip),%rax        # 1d630 <BS>
    489b:	8b 0d 7b 85 01 00    	mov    0x1857b(%rip),%ecx        # 1ce1c <PoolAllocationType>
    48a1:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    48a6:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    48a9:	48 85 c0             	test   %rax,%rax
    48ac:	78 15                	js     48c3 <AllocateZeroPool+0x43>
    return p;
    48ae:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
    VOID                    *p;

    p = AllocatePool (Size);
    if (p) {
    48b3:	4d 85 e4             	test   %r12,%r12
    48b6:	74 0b                	je     48c3 <AllocateZeroPool+0x43>
ZeroMem (
    IN VOID     *Buffer,
    IN UINTN    Size
    )
{
    RtZeroMem (Buffer, Size);
    48b8:	48 89 ee             	mov    %rbp,%rsi
    48bb:	4c 89 e7             	mov    %r12,%rdi
    48be:	e8 0d 32 00 00       	call   7ad0 <RtZeroMem>
}
    48c3:	48 83 c4 38          	add    $0x38,%rsp
    48c7:	4c 89 e0             	mov    %r12,%rax
    48ca:	5d                   	pop    %rbp
    48cb:	41 5c                	pop    %r12
    48cd:	c3                   	ret    
    48ce:	66 90                	xchg   %ax,%ax

00000000000048d0 <ReallocatePool>:
{
    48d0:	f3 0f 1e fa          	endbr64 
    48d4:	41 55                	push   %r13
    48d6:	41 54                	push   %r12
    48d8:	49 89 fc             	mov    %rdi,%r12
    48db:	55                   	push   %rbp
    48dc:	53                   	push   %rbx
    48dd:	48 83 ec 38          	sub    $0x38,%rsp
    if (NewSize) {
    48e1:	48 85 d2             	test   %rdx,%rdx
    48e4:	74 62                	je     4948 <ReallocatePool+0x78>
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    48e6:	48 8b 05 43 8d 01 00 	mov    0x18d43(%rip),%rax        # 1d630 <BS>
    48ed:	8b 0d 29 85 01 00    	mov    0x18529(%rip),%ecx        # 1ce1c <PoolAllocationType>
    48f3:	48 89 f5             	mov    %rsi,%rbp
    48f6:	48 89 d3             	mov    %rdx,%rbx
    48f9:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    48fe:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    4901:	48 85 c0             	test   %rax,%rax
    4904:	78 42                	js     4948 <ReallocatePool+0x78>
    return p;
    4906:	4c 8b 6c 24 28       	mov    0x28(%rsp),%r13
    if (OldPool) {
    490b:	4d 85 e4             	test   %r12,%r12
    490e:	74 27                	je     4937 <ReallocatePool+0x67>
        if (NewPool) {
    4910:	4d 85 ed             	test   %r13,%r13
    4913:	74 15                	je     492a <ReallocatePool+0x5a>
            CopyMem (NewPool, OldPool, OldSize < NewSize ? OldSize : NewSize);
    4915:	48 39 eb             	cmp    %rbp,%rbx
    4918:	48 89 ea             	mov    %rbp,%rdx
    IN VOID     *Dest,
    IN VOID     *Src,
    IN UINTN    len
    )
{
    RtCopyMem (Dest, Src, len);
    491b:	4c 89 e6             	mov    %r12,%rsi
    491e:	4c 89 ef             	mov    %r13,%rdi
            CopyMem (NewPool, OldPool, OldSize < NewSize ? OldSize : NewSize);
    4921:	48 0f 46 d3          	cmovbe %rbx,%rdx
    RtCopyMem (Dest, Src, len);
    4925:	e8 e6 31 00 00       	call   7b10 <RtCopyMem>
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    492a:	48 8b 05 ff 8c 01 00 	mov    0x18cff(%rip),%rax        # 1d630 <BS>
    4931:	4c 89 e1             	mov    %r12,%rcx
    4934:	ff 50 48             	call   *0x48(%rax)
}
    4937:	48 83 c4 38          	add    $0x38,%rsp
    493b:	4c 89 e8             	mov    %r13,%rax
    493e:	5b                   	pop    %rbx
    493f:	5d                   	pop    %rbp
    4940:	41 5c                	pop    %r12
    4942:	41 5d                	pop    %r13
    4944:	c3                   	ret    
    4945:	0f 1f 00             	nopl   (%rax)
    NewPool = NULL;
    4948:	45 31 ed             	xor    %r13d,%r13d
    if (OldPool) {
    494b:	4d 85 e4             	test   %r12,%r12
    494e:	75 da                	jne    492a <ReallocatePool+0x5a>
}
    4950:	48 83 c4 38          	add    $0x38,%rsp
    4954:	4c 89 e8             	mov    %r13,%rax
    4957:	5b                   	pop    %rbx
    4958:	5d                   	pop    %rbp
    4959:	41 5c                	pop    %r12
    495b:	41 5d                	pop    %r13
    495d:	c3                   	ret    
    495e:	66 90                	xchg   %ax,%ax

0000000000004960 <FreePool>:
{
    4960:	f3 0f 1e fa          	endbr64 
    4964:	48 83 ec 28          	sub    $0x28,%rsp
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4968:	48 8b 05 c1 8c 01 00 	mov    0x18cc1(%rip),%rax        # 1d630 <BS>
{
    496f:	48 89 f9             	mov    %rdi,%rcx
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4972:	ff 50 48             	call   *0x48(%rax)
}
    4975:	48 83 c4 28          	add    $0x28,%rsp
    4979:	c3                   	ret    
    497a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000004980 <ZeroMem>:
{
    4980:	f3 0f 1e fa          	endbr64 
    RtZeroMem (Buffer, Size);
    4984:	e9 47 31 00 00       	jmp    7ad0 <RtZeroMem>
    4989:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000004990 <SetMem>:
{
    4990:	f3 0f 1e fa          	endbr64 
    4994:	57                   	push   %rdi
    4995:	48 89 cf             	mov    %rcx,%rdi
    4998:	56                   	push   %rsi
    4999:	48 89 d6             	mov    %rdx,%rsi
    RtSetMem (Buffer, Size, Value);
    499c:	41 0f b6 d0          	movzbl %r8b,%edx
{
    49a0:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    49a7:	0f 29 34 24          	movaps %xmm6,(%rsp)
    49ab:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    49b0:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    49b6:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    49bc:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    49c2:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    49c8:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    49ce:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    49d4:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    49db:	00 00 
    49dd:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    49e4:	00 00 
    RtSetMem (Buffer, Size, Value);
    49e6:	e8 05 31 00 00       	call   7af0 <RtSetMem>
}
    49eb:	0f 28 34 24          	movaps (%rsp),%xmm6
    49ef:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    49f4:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    49fa:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    4a00:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    4a06:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    4a0c:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    4a12:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    4a18:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    4a1f:	00 00 
    4a21:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    4a28:	00 00 
    4a2a:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    4a31:	5e                   	pop    %rsi
    4a32:	5f                   	pop    %rdi
    4a33:	c3                   	ret    
    4a34:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4a3b:	00 00 00 00 
    4a3f:	90                   	nop

0000000000004a40 <CopyMem>:
{
    4a40:	f3 0f 1e fa          	endbr64 
    4a44:	57                   	push   %rdi
    4a45:	48 89 cf             	mov    %rcx,%rdi
    4a48:	56                   	push   %rsi
    4a49:	48 89 d6             	mov    %rdx,%rsi
    4a4c:	4c 89 c2             	mov    %r8,%rdx
    4a4f:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    4a56:	0f 29 34 24          	movaps %xmm6,(%rsp)
    4a5a:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    4a5f:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    4a65:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    4a6b:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    4a71:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    4a77:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    4a7d:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    4a83:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    4a8a:	00 00 
    4a8c:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    4a93:	00 00 
    RtCopyMem (Dest, Src, len);
    4a95:	e8 76 30 00 00       	call   7b10 <RtCopyMem>
}
    4a9a:	0f 28 34 24          	movaps (%rsp),%xmm6
    4a9e:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    4aa3:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    4aa9:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    4aaf:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    4ab5:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    4abb:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    4ac1:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    4ac7:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    4ace:	00 00 
    4ad0:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    4ad7:	00 00 
    4ad9:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    4ae0:	5e                   	pop    %rsi
    4ae1:	5f                   	pop    %rdi
    4ae2:	c3                   	ret    
    4ae3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4aea:	00 00 00 00 
    4aee:	66 90                	xchg   %ax,%ax

0000000000004af0 <CompareMem>:
CompareMem (
    IN CONST VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    )
{
    4af0:	f3 0f 1e fa          	endbr64 
    return RtCompareMem (Dest, Src, len);
    4af4:	e9 97 30 00 00       	jmp    7b90 <RtCompareMem>
    4af9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000004b00 <GrowBuffer>:
    
    TRUE - if the buffer was reallocated and the caller 
    should try the API again.

--*/
{
    4b00:	f3 0f 1e fa          	endbr64 
    4b04:	41 54                	push   %r12
    4b06:	49 89 d4             	mov    %rdx,%r12
    4b09:	55                   	push   %rbp
    4b0a:	48 89 fd             	mov    %rdi,%rbp
    4b0d:	53                   	push   %rbx
    4b0e:	48 89 f3             	mov    %rsi,%rbx
    4b11:	48 83 ec 30          	sub    $0x30,%rsp

    //
    // If this is an initial request, buffer will be null with a new buffer size
    //

    if (!*Buffer && BufferSize) {
    4b15:	48 8b 0e             	mov    (%rsi),%rcx
    4b18:	48 85 d2             	test   %rdx,%rdx
    4b1b:	74 05                	je     4b22 <GrowBuffer+0x22>
    4b1d:	48 85 c9             	test   %rcx,%rcx
    4b20:	74 5e                	je     4b80 <GrowBuffer+0x80>
    //
    // If the status code is "buffer too small", resize the buffer
    //
        
    TryAgain = FALSE;
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    4b22:	48 ba 05 00 00 00 00 	movabs $0x8000000000000005,%rdx
    4b29:	00 00 80 
    4b2c:	48 8b 45 00          	mov    0x0(%rbp),%rax
    4b30:	48 39 d0             	cmp    %rdx,%rax
    4b33:	74 5b                	je     4b90 <GrowBuffer+0x90>

    //
    // If there's an error, free the buffer
    //

    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    4b35:	48 85 c0             	test   %rax,%rax
    4b38:	78 26                	js     4b60 <GrowBuffer+0x60>
        FreePool (*Buffer);
        *Buffer = NULL;
    }

    return TryAgain;
}
    4b3a:	48 83 c4 30          	add    $0x30,%rsp
        *Buffer = NULL;
    4b3e:	31 c0                	xor    %eax,%eax
}
    4b40:	5b                   	pop    %rbx
    4b41:	5d                   	pop    %rbp
    4b42:	41 5c                	pop    %r12
    4b44:	c3                   	ret    
    4b45:	0f 1f 00             	nopl   (%rax)
        *Buffer = AllocatePool (BufferSize);
    4b48:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
            *Status = EFI_OUT_OF_RESOURCES;
    4b4f:	48 b8 09 00 00 00 00 	movabs $0x8000000000000009,%rax
    4b56:	00 00 80 
    4b59:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    4b5d:	48 8b 0b             	mov    (%rbx),%rcx
    4b60:	48 85 c9             	test   %rcx,%rcx
    4b63:	74 d5                	je     4b3a <GrowBuffer+0x3a>
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4b65:	48 8b 05 c4 8a 01 00 	mov    0x18ac4(%rip),%rax        # 1d630 <BS>
    4b6c:	ff 50 48             	call   *0x48(%rax)
        *Buffer = NULL;
    4b6f:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    4b76:	eb c2                	jmp    4b3a <GrowBuffer+0x3a>
    4b78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    4b7f:	00 
        *Status = EFI_BUFFER_TOO_SMALL;
    4b80:	48 b8 05 00 00 00 00 	movabs $0x8000000000000005,%rax
    4b87:	00 00 80 
    4b8a:	48 89 07             	mov    %rax,(%rdi)
        if (*Buffer) {
    4b8d:	48 8b 0e             	mov    (%rsi),%rcx
    4b90:	48 85 c9             	test   %rcx,%rcx
    4b93:	74 0a                	je     4b9f <GrowBuffer+0x9f>
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4b95:	48 8b 05 94 8a 01 00 	mov    0x18a94(%rip),%rax        # 1d630 <BS>
    4b9c:	ff 50 48             	call   *0x48(%rax)
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4b9f:	48 8b 05 8a 8a 01 00 	mov    0x18a8a(%rip),%rax        # 1d630 <BS>
    4ba6:	8b 0d 70 82 01 00    	mov    0x18270(%rip),%ecx        # 1ce1c <PoolAllocationType>
    4bac:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    4bb1:	4c 89 e2             	mov    %r12,%rdx
    4bb4:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    4bb7:	48 85 c0             	test   %rax,%rax
    4bba:	78 8c                	js     4b48 <GrowBuffer+0x48>
    return p;
    4bbc:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
        *Buffer = AllocatePool (BufferSize);
    4bc1:	48 89 03             	mov    %rax,(%rbx)
        if (*Buffer) {
    4bc4:	48 85 c0             	test   %rax,%rax
    4bc7:	74 86                	je     4b4f <GrowBuffer+0x4f>
}
    4bc9:	48 83 c4 30          	add    $0x30,%rsp
            TryAgain = TRUE;
    4bcd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4bd2:	5b                   	pop    %rbx
    4bd3:	5d                   	pop    %rbp
    4bd4:	41 5c                	pop    %r12
    4bd6:	c3                   	ret    
    4bd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    4bde:	00 00 

0000000000004be0 <LibMemoryMap>:
    OUT UINTN               *NoEntries,
    OUT UINTN               *MapKey,
    OUT UINTN               *DescriptorSize,
    OUT UINT32              *DescriptorVersion
    )
{
    4be0:	f3 0f 1e fa          	endbr64 
    4be4:	41 57                	push   %r15
    4be6:	41 56                	push   %r14
    4be8:	41 55                	push   %r13
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    4bea:	49 bd 05 00 00 00 00 	movabs $0x8000000000000005,%r13
    4bf1:	00 00 80 
{
    4bf4:	41 54                	push   %r12
    4bf6:	49 89 f4             	mov    %rsi,%r12
    4bf9:	55                   	push   %rbp
    4bfa:	48 89 cd             	mov    %rcx,%rbp
    4bfd:	53                   	push   %rbx
    4bfe:	48 89 d3             	mov    %rdx,%rbx

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    4c01:	ba 28 00 00 00       	mov    $0x28,%edx
{
    4c06:	48 83 ec 58          	sub    $0x58,%rsp
    4c0a:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    4c0f:	4c 8d 74 24 48       	lea    0x48(%rsp),%r14
    BufferSize = sizeof(EFI_MEMORY_DESCRIPTOR);
    4c14:	48 c7 44 24 40 28 00 	movq   $0x28,0x40(%rsp)
    4c1b:	00 00 
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4c1d:	48 8b 05 0c 8a 01 00 	mov    0x18a0c(%rip),%rax        # 1d630 <BS>
    4c24:	8b 0d f2 81 01 00    	mov    0x181f2(%rip),%ecx        # 1ce1c <PoolAllocationType>
    4c2a:	4d 89 f0             	mov    %r14,%r8
    4c2d:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    4c30:	48 85 c0             	test   %rax,%rax
    4c33:	0f 88 97 00 00 00    	js     4cd0 <LibMemoryMap+0xf0>
    return p;
    4c39:	4c 8b 7c 24 48       	mov    0x48(%rsp),%r15
        if (*Buffer) {
    4c3e:	4d 85 ff             	test   %r15,%r15
    4c41:	0f 84 89 00 00 00    	je     4cd0 <LibMemoryMap+0xf0>
        Status = uefi_call_wrapper(BS->GetMemoryMap, 5, &BufferSize, Buffer, MapKey, DescriptorSize, DescriptorVersion);
    4c47:	48 8b 05 e2 89 01 00 	mov    0x189e2(%rip),%rax        # 1d630 <BS>
    4c4e:	4c 89 fa             	mov    %r15,%rdx
    4c51:	49 89 d9             	mov    %rbx,%r9
    4c54:	4d 89 e0             	mov    %r12,%r8
    4c57:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
    4c5c:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
    4c61:	ff 50 38             	call   *0x38(%rax)
    while (GrowBuffer (&Status, (VOID **) &Buffer, BufferSize)) {
    4c64:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    4c69:	4c 39 e8             	cmp    %r13,%rax
    4c6c:	74 2a                	je     4c98 <LibMemoryMap+0xb8>
    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    4c6e:	48 85 c0             	test   %rax,%rax
    4c71:	78 45                	js     4cb8 <LibMemoryMap+0xd8>
    //
    // Convert buffer size to NoEntries
    //

    if (!EFI_ERROR(Status)) {
        *NoEntries = BufferSize / *DescriptorSize;
    4c73:	48 89 d0             	mov    %rdx,%rax
    4c76:	31 d2                	xor    %edx,%edx
    4c78:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    4c7d:	48 f7 33             	divq   (%rbx)
    4c80:	48 89 06             	mov    %rax,(%rsi)
    }

    return Buffer;
}
    4c83:	48 83 c4 58          	add    $0x58,%rsp
    4c87:	4c 89 f8             	mov    %r15,%rax
    4c8a:	5b                   	pop    %rbx
    4c8b:	5d                   	pop    %rbp
    4c8c:	41 5c                	pop    %r12
    4c8e:	41 5d                	pop    %r13
    4c90:	41 5e                	pop    %r14
    4c92:	41 5f                	pop    %r15
    4c94:	c3                   	ret    
    4c95:	0f 1f 00             	nopl   (%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4c98:	48 8b 05 91 89 01 00 	mov    0x18991(%rip),%rax        # 1d630 <BS>
    4c9f:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    4ca4:	4c 89 f9             	mov    %r15,%rcx
    4ca7:	ff 50 48             	call   *0x48(%rax)
    4caa:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    4caf:	e9 69 ff ff ff       	jmp    4c1d <LibMemoryMap+0x3d>
    4cb4:	0f 1f 40 00          	nopl   0x0(%rax)
    4cb8:	48 8b 05 71 89 01 00 	mov    0x18971(%rip),%rax        # 1d630 <BS>
    4cbf:	4c 89 f9             	mov    %r15,%rcx
    4cc2:	45 31 ff             	xor    %r15d,%r15d
    4cc5:	ff 50 48             	call   *0x48(%rax)
    if (!EFI_ERROR(Status)) {
    4cc8:	eb b9                	jmp    4c83 <LibMemoryMap+0xa3>
    4cca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    4cd0:	45 31 ff             	xor    %r15d,%r15d
    4cd3:	eb ae                	jmp    4c83 <LibMemoryMap+0xa3>
    4cd5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4cdc:	00 00 00 00 

0000000000004ce0 <LibGetVariableAndSize>:
LibGetVariableAndSize (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid,
    OUT UINTN               *VarSize
    )
{
    4ce0:	f3 0f 1e fa          	endbr64 
    4ce4:	41 57                	push   %r15
    4ce6:	41 56                	push   %r14

    //
    // Call the real function
    //

    while (GrowBuffer (&Status, &Buffer, BufferSize)) {
    4ce8:	41 be 64 00 00 00    	mov    $0x64,%r14d
{
    4cee:	41 55                	push   %r13
    4cf0:	41 54                	push   %r12
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    4cf2:	49 bc 05 00 00 00 00 	movabs $0x8000000000000005,%r12
    4cf9:	00 00 80 
{
    4cfc:	55                   	push   %rbp
    4cfd:	48 89 fd             	mov    %rdi,%rbp
    4d00:	53                   	push   %rbx
    4d01:	48 89 f3             	mov    %rsi,%rbx
    4d04:	48 83 ec 58          	sub    $0x58,%rsp
    4d08:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)
    4d0d:	4c 8d 6c 24 48       	lea    0x48(%rsp),%r13
    BufferSize = 100;
    4d12:	48 c7 44 24 40 64 00 	movq   $0x64,0x40(%rsp)
    4d19:	00 00 
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4d1b:	48 8b 05 0e 89 01 00 	mov    0x1890e(%rip),%rax        # 1d630 <BS>
    4d22:	8b 0d f4 80 01 00    	mov    0x180f4(%rip),%ecx        # 1ce1c <PoolAllocationType>
    4d28:	4d 89 e8             	mov    %r13,%r8
    4d2b:	4c 89 f2             	mov    %r14,%rdx
    4d2e:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    4d31:	48 85 c0             	test   %rax,%rax
    4d34:	78 67                	js     4d9d <LibGetVariableAndSize+0xbd>
    return p;
    4d36:	4c 8b 7c 24 48       	mov    0x48(%rsp),%r15
        if (*Buffer) {
    4d3b:	4d 85 ff             	test   %r15,%r15
    4d3e:	74 7a                	je     4dba <LibGetVariableAndSize+0xda>
        Status = uefi_call_wrapper(
    4d40:	48 8b 05 29 89 01 00 	mov    0x18929(%rip),%rax        # 1d670 <RT>
    4d47:	45 31 c0             	xor    %r8d,%r8d
    4d4a:	48 89 da             	mov    %rbx,%rdx
    4d4d:	48 89 e9             	mov    %rbp,%rcx
    4d50:	4c 89 7c 24 20       	mov    %r15,0x20(%rsp)
    4d55:	4c 8d 4c 24 40       	lea    0x40(%rsp),%r9
    4d5a:	ff 50 48             	call   *0x48(%rax)
    while (GrowBuffer (&Status, &Buffer, BufferSize)) {
    4d5d:	4c 8b 74 24 40       	mov    0x40(%rsp),%r14
    if (*Status == EFI_BUFFER_TOO_SMALL) {
    4d62:	4c 39 e0             	cmp    %r12,%rax
    4d65:	74 41                	je     4da8 <LibGetVariableAndSize+0xc8>
    if (!TryAgain && EFI_ERROR(*Status) && *Buffer) {
    4d67:	48 85 c0             	test   %rax,%rax
    4d6a:	78 24                	js     4d90 <LibGetVariableAndSize+0xb0>
    4d6c:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    4d71:	4c 89 30             	mov    %r14,(%rax)
        *VarSize = BufferSize;
    } else {
        *VarSize = 0;
    }
    return Buffer;
}
    4d74:	48 83 c4 58          	add    $0x58,%rsp
    4d78:	4c 89 f8             	mov    %r15,%rax
    4d7b:	5b                   	pop    %rbx
    4d7c:	5d                   	pop    %rbp
    4d7d:	41 5c                	pop    %r12
    4d7f:	41 5d                	pop    %r13
    4d81:	41 5e                	pop    %r14
    4d83:	41 5f                	pop    %r15
    4d85:	c3                   	ret    
    4d86:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    4d8d:	00 00 00 
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4d90:	48 8b 05 99 88 01 00 	mov    0x18899(%rip),%rax        # 1d630 <BS>
    4d97:	4c 89 f9             	mov    %r15,%rcx
    4d9a:	ff 50 48             	call   *0x48(%rax)
        *VarSize = 0;
    4d9d:	45 31 f6             	xor    %r14d,%r14d
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4da0:	45 31 ff             	xor    %r15d,%r15d
    4da3:	eb c7                	jmp    4d6c <LibGetVariableAndSize+0x8c>
    4da5:	0f 1f 00             	nopl   (%rax)
    4da8:	48 8b 05 81 88 01 00 	mov    0x18881(%rip),%rax        # 1d630 <BS>
    4daf:	4c 89 f9             	mov    %r15,%rcx
    4db2:	ff 50 48             	call   *0x48(%rax)
    4db5:	e9 61 ff ff ff       	jmp    4d1b <LibGetVariableAndSize+0x3b>
        *VarSize = 0;
    4dba:	45 31 f6             	xor    %r14d,%r14d
    4dbd:	eb ad                	jmp    4d6c <LibGetVariableAndSize+0x8c>
    4dbf:	90                   	nop

0000000000004dc0 <LibGetVariable>:
VOID *
LibGetVariable (
    IN CHAR16               *Name,
    IN EFI_GUID             *VendorGuid
    )
{
    4dc0:	f3 0f 1e fa          	endbr64 
    4dc4:	48 83 ec 18          	sub    $0x18,%rsp
    UINTN   VarSize;

    return LibGetVariableAndSize (Name, VendorGuid, &VarSize);
    4dc8:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
    4dcd:	e8 0e ff ff ff       	call   4ce0 <LibGetVariableAndSize>
}
    4dd2:	48 83 c4 18          	add    $0x18,%rsp
    4dd6:	c3                   	ret    
    4dd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    4dde:	00 00 

0000000000004de0 <LibDeleteVariable>:
EFI_STATUS
LibDeleteVariable (
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid
    )
{
    4de0:	f3 0f 1e fa          	endbr64 
    4de4:	41 57                	push   %r15
    4de6:	49 bf 0e 00 00 00 00 	movabs $0x800000000000000e,%r15
    4ded:	00 00 80 
    4df0:	41 56                	push   %r14
    4df2:	49 89 f6             	mov    %rsi,%r14
    4df5:	41 55                	push   %r13
    4df7:	49 89 fd             	mov    %rdi,%r13
    4dfa:	41 54                	push   %r12
    4dfc:	48 83 ec 48          	sub    $0x48,%rsp
    return LibGetVariableAndSize (Name, VendorGuid, &VarSize);
    4e00:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
    4e05:	e8 d6 fe ff ff       	call   4ce0 <LibGetVariableAndSize>

    VarBuf = LibGetVariable(VarName,VarGuid);

    Status = EFI_NOT_FOUND;

    if (VarBuf) {
    4e0a:	48 85 c0             	test   %rax,%rax
    4e0d:	74 35                	je     4e44 <LibDeleteVariable+0x64>
    4e0f:	49 89 c4             	mov    %rax,%r12
        //
        // Delete variable from Storage
        //
        Status = uefi_call_wrapper(
    4e12:	48 8b 05 57 88 01 00 	mov    0x18857(%rip),%rax        # 1d670 <RT>
    4e19:	4c 89 e9             	mov    %r13,%rcx
    4e1c:	45 31 c9             	xor    %r9d,%r9d
    4e1f:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
    4e26:	00 00 
    4e28:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    4e2e:	4c 89 f2             	mov    %r14,%rdx
    4e31:	ff 50 58             	call   *0x58(%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4e34:	4c 89 e1             	mov    %r12,%rcx
        Status = uefi_call_wrapper(
    4e37:	49 89 c7             	mov    %rax,%r15
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4e3a:	48 8b 05 ef 87 01 00 	mov    0x187ef(%rip),%rax        # 1d630 <BS>
    4e41:	ff 50 48             	call   *0x48(%rax)
        ASSERT (!EFI_ERROR(Status));
        FreePool(VarBuf);
    }

    return (Status);
}
    4e44:	48 83 c4 48          	add    $0x48,%rsp
    4e48:	4c 89 f8             	mov    %r15,%rax
    4e4b:	41 5c                	pop    %r12
    4e4d:	41 5d                	pop    %r13
    4e4f:	41 5e                	pop    %r14
    4e51:	41 5f                	pop    %r15
    4e53:	c3                   	ret    
    4e54:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    4e5b:	00 00 00 00 
    4e5f:	90                   	nop

0000000000004e60 <LibSetNVVariable>:
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid,
    IN UINTN	 DataSize,
    IN VOID     *Data
    )
{
    4e60:	f3 0f 1e fa          	endbr64 
    4e64:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_STATUS  Status;

    Status = uefi_call_wrapper(
    4e68:	48 8b 05 01 88 01 00 	mov    0x18801(%rip),%rax        # 1d670 <RT>
{
    4e6f:	49 89 d1             	mov    %rdx,%r9
    Status = uefi_call_wrapper(
    4e72:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    4e78:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    4e7d:	48 89 f2             	mov    %rsi,%rdx
    4e80:	48 89 f9             	mov    %rdi,%rcx
    4e83:	ff 50 58             	call   *0x58(%rax)
	    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
	    DataSize, Data
	    );
    ASSERT (!EFI_ERROR(Status));
    return (Status);
}
    4e86:	48 83 c4 38          	add    $0x38,%rsp
    4e8a:	c3                   	ret    
    4e8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004e90 <LibSetVariable>:
    IN CHAR16   *VarName,
    IN EFI_GUID *VarGuid,
    IN UINTN	 DataSize,
    IN VOID     *Data
    )
{
    4e90:	f3 0f 1e fa          	endbr64 
    4e94:	48 83 ec 38          	sub    $0x38,%rsp
    EFI_STATUS  Status;

    Status = uefi_call_wrapper(
    4e98:	48 8b 05 d1 87 01 00 	mov    0x187d1(%rip),%rax        # 1d670 <RT>
{
    4e9f:	49 89 d1             	mov    %rdx,%r9
    Status = uefi_call_wrapper(
    4ea2:	41 b8 06 00 00 00    	mov    $0x6,%r8d
    4ea8:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    4ead:	48 89 f2             	mov    %rsi,%rdx
    4eb0:	48 89 f9             	mov    %rdi,%rcx
    4eb3:	ff 50 58             	call   *0x58(%rax)
	    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
	    DataSize, Data
	    );
    ASSERT (!EFI_ERROR(Status));
    return (Status);
}
    4eb6:	48 83 c4 38          	add    $0x38,%rsp
    4eba:	c3                   	ret    
    4ebb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004ec0 <LibInsertToTailOfBootOrder>:
EFI_STATUS
LibInsertToTailOfBootOrder (
    IN  UINT16  BootOption,
    IN  BOOLEAN OnlyInsertIfEmpty
    )
{
    4ec0:	f3 0f 1e fa          	endbr64 
    4ec4:	41 57                	push   %r15
    4ec6:	41 56                	push   %r14
    UINT16      *NewBootOptionArray;
    UINTN       VarSize;
    UINTN       Index;
    EFI_STATUS  Status;

    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    4ec8:	4c 8d 35 31 7f 01 00 	lea    0x17f31(%rip),%r14        # 1ce00 <gEfiGlobalVariableGuid>
{
    4ecf:	41 55                	push   %r13
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    4ed1:	4c 8d 2d 42 48 02 00 	lea    0x24842(%rip),%r13        # 2971a <_DYNAMIC+0xb71a>
{
    4ed8:	41 54                	push   %r12
    4eda:	41 89 f4             	mov    %esi,%r12d
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    4edd:	4c 89 f6             	mov    %r14,%rsi
{
    4ee0:	53                   	push   %rbx
    4ee1:	89 fb                	mov    %edi,%ebx
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    4ee3:	4c 89 ef             	mov    %r13,%rdi
{
    4ee6:	48 83 ec 40          	sub    $0x40,%rsp
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    4eea:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
    4eef:	e8 ec fd ff ff       	call   4ce0 <LibGetVariableAndSize>
    if (VarSize != 0 && OnlyInsertIfEmpty) {
    4ef4:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    BootOptionArray = LibGetVariableAndSize (VarBootOrder, &EfiGlobalVariable, &VarSize);    
    4ef9:	49 89 c7             	mov    %rax,%r15
    if (VarSize != 0 && OnlyInsertIfEmpty) {
    4efc:	48 85 d2             	test   %rdx,%rdx
    4eff:	74 09                	je     4f0a <LibInsertToTailOfBootOrder+0x4a>
    4f01:	45 84 e4             	test   %r12b,%r12b
    4f04:	0f 85 16 01 00 00    	jne    5020 <LibInsertToTailOfBootOrder+0x160>
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4f0a:	48 8b 05 1f 87 01 00 	mov    0x1871f(%rip),%rax        # 1d630 <BS>
            FreePool (BootOptionArray);
        }
        return EFI_UNSUPPORTED;
    }

    VarSize += sizeof(UINT16);
    4f11:	48 83 c2 02          	add    $0x2,%rdx
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4f15:	8b 0d 01 7f 01 00    	mov    0x17f01(%rip),%ecx        # 1ce1c <PoolAllocationType>
    4f1b:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    VarSize += sizeof(UINT16);
    4f20:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    Status = uefi_call_wrapper(BS->AllocatePool, 3, PoolAllocationType, Size, &p);
    4f25:	ff 50 40             	call   *0x40(%rax)
    if (EFI_ERROR(Status)) {
    4f28:	48 85 c0             	test   %rax,%rax
    4f2b:	0f 88 9f 00 00 00    	js     4fd0 <LibInsertToTailOfBootOrder+0x110>
    return p;
    4f31:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
    NewBootOptionArray = AllocatePool (VarSize);
    if (!NewBootOptionArray)
    4f36:	4d 85 e4             	test   %r12,%r12
    4f39:	0f 84 91 00 00 00    	je     4fd0 <LibInsertToTailOfBootOrder+0x110>
        return EFI_OUT_OF_RESOURCES;

    for (Index = 0; Index < ((VarSize/sizeof(UINT16)) - 1); Index++) {
    4f3f:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    4f44:	48 d1 e8             	shr    %rax
    4f47:	48 83 f8 01          	cmp    $0x1,%rax
    4f4b:	0f 84 8f 00 00 00    	je     4fe0 <LibInsertToTailOfBootOrder+0x120>
    4f51:	31 d2                	xor    %edx,%edx
    4f53:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        NewBootOptionArray[Index] = BootOptionArray[Index];
    4f58:	41 0f b7 04 57       	movzwl (%r15,%rdx,2),%eax
    4f5d:	66 41 89 04 54       	mov    %ax,(%r12,%rdx,2)
    for (Index = 0; Index < ((VarSize/sizeof(UINT16)) - 1); Index++) {
    4f62:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    4f67:	48 83 c2 01          	add    $0x1,%rdx
    4f6b:	48 d1 e8             	shr    %rax
    4f6e:	48 83 e8 01          	sub    $0x1,%rax
    4f72:	48 39 d0             	cmp    %rdx,%rax
    4f75:	77 e1                	ja     4f58 <LibInsertToTailOfBootOrder+0x98>
    }
    //
    // Insert in the tail of the array
    //
    NewBootOptionArray[Index] = BootOption;
    4f77:	66 41 89 1c 54       	mov    %bx,(%r12,%rdx,2)

    Status = uefi_call_wrapper(
    4f7c:	4c 89 e9             	mov    %r13,%rcx
    4f7f:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    4f84:	4c 89 f2             	mov    %r14,%rdx
    4f87:	48 8b 05 e2 86 01 00 	mov    0x186e2(%rip),%rax        # 1d670 <RT>
    4f8e:	4c 89 64 24 20       	mov    %r12,0x20(%rsp)
    4f93:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    4f99:	ff 50 58             	call   *0x58(%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4f9c:	4c 89 e1             	mov    %r12,%rcx
    Status = uefi_call_wrapper(
    4f9f:	49 89 c5             	mov    %rax,%r13
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    4fa2:	48 8b 05 87 86 01 00 	mov    0x18687(%rip),%rax        # 1d630 <BS>
    4fa9:	ff 50 48             	call   *0x48(%rax)
    4fac:	48 8b 05 7d 86 01 00 	mov    0x1867d(%rip),%rax        # 1d630 <BS>
    4fb3:	4c 89 f9             	mov    %r15,%rcx
    4fb6:	ff 50 48             	call   *0x48(%rax)
    FreePool (NewBootOptionArray);
    if (BootOptionArray) {
        FreePool (BootOptionArray);
    }
    return Status;
}
    4fb9:	48 83 c4 40          	add    $0x40,%rsp
    4fbd:	4c 89 e8             	mov    %r13,%rax
    4fc0:	5b                   	pop    %rbx
    4fc1:	41 5c                	pop    %r12
    4fc3:	41 5d                	pop    %r13
    4fc5:	41 5e                	pop    %r14
    4fc7:	41 5f                	pop    %r15
    4fc9:	c3                   	ret    
    4fca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return EFI_OUT_OF_RESOURCES;
    4fd0:	49 bd 09 00 00 00 00 	movabs $0x8000000000000009,%r13
    4fd7:	00 00 80 
    4fda:	eb dd                	jmp    4fb9 <LibInsertToTailOfBootOrder+0xf9>
    4fdc:	0f 1f 40 00          	nopl   0x0(%rax)
    NewBootOptionArray[Index] = BootOption;
    4fe0:	66 41 89 1c 24       	mov    %bx,(%r12)
    Status = uefi_call_wrapper(
    4fe5:	48 8b 05 84 86 01 00 	mov    0x18684(%rip),%rax        # 1d670 <RT>
    4fec:	4c 89 e9             	mov    %r13,%rcx
    4fef:	4c 89 f2             	mov    %r14,%rdx
    4ff2:	4c 89 64 24 20       	mov    %r12,0x20(%rsp)
    4ff7:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    4ffc:	41 b8 07 00 00 00    	mov    $0x7,%r8d
    5002:	ff 50 58             	call   *0x58(%rax)
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    5005:	4c 89 e1             	mov    %r12,%rcx
    Status = uefi_call_wrapper(
    5008:	49 89 c5             	mov    %rax,%r13
    uefi_call_wrapper(BS->FreePool, 1, Buffer);
    500b:	48 8b 05 1e 86 01 00 	mov    0x1861e(%rip),%rax        # 1d630 <BS>
    5012:	ff 50 48             	call   *0x48(%rax)
    if (BootOptionArray) {
    5015:	4d 85 ff             	test   %r15,%r15
    5018:	74 9f                	je     4fb9 <LibInsertToTailOfBootOrder+0xf9>
    501a:	eb 90                	jmp    4fac <LibInsertToTailOfBootOrder+0xec>
    501c:	0f 1f 40 00          	nopl   0x0(%rax)
        return EFI_UNSUPPORTED;
    5020:	49 bd 03 00 00 00 00 	movabs $0x8000000000000003,%r13
    5027:	00 00 80 
        if (BootOptionArray) {
    502a:	48 85 c0             	test   %rax,%rax
    502d:	0f 85 79 ff ff ff    	jne    4fac <LibInsertToTailOfBootOrder+0xec>
    5033:	eb 84                	jmp    4fb9 <LibInsertToTailOfBootOrder+0xf9>
    5035:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    503c:	00 00 00 00 

0000000000005040 <ValidMBR>:
BOOLEAN
ValidMBR(
    IN  MASTER_BOOT_RECORD  *Mbr,
    IN  EFI_BLOCK_IO        *BlkIo
    )
{
    5040:	f3 0f 1e fa          	endbr64 
    5044:	55                   	push   %rbp

    if (Mbr->Signature != MBR_SIGNATURE) {
        //
        // The BPB also has this signature, so it can not be used alone.
        //
        return FALSE;
    5045:	31 ed                	xor    %ebp,%ebp
    if (Mbr->Signature != MBR_SIGNATURE) {
    5047:	66 81 bf fe 01 00 00 	cmpw   $0xaa55,0x1fe(%rdi)
    504e:	55 aa 
{
    5050:	53                   	push   %rbx
    if (Mbr->Signature != MBR_SIGNATURE) {
    5051:	0f 85 6c 01 00 00    	jne    51c3 <ValidMBR+0x183>
    } 

    ValidMbr = FALSE;
    for (i=0; i<MAX_MBR_PARTITIONS; i++) {
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
    5057:	80 bf c2 01 00 00 00 	cmpb   $0x0,0x1c2(%rdi)
    505e:	49 89 f2             	mov    %rsi,%r10
    if (Mbr->Signature != MBR_SIGNATURE) {
    5061:	41 bb 01 00 00 00    	mov    $0x1,%r11d
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
    5067:	0f 84 50 01 00 00    	je     51bd <ValidMBR+0x17d>
    506d:	0f b6 87 cb 01 00 00 	movzbl 0x1cb(%rdi),%eax
    5074:	0f b6 97 cc 01 00 00 	movzbl 0x1cc(%rdi),%edx
    507b:	c1 e0 08             	shl    $0x8,%eax
    507e:	c1 e2 10             	shl    $0x10,%edx
    5081:	09 d0                	or     %edx,%eax
    5083:	0f b6 97 ca 01 00 00 	movzbl 0x1ca(%rdi),%edx
    508a:	09 d0                	or     %edx,%eax
    508c:	0f b6 97 cd 01 00 00 	movzbl 0x1cd(%rdi),%edx
    5093:	c1 e2 18             	shl    $0x18,%edx
    5096:	09 d0                	or     %edx,%eax
    5098:	0f 84 1f 01 00 00    	je     51bd <ValidMBR+0x17d>
            continue;
        }
        ValidMbr = TRUE;
        StartingLBA = EXTRACT_UINT32(Mbr->Partition[i].StartingLBA);
    509e:	44 0f b6 87 c7 01 00 	movzbl 0x1c7(%rdi),%r8d
    50a5:	00 
    50a6:	0f b6 97 c8 01 00 00 	movzbl 0x1c8(%rdi),%edx
    50ad:	41 c1 e0 08          	shl    $0x8,%r8d
    50b1:	c1 e2 10             	shl    $0x10,%edx
    50b4:	41 09 d0             	or     %edx,%r8d
    50b7:	0f b6 97 c6 01 00 00 	movzbl 0x1c6(%rdi),%edx
    50be:	41 09 d0             	or     %edx,%r8d
    50c1:	0f b6 97 c9 01 00 00 	movzbl 0x1c9(%rdi),%edx
    50c8:	c1 e2 18             	shl    $0x18,%edx
    50cb:	41 09 d0             	or     %edx,%r8d
        EndingLBA = StartingLBA + EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) - 1;
    50ce:	42 8d 54 00 ff       	lea    -0x1(%rax,%r8,1),%edx
        if (EndingLBA > BlkIo->Media->LastBlock) {
    50d3:	49 8b 42 08          	mov    0x8(%r10),%rax
        EndingLBA = StartingLBA + EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) - 1;
    50d7:	49 89 d1             	mov    %rdx,%r9
        if (EndingLBA > BlkIo->Media->LastBlock) {
    50da:	48 8b 40 18          	mov    0x18(%rax),%rax
    50de:	48 39 c2             	cmp    %rax,%rdx
    50e1:	76 1b                	jbe    50fe <ValidMBR+0xbe>
            //  that gets created from DOS is smaller than the MBR created from 
            //  a real OS (NT & Win98). This leads to BlkIo->LastBlock being 
            //  wrong on some systems FDISKed by the OS.
            //
            //
            if (BlkIo->Media->LastBlock < MIN_MBR_DEVICE_SIZE) {
    50e3:	48 3d ff ff 07 00    	cmp    $0x7ffff,%rax
    50e9:	0f 86 d9 00 00 00    	jbe    51c8 <ValidMBR+0x188>
                // If this is a very small device then trust the BlkIo->LastBlock
                //
                return FALSE;
            }

            if (EndingLBA > (BlkIo->Media->LastBlock + MBR_ERRATA_PAD)) {
    50ef:	48 05 00 00 04 00    	add    $0x40000,%rax
    50f5:	48 39 c2             	cmp    %rax,%rdx
    50f8:	0f 87 ca 00 00 00    	ja     51c8 <ValidMBR+0x188>
                return FALSE;
            }

        }
        for (j=i+1; j<MAX_MBR_PARTITIONS; j++) {
    50fe:	4c 89 de             	mov    %r11,%rsi
    5101:	49 83 fb 04          	cmp    $0x4,%r11
    5105:	0f 84 c1 00 00 00    	je     51cc <ValidMBR+0x18c>
    510b:	48 89 f8             	mov    %rdi,%rax
    510e:	66 90                	xchg   %ax,%ax
            if (Mbr->Partition[j].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[j].SizeInLBA) == 0) {
    5110:	80 b8 d2 01 00 00 00 	cmpb   $0x0,0x1d2(%rax)
    5117:	74 78                	je     5191 <ValidMBR+0x151>
    5119:	0f b6 90 db 01 00 00 	movzbl 0x1db(%rax),%edx
    5120:	0f b6 88 dc 01 00 00 	movzbl 0x1dc(%rax),%ecx
    5127:	c1 e2 08             	shl    $0x8,%edx
    512a:	c1 e1 10             	shl    $0x10,%ecx
    512d:	09 ca                	or     %ecx,%edx
    512f:	0f b6 88 da 01 00 00 	movzbl 0x1da(%rax),%ecx
    5136:	09 ca                	or     %ecx,%edx
    5138:	0f b6 88 dd 01 00 00 	movzbl 0x1dd(%rax),%ecx
    513f:	c1 e1 18             	shl    $0x18,%ecx
    5142:	09 ca                	or     %ecx,%edx
    5144:	74 4b                	je     5191 <ValidMBR+0x151>
                continue;
            }
            if (   EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) >= StartingLBA && 
    5146:	0f b6 88 d7 01 00 00 	movzbl 0x1d7(%rax),%ecx
    514d:	0f b6 98 d8 01 00 00 	movzbl 0x1d8(%rax),%ebx
    5154:	c1 e1 08             	shl    $0x8,%ecx
    5157:	c1 e3 10             	shl    $0x10,%ebx
    515a:	09 d9                	or     %ebx,%ecx
    515c:	0f b6 98 d6 01 00 00 	movzbl 0x1d6(%rax),%ebx
    5163:	09 d9                	or     %ebx,%ecx
    5165:	0f b6 98 d9 01 00 00 	movzbl 0x1d9(%rax),%ebx
    516c:	c1 e3 18             	shl    $0x18,%ebx
    516f:	09 d9                	or     %ebx,%ecx
    5171:	44 39 c9             	cmp    %r9d,%ecx
    5174:	40 0f 96 c5          	setbe  %bpl
    5178:	44 39 c1             	cmp    %r8d,%ecx
    517b:	0f 93 c3             	setae  %bl
    517e:	40 20 dd             	and    %bl,%bpl
    5181:	75 45                	jne    51c8 <ValidMBR+0x188>
                //
                // The Start of this region overlaps with the i'th region
                //
                return FALSE;
            } 
            NewEndingLBA = EXTRACT_UINT32(Mbr->Partition[j].StartingLBA) + EXTRACT_UINT32(Mbr->Partition[j].SizeInLBA) - 1;
    5183:	8d 54 0a ff          	lea    -0x1(%rdx,%rcx,1),%edx
            if ( NewEndingLBA >= StartingLBA && NewEndingLBA <= EndingLBA ) {
    5187:	41 39 d0             	cmp    %edx,%r8d
    518a:	77 05                	ja     5191 <ValidMBR+0x151>
    518c:	41 39 d1             	cmp    %edx,%r9d
    518f:	73 32                	jae    51c3 <ValidMBR+0x183>
        for (j=i+1; j<MAX_MBR_PARTITIONS; j++) {
    5191:	48 83 c6 01          	add    $0x1,%rsi
    5195:	48 83 c0 10          	add    $0x10,%rax
    5199:	48 83 fe 04          	cmp    $0x4,%rsi
    519d:	0f 85 6d ff ff ff    	jne    5110 <ValidMBR+0xd0>
        ValidMbr = TRUE;
    51a3:	bd 01 00 00 00       	mov    $0x1,%ebp
    51a8:	48 83 c7 10          	add    $0x10,%rdi
    51ac:	49 83 c3 01          	add    $0x1,%r11
        if ( Mbr->Partition[i].OSIndicator == 0x00 || EXTRACT_UINT32(Mbr->Partition[i].SizeInLBA) == 0 ) {
    51b0:	80 bf c2 01 00 00 00 	cmpb   $0x0,0x1c2(%rdi)
    51b7:	0f 85 b0 fe ff ff    	jne    506d <ValidMBR+0x2d>
    for (i=0; i<MAX_MBR_PARTITIONS; i++) {
    51bd:	49 83 fb 04          	cmp    $0x4,%r11
    51c1:	75 e5                	jne    51a8 <ValidMBR+0x168>
    }
    //
    // Non of the regions overlapped so MBR is O.K.
    //
    return ValidMbr;
} 
    51c3:	89 e8                	mov    %ebp,%eax
    51c5:	5b                   	pop    %rbx
    51c6:	5d                   	pop    %rbp
    51c7:	c3                   	ret    
        return FALSE;
    51c8:	31 ed                	xor    %ebp,%ebp
    51ca:	eb f7                	jmp    51c3 <ValidMBR+0x183>
        ValidMbr = TRUE;
    51cc:	bd 01 00 00 00       	mov    $0x1,%ebp
    51d1:	eb f0                	jmp    51c3 <ValidMBR+0x183>
    51d3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    51da:	00 00 00 00 
    51de:	66 90                	xchg   %ax,%ax

00000000000051e0 <DecimaltoBCD>:

UINT8
DecimaltoBCD(
    IN  UINT8 DecValue
    )
{
    51e0:	f3 0f 1e fa          	endbr64 
    return RtDecimaltoBCD (DecValue);
    51e4:	40 0f b6 ff          	movzbl %dil,%edi
    51e8:	e9 63 2d 00 00       	jmp    7f50 <RtDecimaltoBCD>
    51ed:	0f 1f 00             	nopl   (%rax)

00000000000051f0 <BCDtoDecimal>:

UINT8
BCDtoDecimal(
    IN  UINT8 BcdValue
    )
{
    51f0:	f3 0f 1e fa          	endbr64 
    return RtBCDtoDecimal (BcdValue);
    51f4:	40 0f b6 ff          	movzbl %dil,%edi
    51f8:	e9 33 2d 00 00       	jmp    7f30 <RtBCDtoDecimal>
    51fd:	0f 1f 00             	nopl   (%rax)

0000000000005200 <LibGetSystemConfigurationTable>:
LibGetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    )

{
    5200:	f3 0f 1e fa          	endbr64 
    UINTN Index;

    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
    5204:	48 8b 05 2d 84 01 00 	mov    0x1842d(%rip),%rax        # 1d638 <ST>
    520b:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
    5210:	0f 84 7f 00 00 00    	je     5295 <LibGetSystemConfigurationTable+0x95>
{
    5216:	41 55                	push   %r13
    5218:	49 89 f5             	mov    %rsi,%r13
    521b:	41 54                	push   %r12
    521d:	49 89 fc             	mov    %rdi,%r12
    5220:	55                   	push   %rbp
    5221:	53                   	push   %rbx
    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
    5222:	31 db                	xor    %ebx,%ebx
{
    5224:	48 83 ec 08          	sub    $0x8,%rsp
    5228:	eb 17                	jmp    5241 <LibGetSystemConfigurationTable+0x41>
    522a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for(Index=0;Index<ST->NumberOfTableEntries;Index++) {
    5230:	48 8b 05 01 84 01 00 	mov    0x18401(%rip),%rax        # 1d638 <ST>
    5237:	48 83 c3 01          	add    $0x1,%rbx
    523b:	48 39 58 68          	cmp    %rbx,0x68(%rax)
    523f:	76 3f                	jbe    5280 <LibGetSystemConfigurationTable+0x80>
        if (CompareGuid(TableGuid,&(ST->ConfigurationTable[Index].VendorGuid))==0) {
    5241:	48 8b 70 70          	mov    0x70(%rax),%rsi
    5245:	48 8d 2c 5b          	lea    (%rbx,%rbx,2),%rbp
    5249:	4c 89 e7             	mov    %r12,%rdi
    524c:	48 c1 e5 03          	shl    $0x3,%rbp
    5250:	48 01 ee             	add    %rbp,%rsi
    5253:	e8 f8 44 00 00       	call   9750 <CompareGuid>
    5258:	48 85 c0             	test   %rax,%rax
    525b:	75 d3                	jne    5230 <LibGetSystemConfigurationTable+0x30>
            *Table = ST->ConfigurationTable[Index].VendorTable;
    525d:	48 8b 05 d4 83 01 00 	mov    0x183d4(%rip),%rax        # 1d638 <ST>
    5264:	48 8b 40 70          	mov    0x70(%rax),%rax
    5268:	48 8b 44 28 10       	mov    0x10(%rax,%rbp,1),%rax
    526d:	49 89 45 00          	mov    %rax,0x0(%r13)
            return EFI_SUCCESS;
        }
    }
    return EFI_NOT_FOUND;
}
    5271:	48 83 c4 08          	add    $0x8,%rsp
            return EFI_SUCCESS;
    5275:	31 c0                	xor    %eax,%eax
}
    5277:	5b                   	pop    %rbx
    5278:	5d                   	pop    %rbp
    5279:	41 5c                	pop    %r12
    527b:	41 5d                	pop    %r13
    527d:	c3                   	ret    
    527e:	66 90                	xchg   %ax,%ax
    return EFI_NOT_FOUND;
    5280:	48 b8 0e 00 00 00 00 	movabs $0x800000000000000e,%rax
    5287:	00 00 80 
}
    528a:	48 83 c4 08          	add    $0x8,%rsp
    528e:	5b                   	pop    %rbx
    528f:	5d                   	pop    %rbp
    5290:	41 5c                	pop    %r12
    5292:	41 5d                	pop    %r13
    5294:	c3                   	ret    
    return EFI_NOT_FOUND;
    5295:	48 b8 0e 00 00 00 00 	movabs $0x800000000000000e,%rax
    529c:	00 00 80 
}
    529f:	c3                   	ret    

00000000000052a0 <LibGetUiString>:
    IN  EFI_HANDLE      Handle,
    IN  UI_STRING_TYPE  StringType,
    IN  ISO_639_2       *LangCode,
    IN  BOOLEAN         ReturnDevicePathStrOnMismatch
    )
{
    52a0:	f3 0f 1e fa          	endbr64 
    52a4:	41 56                	push   %r14
    52a6:	41 89 f6             	mov    %esi,%r14d
    52a9:	41 55                	push   %r13
    52ab:	41 89 cd             	mov    %ecx,%r13d
    UI_INTERFACE    *Ui;
    UI_STRING_TYPE  Index;
    UI_STRING_ENTRY *Array;
    EFI_STATUS      Status;
    
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &UiProtocol, (VOID *)&Ui);
    52ae:	48 89 f9             	mov    %rdi,%rcx
{
    52b1:	41 54                	push   %r12
    52b3:	49 89 fc             	mov    %rdi,%r12
    52b6:	55                   	push   %rbp
    52b7:	48 89 d5             	mov    %rdx,%rbp
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &UiProtocol, (VOID *)&Ui);
    52ba:	48 8d 15 ef 79 01 00 	lea    0x179ef(%rip),%rdx        # 1ccb0 <gEFiUiInterfaceProtocolGuid>
{
    52c1:	53                   	push   %rbx
    52c2:	48 83 ec 30          	sub    $0x30,%rsp
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &UiProtocol, (VOID *)&Ui);
    52c6:	48 8b 05 63 83 01 00 	mov    0x18363(%rip),%rax        # 1d630 <BS>
    52cd:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    52d2:	ff 90 98 00 00 00    	call   *0x98(%rax)
    if (EFI_ERROR(Status)) {
    52d8:	48 85 c0             	test   %rax,%rax
    52db:	78 48                	js     5325 <LibGetUiString+0x85>
    }

    //
    // Skip the first strings
    //
    for (Index = UiDeviceString, Array = Ui->Entry; Index < StringType; Index++, Array++) {
    52dd:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    52e2:	48 8b 58 08          	mov    0x8(%rax),%rbx
    52e6:	31 c0                	xor    %eax,%eax
    52e8:	45 85 f6             	test   %r14d,%r14d
    52eb:	75 07                	jne    52f4 <LibGetUiString+0x54>
    52ed:	eb 2e                	jmp    531d <LibGetUiString+0x7d>
    52ef:	90                   	nop
        while (Array->LangCode) {
            Array++;
    52f0:	48 83 c3 10          	add    $0x10,%rbx
        while (Array->LangCode) {
    52f4:	48 83 3b 00          	cmpq   $0x0,(%rbx)
    52f8:	75 f6                	jne    52f0 <LibGetUiString+0x50>
    for (Index = UiDeviceString, Array = Ui->Entry; Index < StringType; Index++, Array++) {
    52fa:	83 c0 01             	add    $0x1,%eax
    52fd:	48 83 c3 10          	add    $0x10,%rbx
    5301:	41 39 c6             	cmp    %eax,%r14d
    5304:	77 ee                	ja     52f4 <LibGetUiString+0x54>
    }

    //
    // Search for the match
    //
    while (Array->LangCode) {
    5306:	48 8b 3b             	mov    (%rbx),%rdi
    5309:	48 85 ff             	test   %rdi,%rdi
    530c:	74 17                	je     5325 <LibGetUiString+0x85>
    530e:	66 90                	xchg   %ax,%ax
        if (strcmpa (Array->LangCode, LangCode) == 0) {
    5310:	48 89 ee             	mov    %rbp,%rsi
    5313:	e8 28 24 00 00       	call   7740 <strcmpa>
    5318:	48 85 c0             	test   %rax,%rax
    531b:	74 39                	je     5356 <LibGetUiString+0xb6>
    while (Array->LangCode) {
    531d:	48 8b 3b             	mov    (%rbx),%rdi
    5320:	48 85 ff             	test   %rdi,%rdi
    5323:	75 eb                	jne    5310 <LibGetUiString+0x70>
        return (ReturnDevicePathStrOnMismatch) ? DevicePathToStr(DevicePathFromHandle(Handle)) : NULL;
    5325:	31 c0                	xor    %eax,%eax
    5327:	45 84 ed             	test   %r13b,%r13b
    532a:	75 0d                	jne    5339 <LibGetUiString+0x99>
            return Array->UiString; 
        }
    }
    return (ReturnDevicePathStrOnMismatch) ? DevicePathToStr(DevicePathFromHandle(Handle)) : NULL;
}
    532c:	48 83 c4 30          	add    $0x30,%rsp
    5330:	5b                   	pop    %rbx
    5331:	5d                   	pop    %rbp
    5332:	41 5c                	pop    %r12
    5334:	41 5d                	pop    %r13
    5336:	41 5e                	pop    %r14
    5338:	c3                   	ret    
    return (ReturnDevicePathStrOnMismatch) ? DevicePathToStr(DevicePathFromHandle(Handle)) : NULL;
    5339:	4c 89 e7             	mov    %r12,%rdi
    533c:	e8 bf 3a 00 00       	call   8e00 <DevicePathFromHandle>
    5341:	48 89 c7             	mov    %rax,%rdi
    5344:	e8 97 41 00 00       	call   94e0 <DevicePathToStr>
}
    5349:	48 83 c4 30          	add    $0x30,%rsp
    534d:	5b                   	pop    %rbx
    534e:	5d                   	pop    %rbp
    534f:	41 5c                	pop    %r12
    5351:	41 5d                	pop    %r13
    5353:	41 5e                	pop    %r14
    5355:	c3                   	ret    
            return Array->UiString; 
    5356:	48 8b 43 08          	mov    0x8(%rbx),%rax
}
    535a:	48 83 c4 30          	add    $0x30,%rsp
    535e:	5b                   	pop    %rbx
    535f:	5d                   	pop    %rbp
    5360:	41 5c                	pop    %r12
    5362:	41 5d                	pop    %r13
    5364:	41 5e                	pop    %r14
    5366:	c3                   	ret    
    5367:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    536e:	00 00 

0000000000005370 <_DbgOut>:
_DbgOut (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
// Append string worker for DbgPrint
{
    5370:	f3 0f 1e fa          	endbr64 
    DbgOut = Context;
//    if (!DbgOut && ST && ST->ConOut) {
//        DbgOut = ST->ConOut;
//    }

    if (DbgOut) {
    5374:	48 85 c9             	test   %rcx,%rcx
    5377:	74 17                	je     5390 <_DbgOut+0x20>
{
    5379:	48 83 ec 28          	sub    $0x28,%rsp
	if (IsLocalPrint(DbgOut->OutputString))
		DbgOut->OutputString(DbgOut, Buffer);
    537d:	ff 51 08             	call   *0x8(%rcx)
        else
		uefi_call_wrapper(DbgOut->OutputString, 2, DbgOut, Buffer);
    }

    return 0;
}
    5380:	31 c0                	xor    %eax,%eax
    5382:	48 83 c4 28          	add    $0x28,%rsp
    5386:	c3                   	ret    
    5387:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    538e:	00 00 
    5390:	31 c0                	xor    %eax,%eax
    5392:	c3                   	ret    
    5393:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    539a:	00 00 00 00 
    539e:	66 90                	xchg   %ax,%ax

00000000000053a0 <_SPrint>:
_SPrint (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
// Append string worker for UnicodeSPrint, PoolPrint and CatPrint
{
    53a0:	f3 0f 1e fa          	endbr64 
    53a4:	41 54                	push   %r12
    53a6:	49 89 d4             	mov    %rdx,%r12
    53a9:	55                   	push   %rbp
    53aa:	48 89 cd             	mov    %rcx,%rbp
    53ad:	57                   	push   %rdi
    UINTN           len;
    POOL_PRINT      *spc;

    spc = Context;
    len = StrLen(Buffer);
    53ae:	48 89 d7             	mov    %rdx,%rdi
{
    53b1:	56                   	push   %rsi
    53b2:	53                   	push   %rbx
    53b3:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    53ba:	0f 29 74 24 20       	movaps %xmm6,0x20(%rsp)
    53bf:	0f 29 7c 24 30       	movaps %xmm7,0x30(%rsp)
    53c4:	44 0f 29 44 24 40    	movaps %xmm8,0x40(%rsp)
    53ca:	44 0f 29 4c 24 50    	movaps %xmm9,0x50(%rsp)
    53d0:	44 0f 29 54 24 60    	movaps %xmm10,0x60(%rsp)
    53d6:	44 0f 29 5c 24 70    	movaps %xmm11,0x70(%rsp)
    53dc:	44 0f 29 a4 24 80 00 	movaps %xmm12,0x80(%rsp)
    53e3:	00 00 
    53e5:	44 0f 29 ac 24 90 00 	movaps %xmm13,0x90(%rsp)
    53ec:	00 00 
    53ee:	44 0f 29 b4 24 a0 00 	movaps %xmm14,0xa0(%rsp)
    53f5:	00 00 
    53f7:	44 0f 29 bc 24 b0 00 	movaps %xmm15,0xb0(%rsp)
    53fe:	00 00 
    len = StrLen(Buffer);
    5400:	e8 9b 22 00 00       	call   76a0 <StrLen>

    //
    // Is the string is over the max truncate it
    //

    if (spc->len + len > spc->maxlen) {
    5405:	48 8b 55 10          	mov    0x10(%rbp),%rdx
    len = StrLen(Buffer);
    5409:	48 89 c3             	mov    %rax,%rbx
    if (spc->len + len > spc->maxlen) {
    540c:	48 8b 45 08          	mov    0x8(%rbp),%rax
        len = spc->maxlen - spc->len;
    5410:	48 89 d1             	mov    %rdx,%rcx
    if (spc->len + len > spc->maxlen) {
    5413:	4c 8d 04 18          	lea    (%rax,%rbx,1),%r8
        len = spc->maxlen - spc->len;
    5417:	48 29 c1             	sub    %rax,%rcx
    541a:	49 39 d0             	cmp    %rdx,%r8

    //
    // Append the new text
    //

    CopyMem (spc->str + spc->len, Buffer, len * sizeof(CHAR16));
    541d:	48 8b 55 00          	mov    0x0(%rbp),%rdx
        len = spc->maxlen - spc->len;
    5421:	48 0f 47 d9          	cmova  %rcx,%rbx
    CopyMem (spc->str + spc->len, Buffer, len * sizeof(CHAR16));
    5425:	48 8d 0c 42          	lea    (%rdx,%rax,2),%rcx
    5429:	4c 89 e2             	mov    %r12,%rdx
    542c:	4c 8d 04 1b          	lea    (%rbx,%rbx,1),%r8
    5430:	e8 0b f6 ff ff       	call   4a40 <CopyMem>

    //
    // Null terminate it
    //

    if (spc->len < spc->maxlen) {
    5435:	48 8b 45 10          	mov    0x10(%rbp),%rax
    spc->len += len;
    5439:	48 03 5d 08          	add    0x8(%rbp),%rbx
    543d:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
    if (spc->len < spc->maxlen) {
    5441:	48 39 c3             	cmp    %rax,%rbx
    5444:	73 6a                	jae    54b0 <_SPrint+0x110>
        spc->str[spc->len] = 0;
    5446:	48 8b 45 00          	mov    0x0(%rbp),%rax
    544a:	45 31 c0             	xor    %r8d,%r8d
    544d:	66 44 89 04 58       	mov    %r8w,(%rax,%rbx,2)
    } else if (spc->maxlen) {
        spc->str[spc->maxlen] = 0;
    }

    return 0;
}
    5452:	0f 28 74 24 20       	movaps 0x20(%rsp),%xmm6
    5457:	0f 28 7c 24 30       	movaps 0x30(%rsp),%xmm7
    545c:	31 c0                	xor    %eax,%eax
    545e:	44 0f 28 44 24 40    	movaps 0x40(%rsp),%xmm8
    5464:	44 0f 28 4c 24 50    	movaps 0x50(%rsp),%xmm9
    546a:	44 0f 28 54 24 60    	movaps 0x60(%rsp),%xmm10
    5470:	44 0f 28 5c 24 70    	movaps 0x70(%rsp),%xmm11
    5476:	44 0f 28 a4 24 80 00 	movaps 0x80(%rsp),%xmm12
    547d:	00 00 
    547f:	44 0f 28 ac 24 90 00 	movaps 0x90(%rsp),%xmm13
    5486:	00 00 
    5488:	44 0f 28 b4 24 a0 00 	movaps 0xa0(%rsp),%xmm14
    548f:	00 00 
    5491:	44 0f 28 bc 24 b0 00 	movaps 0xb0(%rsp),%xmm15
    5498:	00 00 
    549a:	48 81 c4 c0 00 00 00 	add    $0xc0,%rsp
    54a1:	5b                   	pop    %rbx
    54a2:	5e                   	pop    %rsi
    54a3:	5f                   	pop    %rdi
    54a4:	5d                   	pop    %rbp
    54a5:	41 5c                	pop    %r12
    54a7:	c3                   	ret    
    54a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    54af:	00 
    } else if (spc->maxlen) {
    54b0:	48 85 c0             	test   %rax,%rax
    54b3:	74 9d                	je     5452 <_SPrint+0xb2>
        spc->str[spc->maxlen] = 0;
    54b5:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    54b9:	31 c9                	xor    %ecx,%ecx
    54bb:	66 89 0c 42          	mov    %cx,(%rdx,%rax,2)
    54bf:	eb 91                	jmp    5452 <_SPrint+0xb2>
    54c1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    54c8:	00 00 00 00 
    54cc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000054d0 <_PoolPrint>:
_PoolPrint (
    IN VOID     *Context,
    IN CHAR16   *Buffer
    )
// Append string worker for PoolPrint and CatPrint
{
    54d0:	f3 0f 1e fa          	endbr64 
    54d4:	41 55                	push   %r13
    54d6:	49 89 d5             	mov    %rdx,%r13
    54d9:	41 54                	push   %r12
    54db:	49 89 cc             	mov    %rcx,%r12
    54de:	57                   	push   %rdi
    UINTN           newlen;
    POOL_PRINT      *spc;

    spc = Context;
    newlen = spc->len + StrLen(Buffer) + 1;
    54df:	48 89 d7             	mov    %rdx,%rdi
{
    54e2:	56                   	push   %rsi
    54e3:	53                   	push   %rbx
    54e4:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    54eb:	0f 29 34 24          	movaps %xmm6,(%rsp)
    54ef:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    54f4:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    54fa:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    5500:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    5506:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    550c:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    5512:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    5518:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    551f:	00 00 
    5521:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    5528:	00 00 
    newlen = spc->len + StrLen(Buffer) + 1;
    552a:	48 8b 59 08          	mov    0x8(%rcx),%rbx
    552e:	e8 6d 21 00 00       	call   76a0 <StrLen>
    5533:	48 01 d8             	add    %rbx,%rax
    5536:	48 8d 50 01          	lea    0x1(%rax),%rdx

    //
    // Is the string is over the max, grow the buffer
    //

    if (newlen > spc->maxlen) {
    553a:	49 39 54 24 10       	cmp    %rdx,0x10(%r12)
    553f:	72 5f                	jb     55a0 <_PoolPrint+0xd0>
    //
    // Append the new text
    //

    return _SPrint (Context, Buffer);
}
    5541:	0f 28 34 24          	movaps (%rsp),%xmm6
    5545:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    return _SPrint (Context, Buffer);
    554a:	4c 89 ea             	mov    %r13,%rdx
    554d:	4c 89 e1             	mov    %r12,%rcx
}
    5550:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    5556:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    555c:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    5562:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    5568:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    556e:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    5574:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    557b:	00 00 
    557d:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    5584:	00 00 
    5586:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    558d:	5b                   	pop    %rbx
    558e:	5e                   	pop    %rsi
    558f:	5f                   	pop    %rdi
    5590:	41 5c                	pop    %r12
    5592:	41 5d                	pop    %r13
    return _SPrint (Context, Buffer);
    5594:	e9 07 fe ff ff       	jmp    53a0 <_SPrint>
    5599:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        newlen += PRINT_STRING_LEN;
    55a0:	48 05 c9 00 00 00    	add    $0xc9,%rax
        spc->str = ReallocatePool (
    55a6:	49 8b 3c 24          	mov    (%r12),%rdi
        spc->maxlen = newlen;
    55aa:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        spc->str = ReallocatePool (
    55af:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
    55b3:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    55b8:	48 8d 34 00          	lea    (%rax,%rax,1),%rsi
    55bc:	e8 0f f3 ff ff       	call   48d0 <ReallocatePool>
    55c1:	49 89 04 24          	mov    %rax,(%r12)
        if (!spc->str) {
    55c5:	48 85 c0             	test   %rax,%rax
    55c8:	0f 85 73 ff ff ff    	jne    5541 <_PoolPrint+0x71>
            spc->len = 0;
    55ce:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
    55d5:	00 00 
            spc->maxlen = 0;
    55d7:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
    55de:	00 00 
    55e0:	e9 5c ff ff ff       	jmp    5541 <_PoolPrint+0x71>
    55e5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    55ec:	00 00 00 00 

00000000000055f0 <ValueToHex.part.0>:

STATIC CHAR8 Hex[] = {'0','1','2','3','4','5','6','7',
                      '8','9','A','B','C','D','E','F'};

VOID
ValueToHex (
    55f0:	41 56                	push   %r14
    55f2:	41 55                	push   %r13
    55f4:	41 54                	push   %r12
    55f6:	55                   	push   %rbp
    55f7:	48 89 fd             	mov    %rdi,%rbp
    55fa:	53                   	push   %rbx
    55fb:	48 83 ec 20          	sub    $0x20,%rsp
    }

    p1 = str;
    p2 = Buffer;

    while (v) {
    55ff:	48 85 f6             	test   %rsi,%rsi
    5602:	74 69                	je     566d <ValueToHex.part.0+0x7d>
    p1 = str;
    5604:	49 89 e4             	mov    %rsp,%r12
    5607:	48 89 f7             	mov    %rsi,%rdi
    560a:	4c 8d 2d 0f 7b 01 00 	lea    0x17b0f(%rip),%r13        # 1d120 <Hex>
    5611:	4d 89 e6             	mov    %r12,%r14
    5614:	0f 1f 40 00          	nopl   0x0(%rax)
        // Without the cast, the MSVC compiler may insert a reference to __allmull
        *(p1++) = Hex[(UINTN)(v & 0xf)];
    5618:	48 89 f8             	mov    %rdi,%rax
    561b:	49 83 c6 01          	add    $0x1,%r14
        v = RShiftU64 (v, 4);
    561f:	be 04 00 00 00       	mov    $0x4,%esi
        *(p1++) = Hex[(UINTN)(v & 0xf)];
    5624:	83 e0 0f             	and    $0xf,%eax
    5627:	41 0f b6 5c 05 00    	movzbl 0x0(%r13,%rax,1),%ebx
    562d:	41 88 5e ff          	mov    %bl,-0x1(%r14)
        v = RShiftU64 (v, 4);
    5631:	e8 6a 29 00 00       	call   7fa0 <RShiftU64>
    5636:	48 89 c7             	mov    %rax,%rdi
    while (v) {
    5639:	48 85 c0             	test   %rax,%rax
    563c:	75 da                	jne    5618 <ValueToHex.part.0+0x28>
    }

    while (p1 != str) {
    563e:	4d 39 e6             	cmp    %r12,%r14
    5641:	74 2a                	je     566d <ValueToHex.part.0+0x7d>
    p2 = Buffer;
    5643:	48 89 ea             	mov    %rbp,%rdx
    while (p1 != str) {
    5646:	4c 89 f0             	mov    %r14,%rax
    5649:	eb 09                	jmp    5654 <ValueToHex.part.0+0x64>
    564b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        *(p2++) = *(--p1);
    5650:	0f b6 58 ff          	movzbl -0x1(%rax),%ebx
    5654:	48 83 e8 01          	sub    $0x1,%rax
    5658:	48 83 c2 02          	add    $0x2,%rdx
    565c:	66 89 5a fe          	mov    %bx,-0x2(%rdx)
    while (p1 != str) {
    5660:	4c 39 e0             	cmp    %r12,%rax
    5663:	75 eb                	jne    5650 <ValueToHex.part.0+0x60>
        *(p2++) = *(--p1);
    5665:	49 29 c6             	sub    %rax,%r14
    5668:	4a 8d 6c 75 00       	lea    0x0(%rbp,%r14,2),%rbp
    }
    *p2 = 0;
    566d:	31 c0                	xor    %eax,%eax
    566f:	66 89 45 00          	mov    %ax,0x0(%rbp)
}
    5673:	48 83 c4 20          	add    $0x20,%rsp
    5677:	5b                   	pop    %rbx
    5678:	5d                   	pop    %rbp
    5679:	41 5c                	pop    %r12
    567b:	41 5d                	pop    %r13
    567d:	41 5e                	pop    %r14
    567f:	c3                   	ret    

0000000000005680 <IsLocalPrint>:
{
    5680:	f3 0f 1e fa          	endbr64 
	if (func == _DbgOut || func == _SPrint || func == _PoolPrint)
    5684:	48 8d 05 e5 fc ff ff 	lea    -0x31b(%rip),%rax        # 5370 <_DbgOut>
    568b:	48 8d 15 0e fd ff ff 	lea    -0x2f2(%rip),%rdx        # 53a0 <_SPrint>
    5692:	48 39 c7             	cmp    %rax,%rdi
    5695:	0f 94 c0             	sete   %al
    5698:	48 39 d7             	cmp    %rdx,%rdi
    569b:	0f 94 c2             	sete   %dl
		return 1;
    569e:	09 d0                	or     %edx,%eax
	if (func == _DbgOut || func == _SPrint || func == _PoolPrint)
    56a0:	48 8d 15 29 fe ff ff 	lea    -0x1d7(%rip),%rdx        # 54d0 <_PoolPrint>
    56a7:	48 39 d7             	cmp    %rdx,%rdi
    56aa:	0f 94 c2             	sete   %dl
		return 1;
    56ad:	09 d0                	or     %edx,%eax
    56af:	0f b6 c0             	movzbl %al,%eax
}
    56b2:	c3                   	ret    
    56b3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    56ba:	00 00 00 00 
    56be:	66 90                	xchg   %ax,%ax

00000000000056c0 <PFLUSH>:
{
    56c0:	f3 0f 1e fa          	endbr64 
    56c4:	53                   	push   %rbx
    *ps->Pos = 0;
    56c5:	31 d2                	xor    %edx,%edx
{
    56c7:	48 89 fb             	mov    %rdi,%rbx
    56ca:	48 83 ec 20          	sub    $0x20,%rsp
    *ps->Pos = 0;
    56ce:	48 8b 47 40          	mov    0x40(%rdi),%rax
    56d2:	66 89 10             	mov    %dx,(%rax)
	ps->Output(ps->Context, ps->Buffer);
    56d5:	48 8b 57 30          	mov    0x30(%rdi),%rdx
    56d9:	48 8b 8f 88 00 00 00 	mov    0x88(%rdi),%rcx
    56e0:	ff 57 78             	call   *0x78(%rdi)
    ps->Pos = ps->Buffer;
    56e3:	48 8b 43 30          	mov    0x30(%rbx),%rax
    56e7:	48 89 43 40          	mov    %rax,0x40(%rbx)
}
    56eb:	48 83 c4 20          	add    $0x20,%rsp
    56ef:	5b                   	pop    %rbx
    56f0:	c3                   	ret    
    56f1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    56f8:	00 00 00 00 
    56fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000005700 <PSETATTR>:
{
    5700:	f3 0f 1e fa          	endbr64 
    5704:	55                   	push   %rbp
    5705:	48 89 f5             	mov    %rsi,%rbp
    5708:	53                   	push   %rbx
    5709:	48 89 fb             	mov    %rdi,%rbx
    570c:	48 83 ec 28          	sub    $0x28,%rsp
   PFLUSH (ps);
    5710:	e8 ab ff ff ff       	call   56c0 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    5715:	48 8b 43 50          	mov    0x50(%rbx),%rax
    5719:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    571d:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    5724:	48 85 c0             	test   %rax,%rax
    5727:	74 0c                	je     5735 <PSETATTR+0x35>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    5729:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    5730:	48 89 ea             	mov    %rbp,%rdx
    5733:	ff d0                	call   *%rax
   ps->Attr = Attr;
    5735:	48 89 6b 50          	mov    %rbp,0x50(%rbx)
}
    5739:	48 83 c4 28          	add    $0x28,%rsp
    573d:	5b                   	pop    %rbx
    573e:	5d                   	pop    %rbp
    573f:	c3                   	ret    

0000000000005740 <PPUTC>:
{
    5740:	f3 0f 1e fa          	endbr64 
    5744:	48 83 ec 18          	sub    $0x18,%rsp
    *ps->Pos = c;
    5748:	48 8b 47 40          	mov    0x40(%rdi),%rax
    if (c == '\n') {
    574c:	66 83 fe 0a          	cmp    $0xa,%si
    5750:	74 36                	je     5788 <PPUTC+0x48>
    *ps->Pos = c;
    5752:	66 89 30             	mov    %si,(%rax)
    ps->Pos += 1;
    5755:	48 8b 47 40          	mov    0x40(%rdi),%rax
    ps->Len += 1;
    5759:	48 83 47 48 01       	addq   $0x1,0x48(%rdi)
    ps->Pos += 1;
    575e:	48 83 c0 02          	add    $0x2,%rax
    5762:	48 89 47 40          	mov    %rax,0x40(%rdi)
    if (ps->Pos >= ps->End) {
    5766:	48 3b 47 38          	cmp    0x38(%rdi),%rax
    576a:	73 0c                	jae    5778 <PPUTC+0x38>
}
    576c:	48 83 c4 18          	add    $0x18,%rsp
    5770:	c3                   	ret    
    5771:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    5778:	48 83 c4 18          	add    $0x18,%rsp
        PFLUSH(ps);
    577c:	e9 3f ff ff ff       	jmp    56c0 <PFLUSH>
    5781:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    *ps->Pos = c;
    5788:	ba 0d 00 00 00       	mov    $0xd,%edx
    578d:	66 89 10             	mov    %dx,(%rax)
    ps->Pos += 1;
    5790:	48 8b 47 40          	mov    0x40(%rdi),%rax
    ps->Len += 1;
    5794:	48 83 47 48 01       	addq   $0x1,0x48(%rdi)
    ps->Pos += 1;
    5799:	48 83 c0 02          	add    $0x2,%rax
    579d:	48 89 47 40          	mov    %rax,0x40(%rdi)
    if (ps->Pos >= ps->End) {
    57a1:	48 3b 47 38          	cmp    0x38(%rdi),%rax
    57a5:	72 ab                	jb     5752 <PPUTC+0x12>
    57a7:	89 74 24 0c          	mov    %esi,0xc(%rsp)
        PFLUSH(ps);
    57ab:	48 89 3c 24          	mov    %rdi,(%rsp)
    57af:	e8 0c ff ff ff       	call   56c0 <PFLUSH>
    *ps->Pos = c;
    57b4:	48 8b 3c 24          	mov    (%rsp),%rdi
    57b8:	8b 74 24 0c          	mov    0xc(%rsp),%esi
    57bc:	48 8b 47 40          	mov    0x40(%rdi),%rax
    57c0:	eb 90                	jmp    5752 <PPUTC+0x12>
    57c2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    57c9:	00 00 00 00 
    57cd:	0f 1f 00             	nopl   (%rax)

00000000000057d0 <PGETC>:
{
    57d0:	f3 0f 1e fa          	endbr64 
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    57d4:	80 3f 00             	cmpb   $0x0,(%rdi)
    57d7:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    57db:	48 8b 47 08          	mov    0x8(%rdi),%rax
    57df:	74 17                	je     57f8 <PGETC+0x28>
    57e1:	44 0f b6 04 02       	movzbl (%rdx,%rax,1),%r8d
    p->Index += 1;
    57e6:	48 83 c0 01          	add    $0x1,%rax
    57ea:	48 89 47 08          	mov    %rax,0x8(%rdi)
}
    57ee:	44 89 c0             	mov    %r8d,%eax
    57f1:	c3                   	ret    
    57f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    57f8:	44 0f b7 04 42       	movzwl (%rdx,%rax,2),%r8d
    p->Index += 1;
    57fd:	48 83 c0 01          	add    $0x1,%rax
    5801:	48 89 47 08          	mov    %rax,0x8(%rdi)
}
    5805:	44 89 c0             	mov    %r8d,%eax
    5808:	c3                   	ret    
    5809:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000005810 <PITEM>:
{
    5810:	f3 0f 1e fa          	endbr64 
    5814:	41 56                	push   %r14
    5816:	41 55                	push   %r13
    5818:	41 54                	push   %r12
    while (Item->Item.Index < Item->FieldWidth) {
    581a:	45 31 e4             	xor    %r12d,%r12d
{
    581d:	55                   	push   %rbp
    581e:	53                   	push   %rbx
    Item = ps->Item;
    581f:	48 8b af 90 00 00 00 	mov    0x90(%rdi),%rbp
{
    5826:	48 89 fb             	mov    %rdi,%rbx
    Item->Item.Index = 0;
    5829:	48 c7 45 08 00 00 00 	movq   $0x0,0x8(%rbp)
    5830:	00 
    while (Item->Item.Index < Item->FieldWidth) {
    5831:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx
    5838:	eb 1c                	jmp    5856 <PITEM+0x46>
    583a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5840:	42 0f b6 14 20       	movzbl (%rax,%r12,1),%edx
    p->Index += 1;
    5845:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    584a:	48 89 45 08          	mov    %rax,0x8(%rbp)
        if (!c) {
    584e:	66 85 d2             	test   %dx,%dx
    5851:	74 25                	je     5878 <PITEM+0x68>
    5853:	49 89 c4             	mov    %rax,%r12
    while (Item->Item.Index < Item->FieldWidth) {
    5856:	4c 39 e1             	cmp    %r12,%rcx
    5859:	74 21                	je     587c <PITEM+0x6c>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    585b:	80 7d 00 00          	cmpb   $0x0,0x0(%rbp)
    585f:	48 8b 45 10          	mov    0x10(%rbp),%rax
    5863:	75 db                	jne    5840 <PITEM+0x30>
    5865:	42 0f b7 14 60       	movzwl (%rax,%r12,2),%edx
    p->Index += 1;
    586a:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    586f:	48 89 45 08          	mov    %rax,0x8(%rbp)
        if (!c) {
    5873:	66 85 d2             	test   %dx,%dx
    5876:	75 db                	jne    5853 <PITEM+0x43>
            Item->Item.Index -= 1;
    5878:	4c 89 65 08          	mov    %r12,0x8(%rbp)
    if (Item->FieldWidth == (UINTN) -1) {
    587c:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
    5880:	75 07                	jne    5889 <PITEM+0x79>
        Item->FieldWidth = Len;
    5882:	4c 89 a5 e8 00 00 00 	mov    %r12,0xe8(%rbp)
    if (Len > Item->Width) {
    5889:	4c 8b ad e0 00 00 00 	mov    0xe0(%rbp),%r13
    if (Item->PadBefore) {
    5890:	0f b6 85 fa 00 00 00 	movzbl 0xfa(%rbp),%eax
    if (Len > Item->Width) {
    5897:	4d 39 e5             	cmp    %r12,%r13
    589a:	0f 83 d8 01 00 00    	jae    5a78 <PITEM+0x268>
        Item->Width = Len;
    58a0:	4c 89 a5 e0 00 00 00 	mov    %r12,0xe0(%rbp)
    if (Item->PadBefore) {
    58a7:	84 c0                	test   %al,%al
    58a9:	0f 84 c5 00 00 00    	je     5974 <PITEM+0x164>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    58af:	4c 3b a5 e8 00 00 00 	cmp    0xe8(%rbp),%r12
    58b6:	0f 83 b8 00 00 00    	jae    5974 <PITEM+0x164>
    58bc:	4d 89 e5             	mov    %r12,%r13
    58bf:	eb 14                	jmp    58d5 <PITEM+0xc5>
    58c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    58c8:	49 83 c5 01          	add    $0x1,%r13
    58cc:	4c 39 ad e8 00 00 00 	cmp    %r13,0xe8(%rbp)
    58d3:	76 38                	jbe    590d <PITEM+0xfd>
    *ps->Pos = c;
    58d5:	48 8b 43 40          	mov    0x40(%rbx),%rax
    58d9:	bf 20 00 00 00       	mov    $0x20,%edi
    58de:	66 89 38             	mov    %di,(%rax)
    ps->Pos += 1;
    58e1:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    58e5:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    58ea:	48 83 c0 02          	add    $0x2,%rax
    58ee:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    58f2:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    58f6:	72 d0                	jb     58c8 <PITEM+0xb8>
        PFLUSH(ps);
    58f8:	48 89 df             	mov    %rbx,%rdi
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    58fb:	49 83 c5 01          	add    $0x1,%r13
        PFLUSH(ps);
    58ff:	e8 bc fd ff ff       	call   56c0 <PFLUSH>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    5904:	4c 39 ad e8 00 00 00 	cmp    %r13,0xe8(%rbp)
    590b:	77 c8                	ja     58d5 <PITEM+0xc5>
    for (i=Len; i < Item->Width; i++) {
    590d:	4c 8b ad e0 00 00 00 	mov    0xe0(%rbp),%r13
    5914:	4d 39 ec             	cmp    %r13,%r12
    5917:	73 5b                	jae    5974 <PITEM+0x164>
    5919:	4d 89 e5             	mov    %r12,%r13
    591c:	eb 0f                	jmp    592d <PITEM+0x11d>
    591e:	66 90                	xchg   %ax,%ax
    5920:	49 83 c5 01          	add    $0x1,%r13
    5924:	4c 39 ad e0 00 00 00 	cmp    %r13,0xe0(%rbp)
    592b:	76 47                	jbe    5974 <PITEM+0x164>
        PPUTC (ps, Item->Pad);
    592d:	44 0f b7 b5 f8 00 00 	movzwl 0xf8(%rbp),%r14d
    5934:	00 
    *ps->Pos = c;
    5935:	48 8b 43 40          	mov    0x40(%rbx),%rax
    if (c == '\n') {
    5939:	66 41 83 fe 0a       	cmp    $0xa,%r14w
    593e:	0f 84 54 01 00 00    	je     5a98 <PITEM+0x288>
    *ps->Pos = c;
    5944:	66 44 89 30          	mov    %r14w,(%rax)
    ps->Pos += 1;
    5948:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    594c:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    5951:	48 83 c0 02          	add    $0x2,%rax
    5955:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    5959:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    595d:	72 c1                	jb     5920 <PITEM+0x110>
        PFLUSH(ps);
    595f:	48 89 df             	mov    %rbx,%rdi
    for (i=Len; i < Item->Width; i++) {
    5962:	49 83 c5 01          	add    $0x1,%r13
        PFLUSH(ps);
    5966:	e8 55 fd ff ff       	call   56c0 <PFLUSH>
    for (i=Len; i < Item->Width; i++) {
    596b:	4c 39 ad e0 00 00 00 	cmp    %r13,0xe0(%rbp)
    5972:	77 b9                	ja     592d <PITEM+0x11d>
    Item->Item.Index=0;
    5974:	48 c7 45 08 00 00 00 	movq   $0x0,0x8(%rbp)
    597b:	00 
    while (Item->Item.Index < Len) {
    597c:	31 c0                	xor    %eax,%eax
    597e:	eb 37                	jmp    59b7 <PITEM+0x1a7>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5980:	44 0f b6 2c 02       	movzbl (%rdx,%rax,1),%r13d
    p->Index += 1;
    5985:	48 83 c0 01          	add    $0x1,%rax
    5989:	48 89 45 08          	mov    %rax,0x8(%rbp)
    *ps->Pos = c;
    598d:	48 8b 43 40          	mov    0x40(%rbx),%rax
    if (c == '\n') {
    5991:	66 41 83 fd 0a       	cmp    $0xa,%r13w
    5996:	74 48                	je     59e0 <PITEM+0x1d0>
    *ps->Pos = c;
    5998:	66 44 89 28          	mov    %r13w,(%rax)
    ps->Pos += 1;
    599c:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    59a0:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    59a5:	48 83 c0 02          	add    $0x2,%rax
    59a9:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    59ad:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    59b1:	73 1d                	jae    59d0 <PITEM+0x1c0>
    while (Item->Item.Index < Len) {
    59b3:	48 8b 45 08          	mov    0x8(%rbp),%rax
    59b7:	4c 39 e0             	cmp    %r12,%rax
    59ba:	73 54                	jae    5a10 <PITEM+0x200>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    59bc:	80 7d 00 00          	cmpb   $0x0,0x0(%rbp)
    59c0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
    59c4:	75 ba                	jne    5980 <PITEM+0x170>
    59c6:	44 0f b7 2c 42       	movzwl (%rdx,%rax,2),%r13d
    59cb:	eb b8                	jmp    5985 <PITEM+0x175>
    59cd:	0f 1f 00             	nopl   (%rax)
        PFLUSH(ps);
    59d0:	48 89 df             	mov    %rbx,%rdi
    59d3:	e8 e8 fc ff ff       	call   56c0 <PFLUSH>
    59d8:	eb d9                	jmp    59b3 <PITEM+0x1a3>
    59da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    *ps->Pos = c;
    59e0:	b9 0d 00 00 00       	mov    $0xd,%ecx
    59e5:	66 89 08             	mov    %cx,(%rax)
    ps->Pos += 1;
    59e8:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    59ec:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    59f1:	48 83 c0 02          	add    $0x2,%rax
    59f5:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    59f9:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    59fd:	72 99                	jb     5998 <PITEM+0x188>
        PFLUSH(ps);
    59ff:	48 89 df             	mov    %rbx,%rdi
    5a02:	e8 b9 fc ff ff       	call   56c0 <PFLUSH>
    *ps->Pos = c;
    5a07:	48 8b 43 40          	mov    0x40(%rbx),%rax
    5a0b:	eb 8b                	jmp    5998 <PITEM+0x188>
    5a0d:	0f 1f 00             	nopl   (%rax)
    if (!Item->PadBefore) {
    5a10:	80 bd fa 00 00 00 00 	cmpb   $0x0,0xfa(%rbp)
    5a17:	75 10                	jne    5a29 <PITEM+0x219>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    5a19:	4c 8b a5 e0 00 00 00 	mov    0xe0(%rbp),%r12
    5a20:	4c 3b a5 e8 00 00 00 	cmp    0xe8(%rbp),%r12
    5a27:	72 24                	jb     5a4d <PITEM+0x23d>
}
    5a29:	5b                   	pop    %rbx
    5a2a:	5d                   	pop    %rbp
    5a2b:	41 5c                	pop    %r12
    5a2d:	41 5d                	pop    %r13
    5a2f:	41 5e                	pop    %r14
    5a31:	c3                   	ret    
    5a32:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        PFLUSH(ps);
    5a38:	48 89 df             	mov    %rbx,%rdi
    5a3b:	e8 80 fc ff ff       	call   56c0 <PFLUSH>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    5a40:	49 83 c4 01          	add    $0x1,%r12
    5a44:	4c 39 a5 e8 00 00 00 	cmp    %r12,0xe8(%rbp)
    5a4b:	76 dc                	jbe    5a29 <PITEM+0x219>
    *ps->Pos = c;
    5a4d:	48 8b 43 40          	mov    0x40(%rbx),%rax
    5a51:	ba 20 00 00 00       	mov    $0x20,%edx
    5a56:	66 89 10             	mov    %dx,(%rax)
    ps->Pos += 1;
    5a59:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    5a5d:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    5a62:	48 83 c0 02          	add    $0x2,%rax
    5a66:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    5a6a:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    5a6e:	72 d0                	jb     5a40 <PITEM+0x230>
    5a70:	eb c6                	jmp    5a38 <PITEM+0x228>
    5a72:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (Item->PadBefore) {
    5a78:	84 c0                	test   %al,%al
    5a7a:	0f 84 94 fe ff ff    	je     5914 <PITEM+0x104>
        for (i=Item->Width; i < Item->FieldWidth; i+=1) {
    5a80:	4c 39 ad e8 00 00 00 	cmp    %r13,0xe8(%rbp)
    5a87:	0f 86 87 fe ff ff    	jbe    5914 <PITEM+0x104>
    5a8d:	e9 43 fe ff ff       	jmp    58d5 <PITEM+0xc5>
    5a92:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    *ps->Pos = c;
    5a98:	be 0d 00 00 00       	mov    $0xd,%esi
    5a9d:	66 89 30             	mov    %si,(%rax)
    ps->Pos += 1;
    5aa0:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    5aa4:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    5aa9:	48 83 c0 02          	add    $0x2,%rax
    5aad:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    5ab1:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    5ab5:	0f 82 89 fe ff ff    	jb     5944 <PITEM+0x134>
        PFLUSH(ps);
    5abb:	48 89 df             	mov    %rbx,%rdi
    5abe:	e8 fd fb ff ff       	call   56c0 <PFLUSH>
    *ps->Pos = c;
    5ac3:	48 8b 43 40          	mov    0x40(%rbx),%rax
    5ac7:	e9 78 fe ff ff       	jmp    5944 <PITEM+0x134>
    5acc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000005ad0 <ValueToHex>:
{
    5ad0:	f3 0f 1e fa          	endbr64 
    if (!v) {
    5ad4:	48 85 f6             	test   %rsi,%rsi
    5ad7:	74 07                	je     5ae0 <ValueToHex+0x10>
    5ad9:	e9 12 fb ff ff       	jmp    55f0 <ValueToHex.part.0>
    5ade:	66 90                	xchg   %ax,%ax
        Buffer[0] = '0';
    5ae0:	c7 07 30 00 00 00    	movl   $0x30,(%rdi)
}
    5ae6:	c3                   	ret    
    5ae7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    5aee:	00 00 

0000000000005af0 <ValueToString>:
ValueToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN INT64    v
    )
{
    5af0:	f3 0f 1e fa          	endbr64 
    5af4:	41 56                	push   %r14
    5af6:	49 89 fe             	mov    %rdi,%r14
    STATIC CHAR8 ca[] = {  3, 1, 2 };
    5af9:	bf 03 01 00 00       	mov    $0x103,%edi
{
    5afe:	41 55                	push   %r13
    5b00:	41 54                	push   %r12
    5b02:	55                   	push   %rbp
    5b03:	53                   	push   %rbx
    5b04:	48 83 ec 40          	sub    $0x40,%rsp
    STATIC CHAR8 ca[] = {  3, 1, 2 };
    5b08:	66 89 7c 24 05       	mov    %di,0x5(%rsp)
    5b0d:	c6 44 24 07 02       	movb   $0x2,0x7(%rsp)
    CHAR8        str[40], *p1;
    CHAR16       *p2;
    UINTN        c, r;

    if (!v) {
    5b12:	48 85 d2             	test   %rdx,%rdx
    5b15:	0f 84 f5 00 00 00    	je     5c10 <ValueToString+0x120>
    5b1b:	41 89 f5             	mov    %esi,%r13d
    5b1e:	48 89 d7             	mov    %rdx,%rdi
    }

    p1 = str;
    p2 = Buffer;

    if (v < 0) {
    5b21:	0f 88 d1 00 00 00    	js     5bf8 <ValueToString+0x108>
{
    5b27:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
    5b2c:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
    5b31:	48 89 eb             	mov    %rbp,%rbx
    5b34:	0f 1f 40 00          	nopl   0x0(%rax)
        *(p2++) = '-';
        v = -v;
    }

    while (v) {
        v = (INT64)DivU64x32 ((UINT64)v, 10, &r);
    5b38:	4c 89 e2             	mov    %r12,%rdx
    5b3b:	be 0a 00 00 00       	mov    $0xa,%esi
        *(p1++) = (CHAR8)r + '0';
    5b40:	48 83 c3 01          	add    $0x1,%rbx
        v = (INT64)DivU64x32 ((UINT64)v, 10, &r);
    5b44:	e8 77 24 00 00       	call   7fc0 <DivU64x32>
    5b49:	48 89 c7             	mov    %rax,%rdi
        *(p1++) = (CHAR8)r + '0';
    5b4c:	0f b6 44 24 08       	movzbl 0x8(%rsp),%eax
    5b51:	8d 48 30             	lea    0x30(%rax),%ecx
    5b54:	88 4b ff             	mov    %cl,-0x1(%rbx)
    while (v) {
    5b57:	48 85 ff             	test   %rdi,%rdi
    5b5a:	75 dc                	jne    5b38 <ValueToString+0x48>
    }

    c = (UINTN) (Comma ? ca[(p1 - str) % 3] : 999) + 1;
    5b5c:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    5b61:	45 84 ed             	test   %r13b,%r13b
    5b64:	75 5a                	jne    5bc0 <ValueToString+0xd0>
    while (p1 != str) {
    5b66:	48 39 eb             	cmp    %rbp,%rbx
    5b69:	75 0c                	jne    5b77 <ValueToString+0x87>
    5b6b:	e9 b8 00 00 00       	jmp    5c28 <ValueToString+0x138>
        if (!c) {
            *(p2++) = ',';
            c = 3;
        }

        *(p2++) = *(--p1);
    5b70:	0f b6 4b ff          	movzbl -0x1(%rbx),%ecx
    5b74:	49 89 d6             	mov    %rdx,%r14
        if (!c) {
    5b77:	48 83 e8 01          	sub    $0x1,%rax
    5b7b:	75 13                	jne    5b90 <ValueToString+0xa0>
            *(p2++) = ',';
    5b7d:	ba 2c 00 00 00       	mov    $0x2c,%edx
    5b82:	49 83 c6 02          	add    $0x2,%r14
            c = 3;
    5b86:	b8 03 00 00 00       	mov    $0x3,%eax
            *(p2++) = ',';
    5b8b:	66 41 89 56 fe       	mov    %dx,-0x2(%r14)
        *(p2++) = *(--p1);
    5b90:	0f b6 c9             	movzbl %cl,%ecx
    5b93:	48 83 eb 01          	sub    $0x1,%rbx
    5b97:	49 8d 56 02          	lea    0x2(%r14),%rdx
    5b9b:	66 41 89 0e          	mov    %cx,(%r14)
    while (p1 != str) {
    5b9f:	48 39 eb             	cmp    %rbp,%rbx
    5ba2:	75 cc                	jne    5b70 <ValueToString+0x80>
    }
    *p2 = 0;
    5ba4:	31 c0                	xor    %eax,%eax
    5ba6:	66 89 02             	mov    %ax,(%rdx)
}
    5ba9:	48 83 c4 40          	add    $0x40,%rsp
    5bad:	5b                   	pop    %rbx
    5bae:	5d                   	pop    %rbp
    5baf:	41 5c                	pop    %r12
    5bb1:	41 5d                	pop    %r13
    5bb3:	41 5e                	pop    %r14
    5bb5:	c3                   	ret    
    5bb6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    5bbd:	00 00 00 
    c = (UINTN) (Comma ? ca[(p1 - str) % 3] : 999) + 1;
    5bc0:	48 ba 56 55 55 55 55 	movabs $0x5555555555555556,%rdx
    5bc7:	55 55 55 
    5bca:	48 89 de             	mov    %rbx,%rsi
    5bcd:	48 29 ee             	sub    %rbp,%rsi
    5bd0:	48 89 f0             	mov    %rsi,%rax
    5bd3:	48 f7 ea             	imul   %rdx
    5bd6:	48 89 f0             	mov    %rsi,%rax
    5bd9:	48 c1 f8 3f          	sar    $0x3f,%rax
    5bdd:	48 29 c2             	sub    %rax,%rdx
    5be0:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax
    5be4:	48 29 c6             	sub    %rax,%rsi
    5be7:	0f b6 44 34 05       	movzbl 0x5(%rsp,%rsi,1),%eax
    5bec:	48 83 c0 01          	add    $0x1,%rax
    5bf0:	e9 71 ff ff ff       	jmp    5b66 <ValueToString+0x76>
    5bf5:	0f 1f 00             	nopl   (%rax)
        *(p2++) = '-';
    5bf8:	b9 2d 00 00 00       	mov    $0x2d,%ecx
        v = -v;
    5bfd:	48 f7 df             	neg    %rdi
        *(p2++) = '-';
    5c00:	49 83 c6 02          	add    $0x2,%r14
    5c04:	66 41 89 4e fe       	mov    %cx,-0x2(%r14)
        v = -v;
    5c09:	e9 19 ff ff ff       	jmp    5b27 <ValueToString+0x37>
    5c0e:	66 90                	xchg   %ax,%ax
        Buffer[0] = '0';
    5c10:	41 c7 06 30 00 00 00 	movl   $0x30,(%r14)
}
    5c17:	48 83 c4 40          	add    $0x40,%rsp
    5c1b:	5b                   	pop    %rbx
    5c1c:	5d                   	pop    %rbp
    5c1d:	41 5c                	pop    %r12
    5c1f:	41 5d                	pop    %r13
    5c21:	41 5e                	pop    %r14
    5c23:	c3                   	ret    
    5c24:	0f 1f 40 00          	nopl   0x0(%rax)
    while (p1 != str) {
    5c28:	4c 89 f2             	mov    %r14,%rdx
    5c2b:	e9 74 ff ff ff       	jmp    5ba4 <ValueToString+0xb4>

0000000000005c30 <FloatToString>:
FloatToString (
    IN CHAR16   *Buffer,
    IN BOOLEAN  Comma,
    IN double   v
    )
{
    5c30:	f3 0f 1e fa          	endbr64 
    5c34:	55                   	push   %rbp
    /*
     * Integer part.
     */
    INTN i = (INTN)v;
    5c35:	f2 48 0f 2c e8       	cvttsd2si %xmm0,%rbp
    ValueToString(Buffer, Comma, i);
    5c3a:	40 0f b6 f6          	movzbl %sil,%esi
{
    5c3e:	53                   	push   %rbx
    5c3f:	48 89 fb             	mov    %rdi,%rbx
    5c42:	48 83 ec 18          	sub    $0x18,%rsp
    ValueToString(Buffer, Comma, i);
    5c46:	48 89 ea             	mov    %rbp,%rdx
    INTN i = (INTN)v;
    5c49:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
    ValueToString(Buffer, Comma, i);
    5c4f:	e8 9c fe ff ff       	call   5af0 <ValueToString>


    /*
     * Decimal point.
     */
    UINTN x = StrLen(Buffer);
    5c54:	48 89 df             	mov    %rbx,%rdi
    5c57:	e8 44 1a 00 00       	call   76a0 <StrLen>


    /*
     * Keep fractional part.
     */
    float f = (float)(v - i);
    5c5c:	66 0f ef c9          	pxor   %xmm1,%xmm1
    5c60:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
    Buffer[x] = L'.';
    5c66:	b9 2e 00 00 00       	mov    $0x2e,%ecx
    float f = (float)(v - i);
    5c6b:	f2 48 0f 2a cd       	cvtsi2sd %rbp,%xmm1
    if (f < 0) f = -f;
    5c70:	66 0f ef d2          	pxor   %xmm2,%xmm2
    Buffer[x] = L'.';
    5c74:	66 89 0c 43          	mov    %cx,(%rbx,%rax,2)
    x++;
    5c78:	48 83 c0 01          	add    $0x1,%rax
    float f = (float)(v - i);
    5c7c:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
    5c80:	f2 0f 5a c0          	cvtsd2ss %xmm0,%xmm0
    if (f < 0) f = -f;
    5c84:	0f 2f d0             	comiss %xmm0,%xmm2
    5c87:	76 07                	jbe    5c90 <FloatToString+0x60>
    5c89:	0f 57 05 b0 3c 02 00 	xorps  0x23cb0(%rip),%xmm0        # 29940 <_DYNAMIC+0xb940>


    /*
     * Leading fractional zeroes.
     */
    f *= 10.0;
    5c90:	f3 0f 10 0d b8 3c 02 	movss  0x23cb8(%rip),%xmm1        # 29950 <_DYNAMIC+0xb950>
    5c97:	00 
    5c98:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
    while (   (f != 0)
           && ((INTN)f == 0))
    5c9c:	0f 2e c2             	ucomiss %xmm2,%xmm0
    5c9f:	7a 07                	jp     5ca8 <FloatToString+0x78>
    5ca1:	74 27                	je     5cca <FloatToString+0x9a>
    5ca3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5ca8:	f3 48 0f 2c d0       	cvttss2si %xmm0,%rdx
    5cad:	48 85 d2             	test   %rdx,%rdx
    5cb0:	75 1d                	jne    5ccf <FloatToString+0x9f>
    {
      Buffer[x] = L'0';
      x++;
      f *= 10.0;
    5cb2:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
      Buffer[x] = L'0';
    5cb6:	ba 30 00 00 00       	mov    $0x30,%edx
    5cbb:	66 89 14 43          	mov    %dx,(%rbx,%rax,2)
      x++;
    5cbf:	48 83 c0 01          	add    $0x1,%rax
           && ((INTN)f == 0))
    5cc3:	0f 2e c2             	ucomiss %xmm2,%xmm0
    5cc6:	7a e0                	jp     5ca8 <FloatToString+0x78>
    5cc8:	75 de                	jne    5ca8 <FloatToString+0x78>


    /*
     * Fractional digits.
     */
    while ((float)(INTN)f != f)
    5cca:	f3 48 0f 2c d0       	cvttss2si %xmm0,%rdx
    5ccf:	66 0f ef d2          	pxor   %xmm2,%xmm2
    5cd3:	f3 48 0f 2a d2       	cvtsi2ss %rdx,%xmm2
    5cd8:	0f 2e c2             	ucomiss %xmm2,%xmm0
    5cdb:	7a 03                	jp     5ce0 <FloatToString+0xb0>
    5cdd:	74 1a                	je     5cf9 <FloatToString+0xc9>
    5cdf:	90                   	nop
    {
      f *= 10;
    5ce0:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
    while ((float)(INTN)f != f)
    5ce4:	66 0f ef d2          	pxor   %xmm2,%xmm2
    5ce8:	f3 48 0f 2c d0       	cvttss2si %xmm0,%rdx
    5ced:	f3 48 0f 2a d2       	cvtsi2ss %rdx,%xmm2
    5cf2:	0f 2e d0             	ucomiss %xmm0,%xmm2
    5cf5:	7a e9                	jp     5ce0 <FloatToString+0xb0>
    5cf7:	75 e7                	jne    5ce0 <FloatToString+0xb0>
    }
    ValueToString(Buffer + x, FALSE, (INTN)f);
    return;
}
    5cf9:	48 83 c4 18          	add    $0x18,%rsp
    ValueToString(Buffer + x, FALSE, (INTN)f);
    5cfd:	48 8d 3c 43          	lea    (%rbx,%rax,2),%rdi
    5d01:	31 f6                	xor    %esi,%esi
}
    5d03:	5b                   	pop    %rbx
    5d04:	5d                   	pop    %rbp
    ValueToString(Buffer + x, FALSE, (INTN)f);
    5d05:	e9 e6 fd ff ff       	jmp    5af0 <ValueToString>
    5d0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000005d10 <TimeToString>:
VOID
TimeToString (
    OUT CHAR16      *Buffer,
    IN EFI_TIME     *Time
    )
{
    5d10:	f3 0f 1e fa          	endbr64 
    5d14:	48 83 ec 28          	sub    $0x28,%rsp
    UINTN       Hour, Year;
    CHAR16      AmPm;

    AmPm = 'a';
    Hour = Time->Hour;
    5d18:	0f b6 46 04          	movzbl 0x4(%rsi),%eax
{
    5d1c:	48 89 f2             	mov    %rsi,%rdx
    if (Time->Hour == 0) {
    5d1f:	84 c0                	test   %al,%al
    5d21:	74 75                	je     5d98 <TimeToString+0x88>
    Hour = Time->Hour;
    5d23:	0f b6 c8             	movzbl %al,%ecx
        Hour = 12;
    } else if (Time->Hour >= 12) {
    5d26:	be 61 00 00 00       	mov    $0x61,%esi
    5d2b:	3c 0b                	cmp    $0xb,%al
    5d2d:	76 0d                	jbe    5d3c <TimeToString+0x2c>
        AmPm = 'p';
        if (Time->Hour >= 13) {
    5d2f:	3c 0c                	cmp    $0xc,%al
    5d31:	74 75                	je     5da8 <TimeToString+0x98>
            Hour -= 12;
    5d33:	48 83 e9 0c          	sub    $0xc,%rcx
    5d37:	be 70 00 00 00       	mov    $0x70,%esi
        }
    }

    Year = Time->Year % 100;
    5d3c:	44 0f b7 0a          	movzwl (%rdx),%r9d

    // bugbug: for now just print it any old way
    UnicodeSPrint (Buffer, 0, L"%02d/%02d/%02d  %02d:%02d%c",
    5d40:	44 0f b6 52 02       	movzbl 0x2(%rdx),%r10d
    5d45:	44 0f b6 42 03       	movzbl 0x3(%rdx),%r8d
    5d4a:	89 74 24 10          	mov    %esi,0x10(%rsp)
    5d4e:	31 f6                	xor    %esi,%esi
    Year = Time->Year % 100;
    5d50:	44 89 c8             	mov    %r9d,%eax
    5d53:	66 c1 e8 02          	shr    $0x2,%ax
    5d57:	0f b7 c0             	movzwl %ax,%eax
    5d5a:	69 c0 7b 14 00 00    	imul   $0x147b,%eax,%eax
    5d60:	c1 e8 11             	shr    $0x11,%eax
    5d63:	8d 04 80             	lea    (%rax,%rax,4),%eax
    5d66:	8d 04 80             	lea    (%rax,%rax,4),%eax
    5d69:	c1 e0 02             	shl    $0x2,%eax
    5d6c:	41 29 c1             	sub    %eax,%r9d
    UnicodeSPrint (Buffer, 0, L"%02d/%02d/%02d  %02d:%02d%c",
    5d6f:	0f b6 42 05          	movzbl 0x5(%rdx),%eax
    5d73:	48 89 0c 24          	mov    %rcx,(%rsp)
    5d77:	48 8d 15 b2 39 02 00 	lea    0x239b2(%rip),%rdx        # 29730 <_DYNAMIC+0xb730>
    5d7e:	45 0f b7 c9          	movzwl %r9w,%r9d
    5d82:	44 89 d1             	mov    %r10d,%ecx
    5d85:	89 44 24 08          	mov    %eax,0x8(%rsp)
    5d89:	31 c0                	xor    %eax,%eax
    5d8b:	e8 e0 0e 00 00       	call   6c70 <UnicodeSPrint>
        Year,
        Hour,
        Time->Minute,
        AmPm
        );
}
    5d90:	48 83 c4 28          	add    $0x28,%rsp
    5d94:	c3                   	ret    
    5d95:	0f 1f 00             	nopl   (%rax)
    5d98:	be 61 00 00 00       	mov    $0x61,%esi
        Hour = 12;
    5d9d:	b9 0c 00 00 00       	mov    $0xc,%ecx
    5da2:	eb 98                	jmp    5d3c <TimeToString+0x2c>
    5da4:	0f 1f 40 00          	nopl   0x0(%rax)
    5da8:	be 70 00 00 00       	mov    $0x70,%esi
    5dad:	b9 0c 00 00 00       	mov    $0xc,%ecx
    5db2:	eb 88                	jmp    5d3c <TimeToString+0x2c>
    5db4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    5dbb:	00 00 00 00 
    5dbf:	90                   	nop

0000000000005dc0 <_Print>:
{
    5dc0:	f3 0f 1e fa          	endbr64 
    5dc4:	41 56                	push   %r14
    5dc6:	41 55                	push   %r13
            switch (c) {
    5dc8:	4c 8d 2d b1 39 02 00 	lea    0x239b1(%rip),%r13        # 29780 <_DYNAMIC+0xb780>
{
    5dcf:	41 54                	push   %r12
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
    5dd1:	4c 8d 25 98 39 02 00 	lea    0x23998(%rip),%r12        # 29770 <_DYNAMIC+0xb770>
{
    5dd8:	55                   	push   %rbp
    5dd9:	53                   	push   %rbx
    5dda:	48 89 fb             	mov    %rdi,%rbx
    5ddd:	48 81 ec b0 02 00 00 	sub    $0x2b0,%rsp
    ps->Len = 0;
    5de4:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
    5deb:	00 
    ps->Buffer = Buffer;
    5dec:	48 8d 84 24 20 01 00 	lea    0x120(%rsp),%rax
    5df3:	00 
    ps->fmt.Index = 0;
    5df4:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    5dfb:	00 
    ps->Buffer = Buffer;
    5dfc:	48 89 47 30          	mov    %rax,0x30(%rdi)
    ps->Pos = Buffer;
    5e00:	48 89 47 40          	mov    %rax,0x40(%rdi)
    ps->End = Buffer + PRINT_STRING_LEN - 1;
    5e04:	48 8d 84 24 ae 02 00 	lea    0x2ae(%rsp),%rax
    5e0b:	00 
    5e0c:	48 89 47 38          	mov    %rax,0x38(%rdi)
    ps->Item = &Item;
    5e10:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    5e15:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
    while ((c = PGETC(&ps->fmt))) {
    5e1c:	31 c0                	xor    %eax,%eax
    5e1e:	eb 48                	jmp    5e68 <_Print+0xa8>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5e20:	41 0f b6 2c 00       	movzbl (%r8,%rax,1),%ebp
    p->Index += 1;
    5e25:	48 8d 48 01          	lea    0x1(%rax),%rcx
    5e29:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    while ((c = PGETC(&ps->fmt))) {
    5e2d:	66 85 ed             	test   %bp,%bp
    5e30:	74 54                	je     5e86 <_Print+0xc6>
        if (c != '%') {
    5e32:	66 83 fd 25          	cmp    $0x25,%bp
    5e36:	74 70                	je     5ea8 <_Print+0xe8>
    *ps->Pos = c;
    5e38:	48 8b 43 40          	mov    0x40(%rbx),%rax
    if (c == '\n') {
    5e3c:	66 83 fd 0a          	cmp    $0xa,%bp
    5e40:	0f 84 aa 07 00 00    	je     65f0 <_Print+0x830>
    *ps->Pos = c;
    5e46:	66 89 28             	mov    %bp,(%rax)
    ps->Pos += 1;
    5e49:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    5e4d:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    5e52:	48 83 c0 02          	add    $0x2,%rax
    5e56:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    5e5a:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    5e5e:	0f 83 1c 07 00 00    	jae    6580 <_Print+0x7c0>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5e64:	48 8b 43 08          	mov    0x8(%rbx),%rax
    5e68:	0f b6 3b             	movzbl (%rbx),%edi
    5e6b:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    5e6f:	40 84 ff             	test   %dil,%dil
    5e72:	75 ac                	jne    5e20 <_Print+0x60>
    5e74:	41 0f b7 2c 40       	movzwl (%r8,%rax,2),%ebp
    p->Index += 1;
    5e79:	48 8d 48 01          	lea    0x1(%rax),%rcx
    5e7d:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    while ((c = PGETC(&ps->fmt))) {
    5e81:	66 85 ed             	test   %bp,%bp
    5e84:	75 ac                	jne    5e32 <_Print+0x72>
    PFLUSH (ps);
    5e86:	48 89 df             	mov    %rbx,%rdi
    5e89:	e8 32 f8 ff ff       	call   56c0 <PFLUSH>
    return ps->Len;
    5e8e:	48 8b 43 48          	mov    0x48(%rbx),%rax
}
    5e92:	48 81 c4 b0 02 00 00 	add    $0x2b0,%rsp
    5e99:	5b                   	pop    %rbx
    5e9a:	5d                   	pop    %rbp
    5e9b:	41 5c                	pop    %r12
    5e9d:	41 5d                	pop    %r13
    5e9f:	41 5e                	pop    %r14
    5ea1:	c3                   	ret    
    5ea2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        Item.WidthParse = &Item.Width;
    5ea8:	48 8d 94 24 00 01 00 	lea    0x100(%rsp),%rdx
    5eaf:	00 
        Item.Item.Ascii = FALSE;
    5eb0:	c6 44 24 20 00       	movb   $0x0,0x20(%rsp)
    5eb5:	48 8d 70 02          	lea    0x2(%rax),%rsi
        Item.WidthParse = &Item.Width;
    5eb9:	48 89 94 24 10 01 00 	mov    %rdx,0x110(%rsp)
    5ec0:	00 
                Item.WidthParse = &Item.FieldWidth;
    5ec1:	48 8d ac 24 08 01 00 	lea    0x108(%rsp),%rbp
    5ec8:	00 
        Item.FieldWidth = (UINTN) -1;
    5ec9:	48 c7 84 24 08 01 00 	movq   $0xffffffffffffffff,0x108(%rsp)
    5ed0:	00 ff ff ff ff 
        Item.Width = 0;
    5ed5:	48 c7 84 24 00 01 00 	movq   $0x0,0x100(%rsp)
    5edc:	00 00 00 00 00 
        Item.Pad = ' ';
    5ee1:	c7 84 24 18 01 00 00 	movl   $0x10020,0x118(%rsp)
    5ee8:	20 00 01 00 
        Item.Long = FALSE;
    5eec:	c6 84 24 1c 01 00 00 	movb   $0x0,0x11c(%rsp)
    5ef3:	00 
        Item.Item.pw = NULL;
    5ef4:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
    5efb:	00 00 
        ps->RestoreAttr = 0;
    5efd:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    5f04:	00 
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5f05:	40 84 ff             	test   %dil,%dil
    5f08:	0f 84 ff 01 00 00    	je     610d <_Print+0x34d>
    5f0e:	41 0f b6 04 08       	movzbl (%r8,%rcx,1),%eax
    p->Index += 1;
    5f13:	48 89 73 08          	mov    %rsi,0x8(%rbx)
    5f17:	48 89 f1             	mov    %rsi,%rcx
        while ((c = PGETC(&ps->fmt))) {
    5f1a:	66 85 c0             	test   %ax,%ax
    5f1d:	74 41                	je     5f60 <_Print+0x1a0>
            switch (c) {
    5f1f:	8d 50 db             	lea    -0x25(%rax),%edx
    5f22:	66 83 fa 53          	cmp    $0x53,%dx
    5f26:	77 18                	ja     5f40 <_Print+0x180>
    5f28:	0f b7 d2             	movzwl %dx,%edx
    5f2b:	49 63 54 95 00       	movslq 0x0(%r13,%rdx,4),%rdx
    5f30:	4c 01 ea             	add    %r13,%rdx
    5f33:	3e ff e2             	notrack jmp *%rdx
    5f36:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    5f3d:	00 00 00 
                Item.Scratch[0] = '?';
    5f40:	c7 44 24 38 3f 00 00 	movl   $0x3f,0x38(%rsp)
    5f47:	00 
                Item.Item.pw = Item.Scratch;
    5f48:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    5f4d:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    5f52:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                PITEM (ps);
    5f58:	48 89 df             	mov    %rbx,%rdi
    5f5b:	e8 b0 f8 ff ff       	call   5810 <PITEM>
        if (ps->RestoreAttr) {
    5f60:	48 8b 6b 58          	mov    0x58(%rbx),%rbp
    5f64:	48 85 ed             	test   %rbp,%rbp
    5f67:	0f 84 f7 fe ff ff    	je     5e64 <_Print+0xa4>
   PFLUSH (ps);
    5f6d:	48 89 df             	mov    %rbx,%rdi
    5f70:	e8 4b f7 ff ff       	call   56c0 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    5f75:	48 8b 43 50          	mov    0x50(%rbx),%rax
    5f79:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    5f7d:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    5f84:	48 85 c0             	test   %rax,%rax
    5f87:	74 0c                	je     5f95 <_Print+0x1d5>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    5f89:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    5f90:	48 89 ea             	mov    %rbp,%rdx
    5f93:	ff d0                	call   *%rax
   ps->Attr = Attr;
    5f95:	48 89 6b 50          	mov    %rbp,0x50(%rbx)
}
    5f99:	e9 c6 fe ff ff       	jmp    5e64 <_Print+0xa4>
    5f9e:	66 90                	xchg   %ax,%ax
                *Item.WidthParse = 0;
    5fa0:	48 8b 94 24 10 01 00 	mov    0x110(%rsp),%rdx
    5fa7:	00 
    5fa8:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    5faf:	eb 24                	jmp    5fd5 <_Print+0x215>
    5fb1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5fb8:	48 8b 43 10          	mov    0x10(%rbx),%rax
    5fbc:	0f b6 04 08          	movzbl (%rax,%rcx,1),%eax
    p->Index += 1;
    5fc0:	48 8d 71 01          	lea    0x1(%rcx),%rsi
                } while (c >= '0'  &&  c <= '9') ;
    5fc4:	8d 50 d0             	lea    -0x30(%rax),%edx
    p->Index += 1;
    5fc7:	48 89 73 08          	mov    %rsi,0x8(%rbx)
                } while (c >= '0'  &&  c <= '9') ;
    5fcb:	66 83 fa 09          	cmp    $0x9,%dx
    5fcf:	0f 87 fb 05 00 00    	ja     65d0 <_Print+0x810>
                    *Item.WidthParse = *Item.WidthParse * 10 + c - '0';
    5fd5:	48 8b 94 24 10 01 00 	mov    0x110(%rsp),%rdx
    5fdc:	00 
    5fdd:	48 8b 0a             	mov    (%rdx),%rcx
    5fe0:	48 8d 0c 89          	lea    (%rcx,%rcx,4),%rcx
    5fe4:	48 8d 44 48 d0       	lea    -0x30(%rax,%rcx,2),%rax
    5fe9:	48 89 02             	mov    %rax,(%rdx)
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    5fec:	0f b6 3b             	movzbl (%rbx),%edi
    5fef:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    5ff3:	40 84 ff             	test   %dil,%dil
    5ff6:	75 c0                	jne    5fb8 <_Print+0x1f8>
    5ff8:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    5ffc:	41 0f b7 04 48       	movzwl (%r8,%rcx,2),%eax
    6001:	eb bd                	jmp    5fc0 <_Print+0x200>
    6003:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                    Item.Long ? va_arg(ps->args, INT64) : va_arg(ps->args, INT32)
    6008:	0f b6 94 24 1c 01 00 	movzbl 0x11c(%rsp),%edx
    600f:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    6010:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToHex (
    6013:	84 d2                	test   %dl,%dl
    6015:	0f 84 13 04 00 00    	je     642e <_Print+0x66e>
    601b:	83 f8 2f             	cmp    $0x2f,%eax
    601e:	0f 87 e4 06 00 00    	ja     6708 <_Print+0x948>
    6024:	89 c2                	mov    %eax,%edx
    6026:	83 c0 08             	add    $0x8,%eax
    6029:	48 03 53 28          	add    0x28(%rbx),%rdx
    602d:	89 43 18             	mov    %eax,0x18(%rbx)
    6030:	48 8b 32             	mov    (%rdx),%rsi
    if (!v) {
    6033:	48 85 f6             	test   %rsi,%rsi
    6036:	0f 84 12 04 00 00    	je     644e <_Print+0x68e>
    603c:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    6041:	48 89 ef             	mov    %rbp,%rdi
    6044:	e8 a7 f5 ff ff       	call   55f0 <ValueToHex.part.0>
                Item.Item.pw = Item.Scratch;
    6049:	e9 ff fe ff ff       	jmp    5f4d <_Print+0x18d>
    604e:	66 90                	xchg   %ax,%ax
                ValueToString (
    6050:	80 bc 24 1c 01 00 00 	cmpb   $0x0,0x11c(%rsp)
    6057:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    6058:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToString (
    605b:	0f 85 2f 05 00 00    	jne    6590 <_Print+0x7d0>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    6061:	83 f8 2f             	cmp    $0x2f,%eax
    6064:	0f 86 31 07 00 00    	jbe    679b <_Print+0x9db>
    606a:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    606e:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6072:	48 89 43 20          	mov    %rax,0x20(%rbx)
                ValueToString (
    6076:	8b 12                	mov    (%rdx),%edx
    6078:	e9 2b 05 00 00       	jmp    65a8 <_Print+0x7e8>
    607d:	0f 1f 00             	nopl   (%rax)
                TimeToString (Item.Scratch, va_arg(ps->args, EFI_TIME *));
    6080:	8b 43 18             	mov    0x18(%rbx),%eax
    6083:	83 f8 2f             	cmp    $0x2f,%eax
    6086:	0f 87 34 06 00 00    	ja     66c0 <_Print+0x900>
    608c:	89 c2                	mov    %eax,%edx
    608e:	83 c0 08             	add    $0x8,%eax
    6091:	48 03 53 28          	add    0x28(%rbx),%rdx
    6095:	89 43 18             	mov    %eax,0x18(%rbx)
    6098:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    609d:	48 8b 32             	mov    (%rdx),%rsi
    60a0:	48 89 ef             	mov    %rbp,%rdi
    60a3:	e8 68 fc ff ff       	call   5d10 <TimeToString>
                Item.Item.pw = Item.Scratch;
    60a8:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    60ad:	e9 a6 fe ff ff       	jmp    5f58 <_Print+0x198>
    60b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
    60b8:	8b 43 18             	mov    0x18(%rbx),%eax
    60bb:	83 f8 2f             	cmp    $0x2f,%eax
    60be:	0f 87 b4 05 00 00    	ja     6678 <_Print+0x8b8>
    60c4:	89 c2                	mov    %eax,%edx
    60c6:	83 c0 08             	add    $0x8,%eax
    60c9:	48 03 53 28          	add    0x28(%rbx),%rdx
    60cd:	89 43 18             	mov    %eax,0x18(%rbx)
    60d0:	48 8b 02             	mov    (%rdx),%rax
    60d3:	48 85 c0             	test   %rax,%rax
    60d6:	49 0f 44 c4          	cmove  %r12,%rax
    60da:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    60df:	e9 74 fe ff ff       	jmp    5f58 <_Print+0x198>
    60e4:	0f 1f 40 00          	nopl   0x0(%rax)
            if (Item.Item.pw) {
    60e8:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.Long = TRUE;
    60ee:	c6 84 24 1c 01 00 00 	movb   $0x1,0x11c(%rsp)
    60f5:	01 
            if (Item.Item.pw) {
    60f6:	0f 85 5c fe ff ff    	jne    5f58 <_Print+0x198>
    60fc:	0f 1f 40 00          	nopl   0x0(%rax)
    6100:	48 83 c6 01          	add    $0x1,%rsi
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    6104:	40 84 ff             	test   %dil,%dil
    6107:	0f 85 01 fe ff ff    	jne    5f0e <_Print+0x14e>
    610d:	41 0f b7 04 48       	movzwl (%r8,%rcx,2),%eax
    6112:	e9 fc fd ff ff       	jmp    5f13 <_Print+0x153>
    6117:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    611e:	00 00 
                Item.Pad = '0';
    6120:	ba 30 00 00 00       	mov    $0x30,%edx
                ValueToHex (
    6125:	80 bc 24 1c 01 00 00 	cmpb   $0x0,0x11c(%rsp)
    612c:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    612d:	8b 43 18             	mov    0x18(%rbx),%eax
                Item.Width = sizeof(void *) == (8 ? 16 : 8) + 2;
    6130:	48 c7 84 24 00 01 00 	movq   $0x0,0x100(%rsp)
    6137:	00 00 00 00 00 
                Item.Pad = '0';
    613c:	66 89 94 24 18 01 00 	mov    %dx,0x118(%rsp)
    6143:	00 
                Item.Scratch[0] = ' ';
    6144:	c7 44 24 38 20 00 20 	movl   $0x200020,0x38(%rsp)
    614b:	00 
                ValueToHex (
    614c:	0f 84 86 05 00 00    	je     66d8 <_Print+0x918>
    6152:	83 f8 2f             	cmp    $0x2f,%eax
    6155:	0f 87 2f 06 00 00    	ja     678a <_Print+0x9ca>
    615b:	89 c2                	mov    %eax,%edx
    615d:	83 c0 08             	add    $0x8,%eax
    6160:	48 03 53 28          	add    0x28(%rbx),%rdx
    6164:	89 43 18             	mov    %eax,0x18(%rbx)
    6167:	48 8b 32             	mov    (%rdx),%rsi
    if (!v) {
    616a:	48 85 f6             	test   %rsi,%rsi
    616d:	0f 84 85 05 00 00    	je     66f8 <_Print+0x938>
    6173:	48 8d 7c 24 3c       	lea    0x3c(%rsp),%rdi
    6178:	e8 73 f4 ff ff       	call   55f0 <ValueToHex.part.0>
                Item.Item.pw = Item.Scratch;
    617d:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                Item.Scratch[0] = '0';
    6182:	c7 44 24 38 30 00 78 	movl   $0x780030,0x38(%rsp)
    6189:	00 
                Item.Item.pw = Item.Scratch;
    618a:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    618f:	e9 c4 fd ff ff       	jmp    5f58 <_Print+0x198>
    6194:	0f 1f 40 00          	nopl   0x0(%rax)
                PSETATTR(ps, ps->AttrNorm);
    6198:	4c 8b 73 60          	mov    0x60(%rbx),%r14
   PFLUSH (ps);
    619c:	48 89 df             	mov    %rbx,%rdi
    619f:	e8 1c f5 ff ff       	call   56c0 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    61a4:	48 8b 43 50          	mov    0x50(%rbx),%rax
    61a8:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    61ac:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    61b3:	48 85 c0             	test   %rax,%rax
    61b6:	74 0c                	je     61c4 <_Print+0x404>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    61b8:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    61bf:	4c 89 f2             	mov    %r14,%rdx
    61c2:	ff d0                	call   *%rax
            if (Item.Item.pw) {
    61c4:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
   ps->Attr = Attr;
    61ca:	4c 89 73 50          	mov    %r14,0x50(%rbx)
            if (Item.Item.pw) {
    61ce:	0f 85 84 fd ff ff    	jne    5f58 <_Print+0x198>
    c = p->Ascii ? p->pc[p->Index] : p->pw[p->Index];
    61d4:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    61d8:	0f b6 3b             	movzbl (%rbx),%edi
    61db:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    61df:	48 8d 71 01          	lea    0x1(%rcx),%rsi
    61e3:	e9 1d fd ff ff       	jmp    5f05 <_Print+0x145>
    61e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    61ef:	00 
                GuidToString (Item.Scratch, va_arg(ps->args, EFI_GUID *));
    61f0:	8b 43 18             	mov    0x18(%rbx),%eax
    61f3:	83 f8 2f             	cmp    $0x2f,%eax
    61f6:	0f 87 ac 04 00 00    	ja     66a8 <_Print+0x8e8>
    61fc:	89 c2                	mov    %eax,%edx
    61fe:	83 c0 08             	add    $0x8,%eax
    6201:	48 03 53 28          	add    0x28(%rbx),%rdx
    6205:	89 43 18             	mov    %eax,0x18(%rbx)
    6208:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    620d:	48 8b 32             	mov    (%rdx),%rsi
    6210:	48 89 ef             	mov    %rbp,%rdi
    6213:	e8 48 35 00 00       	call   9760 <GuidToString>
                Item.Item.pw = Item.Scratch;
    6218:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    621d:	e9 36 fd ff ff       	jmp    5f58 <_Print+0x198>
    6222:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                FloatToString (
    6228:	8b 43 1c             	mov    0x1c(%rbx),%eax
    622b:	3d af 00 00 00       	cmp    $0xaf,%eax
    6230:	0f 87 5a 04 00 00    	ja     6690 <_Print+0x8d0>
    6236:	89 c2                	mov    %eax,%edx
    6238:	83 c0 10             	add    $0x10,%eax
    623b:	48 03 53 28          	add    0x28(%rbx),%rdx
    623f:	89 43 1c             	mov    %eax,0x1c(%rbx)
    6242:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    6247:	0f b6 b4 24 1b 01 00 	movzbl 0x11b(%rsp),%esi
    624e:	00 
    624f:	f2 0f 10 02          	movsd  (%rdx),%xmm0
    6253:	48 89 ef             	mov    %rbp,%rdi
    6256:	e8 d5 f9 ff ff       	call   5c30 <FloatToString>
                Item.Item.pw = Item.Scratch;
    625b:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    6260:	e9 f3 fc ff ff       	jmp    5f58 <_Print+0x198>
    6265:	0f 1f 00             	nopl   (%rax)
                PSETATTR(ps, ps->AttrHighlight);
    6268:	4c 8b 73 68          	mov    0x68(%rbx),%r14
   PFLUSH (ps);
    626c:	e9 2b ff ff ff       	jmp    619c <_Print+0x3dc>
    6271:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                StatusToString (Item.Scratch, va_arg(ps->args, EFI_STATUS));
    6278:	8b 43 18             	mov    0x18(%rbx),%eax
    627b:	83 f8 2f             	cmp    $0x2f,%eax
    627e:	0f 87 9c 04 00 00    	ja     6720 <_Print+0x960>
    6284:	89 c2                	mov    %eax,%edx
    6286:	83 c0 08             	add    $0x8,%eax
    6289:	48 03 53 28          	add    0x28(%rbx),%rdx
    628d:	89 43 18             	mov    %eax,0x18(%rbx)
    6290:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    6295:	48 8b 32             	mov    (%rdx),%rsi
    6298:	48 89 ef             	mov    %rbp,%rdi
    629b:	e8 20 d5 ff ff       	call   37c0 <StatusToString>
                Item.Item.pw = Item.Scratch;
    62a0:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    62a5:	e9 ae fc ff ff       	jmp    5f58 <_Print+0x198>
    62aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                PSETATTR(ps, ps->AttrError);
    62b0:	4c 8b 73 70          	mov    0x70(%rbx),%r14
   PFLUSH (ps);
    62b4:	e9 e3 fe ff ff       	jmp    619c <_Print+0x3dc>
    62b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            if (Item.Item.pw) {
    62c0:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.PadBefore = FALSE;
    62c6:	c6 84 24 1a 01 00 00 	movb   $0x0,0x11a(%rsp)
    62cd:	00 
            if (Item.Item.pw) {
    62ce:	0f 84 2c fe ff ff    	je     6100 <_Print+0x340>
    62d4:	e9 7f fc ff ff       	jmp    5f58 <_Print+0x198>
    62d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    62e0:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.Comma = TRUE;
    62e6:	c6 84 24 1b 01 00 00 	movb   $0x1,0x11b(%rsp)
    62ed:	01 
            if (Item.Item.pw) {
    62ee:	0f 84 0c fe ff ff    	je     6100 <_Print+0x340>
    62f4:	e9 5f fc ff ff       	jmp    5f58 <_Print+0x198>
    62f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                *Item.WidthParse = va_arg(ps->args, UINTN);
    6300:	8b 43 18             	mov    0x18(%rbx),%eax
    6303:	48 8b 8c 24 10 01 00 	mov    0x110(%rsp),%rcx
    630a:	00 
    630b:	83 f8 2f             	cmp    $0x2f,%eax
    630e:	0f 87 3c 04 00 00    	ja     6750 <_Print+0x990>
    6314:	89 c2                	mov    %eax,%edx
    6316:	83 c0 08             	add    $0x8,%eax
    6319:	48 03 53 28          	add    0x28(%rbx),%rdx
    631d:	89 43 18             	mov    %eax,0x18(%rbx)
    6320:	48 8b 02             	mov    (%rdx),%rax
    6323:	48 89 01             	mov    %rax,(%rcx)
            if (Item.Item.pw) {
    6326:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
    632c:	0f 84 a2 fe ff ff    	je     61d4 <_Print+0x414>
    6332:	e9 21 fc ff ff       	jmp    5f58 <_Print+0x198>
    6337:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    633e:	00 00 
                Item.Item.pw = Item.Scratch;
    6340:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                Item.Scratch[0] = '%';
    6345:	c7 44 24 38 25 00 00 	movl   $0x25,0x38(%rsp)
    634c:	00 
                Item.Item.pw = Item.Scratch;
    634d:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    6352:	e9 01 fc ff ff       	jmp    5f58 <_Print+0x198>
    6357:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    635e:	00 00 
                Item.Pad = '0';
    6360:	41 b9 30 00 00 00    	mov    $0x30,%r9d
            if (Item.Item.pw) {
    6366:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.Pad = '0';
    636c:	66 44 89 8c 24 18 01 	mov    %r9w,0x118(%rsp)
    6373:	00 00 
            if (Item.Item.pw) {
    6375:	0f 84 85 fd ff ff    	je     6100 <_Print+0x340>
    637b:	e9 d8 fb ff ff       	jmp    5f58 <_Print+0x198>
    6380:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                Item.WidthParse = &Item.FieldWidth;
    6386:	48 89 ac 24 10 01 00 	mov    %rbp,0x110(%rsp)
    638d:	00 
            if (Item.Item.pw) {
    638e:	0f 84 6c fd ff ff    	je     6100 <_Print+0x340>
    6394:	e9 bf fb ff ff       	jmp    5f58 <_Print+0x198>
    6399:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                EFI_DEVICE_PATH *dp = va_arg(ps->args, EFI_DEVICE_PATH *);
    63a0:	8b 43 18             	mov    0x18(%rbx),%eax
    63a3:	83 f8 2f             	cmp    $0x2f,%eax
    63a6:	0f 87 b4 02 00 00    	ja     6660 <_Print+0x8a0>
    63ac:	89 c2                	mov    %eax,%edx
    63ae:	83 c0 08             	add    $0x8,%eax
    63b1:	48 03 53 28          	add    0x28(%rbx),%rdx
    63b5:	89 43 18             	mov    %eax,0x18(%rbx)
                CHAR16 *dpstr = DevicePathToStr(dp);
    63b8:	48 8b 3a             	mov    (%rdx),%rdi
                StrnCpy(Item.Scratch, dpstr, PRINT_ITEM_BUFFER_LEN);
    63bb:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                CHAR16 *dpstr = DevicePathToStr(dp);
    63c0:	e8 1b 31 00 00       	call   94e0 <DevicePathToStr>
                StrnCpy(Item.Scratch, dpstr, PRINT_ITEM_BUFFER_LEN);
    63c5:	ba 64 00 00 00       	mov    $0x64,%edx
    63ca:	48 89 ef             	mov    %rbp,%rdi
                CHAR16 *dpstr = DevicePathToStr(dp);
    63cd:	49 89 c6             	mov    %rax,%r14
                StrnCpy(Item.Scratch, dpstr, PRINT_ITEM_BUFFER_LEN);
    63d0:	48 89 c6             	mov    %rax,%rsi
    63d3:	e8 68 12 00 00       	call   7640 <StrnCpy>
                Item.Scratch[PRINT_ITEM_BUFFER_LEN-1] = L'\0';
    63d8:	31 c9                	xor    %ecx,%ecx
                FreePool(dpstr);
    63da:	4c 89 f7             	mov    %r14,%rdi
                Item.Scratch[PRINT_ITEM_BUFFER_LEN-1] = L'\0';
    63dd:	66 89 8c 24 fe 00 00 	mov    %cx,0xfe(%rsp)
    63e4:	00 
                FreePool(dpstr);
    63e5:	e8 76 e5 ff ff       	call   4960 <FreePool>
                Item.Item.pw = Item.Scratch;
    63ea:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    63ef:	e9 64 fb ff ff       	jmp    5f58 <_Print+0x198>
    63f4:	0f 1f 40 00          	nopl   0x0(%rax)
                Item.Width = Item.Long ? 16 : 8;
    63f8:	0f b6 94 24 1c 01 00 	movzbl 0x11c(%rsp),%edx
    63ff:	00 
    6400:	80 fa 01             	cmp    $0x1,%dl
    6403:	48 19 c0             	sbb    %rax,%rax
    6406:	48 83 e0 f8          	and    $0xfffffffffffffff8,%rax
    640a:	48 83 c0 10          	add    $0x10,%rax
    640e:	48 89 84 24 00 01 00 	mov    %rax,0x100(%rsp)
    6415:	00 
                Item.Pad = '0';
    6416:	b8 30 00 00 00       	mov    $0x30,%eax
    641b:	66 89 84 24 18 01 00 	mov    %ax,0x118(%rsp)
    6422:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    6423:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToHex (
    6426:	84 d2                	test   %dl,%dl
    6428:	0f 85 ed fb ff ff    	jne    601b <_Print+0x25b>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    642e:	83 f8 2f             	cmp    $0x2f,%eax
    6431:	0f 87 f9 01 00 00    	ja     6630 <_Print+0x870>
    6437:	89 c2                	mov    %eax,%edx
    6439:	83 c0 08             	add    $0x8,%eax
    643c:	48 03 53 28          	add    0x28(%rbx),%rdx
    6440:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToHex (
    6443:	8b 32                	mov    (%rdx),%esi
    if (!v) {
    6445:	48 85 f6             	test   %rsi,%rsi
    6448:	0f 85 ee fb ff ff    	jne    603c <_Print+0x27c>
        Buffer[0] = '0';
    644e:	c7 44 24 38 30 00 00 	movl   $0x30,0x38(%rsp)
    6455:	00 
        return ;
    6456:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    645b:	e9 ed fa ff ff       	jmp    5f4d <_Print+0x18d>
                Item.Scratch[0] = (CHAR16) va_arg(ps->args, UINTN);
    6460:	8b 43 18             	mov    0x18(%rbx),%eax
    6463:	83 f8 2f             	cmp    $0x2f,%eax
    6466:	0f 87 dc 01 00 00    	ja     6648 <_Print+0x888>
    646c:	89 c2                	mov    %eax,%edx
    646e:	83 c0 08             	add    $0x8,%eax
    6471:	48 03 53 28          	add    0x28(%rbx),%rdx
    6475:	89 43 18             	mov    %eax,0x18(%rbx)
    6478:	48 8b 02             	mov    (%rdx),%rax
                Item.Scratch[1] = 0;
    647b:	31 f6                	xor    %esi,%esi
                Item.Item.pw = Item.Scratch;
    647d:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
                Item.Scratch[1] = 0;
    6482:	66 89 74 24 3a       	mov    %si,0x3a(%rsp)
                Item.Scratch[0] = (CHAR16) va_arg(ps->args, UINTN);
    6487:	66 89 44 24 38       	mov    %ax,0x38(%rsp)
                Item.Item.pw = Item.Scratch;
    648c:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    6491:	e9 c2 fa ff ff       	jmp    5f58 <_Print+0x198>
    6496:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    649d:	00 00 00 
                Item.Item.pc = va_arg(ps->args, CHAR8 *);
    64a0:	8b 43 18             	mov    0x18(%rbx),%eax
    64a3:	83 f8 2f             	cmp    $0x2f,%eax
    64a6:	0f 87 8c 02 00 00    	ja     6738 <_Print+0x978>
    64ac:	89 c2                	mov    %eax,%edx
    64ae:	83 c0 08             	add    $0x8,%eax
    64b1:	48 03 53 28          	add    0x28(%rbx),%rdx
    64b5:	89 43 18             	mov    %eax,0x18(%rbx)
    64b8:	48 8b 12             	mov    (%rdx),%rdx
                    Item.Item.pc = (CHAR8 *)"(null)";
    64bb:	48 8d 05 a6 32 02 00 	lea    0x232a6(%rip),%rax        # 29768 <_DYNAMIC+0xb768>
                Item.Item.Ascii = TRUE;
    64c2:	c6 44 24 20 01       	movb   $0x1,0x20(%rsp)
                    Item.Item.pc = (CHAR8 *)"(null)";
    64c7:	48 85 d2             	test   %rdx,%rdx
    64ca:	48 0f 45 c2          	cmovne %rdx,%rax
    64ce:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    64d3:	e9 80 fa ff ff       	jmp    5f58 <_Print+0x198>
    64d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    64df:	00 
                ValueToString (
    64e0:	80 bc 24 1c 01 00 00 	cmpb   $0x0,0x11c(%rsp)
    64e7:	00 
                *Item.WidthParse = va_arg(ps->args, UINTN);
    64e8:	8b 43 18             	mov    0x18(%rbx),%eax
                ValueToString (
    64eb:	0f 85 9f 00 00 00    	jne    6590 <_Print+0x7d0>
                    Item.Long ? va_arg(ps->args, INT64) : va_arg(ps->args, INT32)
    64f1:	83 f8 2f             	cmp    $0x2f,%eax
    64f4:	0f 87 7f 02 00 00    	ja     6779 <_Print+0x9b9>
    64fa:	89 c2                	mov    %eax,%edx
    64fc:	83 c0 08             	add    $0x8,%eax
    64ff:	48 03 53 28          	add    0x28(%rbx),%rdx
    6503:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToString (
    6506:	48 63 12             	movslq (%rdx),%rdx
    6509:	e9 9a 00 00 00       	jmp    65a8 <_Print+0x7e8>
    650e:	66 90                	xchg   %ax,%ax
                Attr = ps->AttrHighlight;
    6510:	4c 8b 73 68          	mov    0x68(%rbx),%r14
            if (Item.Item.pw) {
    6514:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
    651a:	0f 85 38 fa ff ff    	jne    5f58 <_Print+0x198>
            if (Attr) {
    6520:	4d 85 f6             	test   %r14,%r14
    6523:	0f 84 d7 fb ff ff    	je     6100 <_Print+0x340>
   PFLUSH (ps);
    6529:	48 89 df             	mov    %rbx,%rdi
    652c:	e8 8f f1 ff ff       	call   56c0 <PFLUSH>
   ps->RestoreAttr = ps->Attr;
    6531:	48 8b 43 50          	mov    0x50(%rbx),%rax
    6535:	48 89 43 58          	mov    %rax,0x58(%rbx)
   if (ps->SetAttr) {
    6539:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    6540:	48 85 c0             	test   %rax,%rax
    6543:	74 0c                	je     6551 <_Print+0x791>
	uefi_call_wrapper(ps->SetAttr, 2, ps->Context, Attr);
    6545:	48 8b 8b 88 00 00 00 	mov    0x88(%rbx),%rcx
    654c:	4c 89 f2             	mov    %r14,%rdx
    654f:	ff d0                	call   *%rax
   ps->Attr = Attr;
    6551:	4c 89 73 50          	mov    %r14,0x50(%rbx)
                ps->RestoreAttr = 0;
    6555:	48 c7 43 58 00 00 00 	movq   $0x0,0x58(%rbx)
    655c:	00 
        if (ps->RestoreAttr) {
    655d:	e9 02 f9 ff ff       	jmp    5e64 <_Print+0xa4>
    6562:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                Attr = ps->AttrError;
    6568:	4c 8b 73 70          	mov    0x70(%rbx),%r14
                break;
    656c:	eb a6                	jmp    6514 <_Print+0x754>
    656e:	66 90                	xchg   %ax,%ax
                Attr = ps->AttrNorm;
    6570:	4c 8b 73 60          	mov    0x60(%rbx),%r14
                break;
    6574:	eb 9e                	jmp    6514 <_Print+0x754>
    6576:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    657d:	00 00 00 
        PFLUSH(ps);
    6580:	48 89 df             	mov    %rbx,%rdi
    6583:	e8 38 f1 ff ff       	call   56c0 <PFLUSH>
    6588:	e9 d7 f8 ff ff       	jmp    5e64 <_Print+0xa4>
    658d:	0f 1f 00             	nopl   (%rax)
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    6590:	83 f8 2f             	cmp    $0x2f,%eax
    6593:	0f 87 cf 01 00 00    	ja     6768 <_Print+0x9a8>
    6599:	89 c2                	mov    %eax,%edx
    659b:	83 c0 08             	add    $0x8,%eax
    659e:	48 03 53 28          	add    0x28(%rbx),%rdx
    65a2:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToString (
    65a5:	48 8b 12             	mov    (%rdx),%rdx
    65a8:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    65ad:	0f b6 b4 24 1b 01 00 	movzbl 0x11b(%rsp),%esi
    65b4:	00 
    65b5:	48 89 ef             	mov    %rbp,%rdi
    65b8:	e8 33 f5 ff ff       	call   5af0 <ValueToString>
                Item.Item.pw = Item.Scratch;
    65bd:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
            if (Item.Item.pw) {
    65c2:	e9 91 f9 ff ff       	jmp    5f58 <_Print+0x198>
    65c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    65ce:	00 00 
    65d0:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
                ps->fmt.Index -= 1;
    65d6:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
            if (Item.Item.pw) {
    65da:	0f 85 78 f9 ff ff    	jne    5f58 <_Print+0x198>
    65e0:	4c 8b 43 10          	mov    0x10(%rbx),%r8
    65e4:	e9 1c f9 ff ff       	jmp    5f05 <_Print+0x145>
    65e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    *ps->Pos = c;
    65f0:	41 ba 0d 00 00 00    	mov    $0xd,%r10d
    65f6:	66 44 89 10          	mov    %r10w,(%rax)
    ps->Pos += 1;
    65fa:	48 8b 43 40          	mov    0x40(%rbx),%rax
    ps->Len += 1;
    65fe:	48 83 43 48 01       	addq   $0x1,0x48(%rbx)
    ps->Pos += 1;
    6603:	48 83 c0 02          	add    $0x2,%rax
    6607:	48 89 43 40          	mov    %rax,0x40(%rbx)
    if (ps->Pos >= ps->End) {
    660b:	48 3b 43 38          	cmp    0x38(%rbx),%rax
    660f:	0f 82 31 f8 ff ff    	jb     5e46 <_Print+0x86>
        PFLUSH(ps);
    6615:	48 89 df             	mov    %rbx,%rdi
    6618:	e8 a3 f0 ff ff       	call   56c0 <PFLUSH>
    *ps->Pos = c;
    661d:	48 8b 43 40          	mov    0x40(%rbx),%rax
    6621:	e9 20 f8 ff ff       	jmp    5e46 <_Print+0x86>
    6626:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    662d:	00 00 00 
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    6630:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    6634:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6638:	48 89 43 20          	mov    %rax,0x20(%rbx)
                ValueToHex (
    663c:	8b 32                	mov    (%rdx),%esi
    663e:	e9 02 fe ff ff       	jmp    6445 <_Print+0x685>
    6643:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                Item.Scratch[0] = (CHAR16) va_arg(ps->args, UINTN);
    6648:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    664c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6650:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6654:	e9 1f fe ff ff       	jmp    6478 <_Print+0x6b8>
    6659:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                EFI_DEVICE_PATH *dp = va_arg(ps->args, EFI_DEVICE_PATH *);
    6660:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    6664:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6668:	48 89 43 20          	mov    %rax,0x20(%rbx)
    666c:	e9 47 fd ff ff       	jmp    63b8 <_Print+0x5f8>
    6671:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                Item.Item.pw = va_arg(ps->args, CHAR16 *);
    6678:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    667c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6680:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6684:	e9 47 fa ff ff       	jmp    60d0 <_Print+0x310>
    6689:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                FloatToString (
    6690:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    6694:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6698:	48 89 43 20          	mov    %rax,0x20(%rbx)
    669c:	e9 a1 fb ff ff       	jmp    6242 <_Print+0x482>
    66a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                GuidToString (Item.Scratch, va_arg(ps->args, EFI_GUID *));
    66a8:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    66ac:	48 8d 42 08          	lea    0x8(%rdx),%rax
    66b0:	48 89 43 20          	mov    %rax,0x20(%rbx)
    66b4:	e9 4f fb ff ff       	jmp    6208 <_Print+0x448>
    66b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                TimeToString (Item.Scratch, va_arg(ps->args, EFI_TIME *));
    66c0:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    66c4:	48 8d 42 08          	lea    0x8(%rdx),%rax
    66c8:	48 89 43 20          	mov    %rax,0x20(%rbx)
    66cc:	e9 c7 f9 ff ff       	jmp    6098 <_Print+0x2d8>
    66d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    66d8:	83 f8 2f             	cmp    $0x2f,%eax
    66db:	0f 86 cd 00 00 00    	jbe    67ae <_Print+0x9ee>
    66e1:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    66e5:	48 8d 42 08          	lea    0x8(%rdx),%rax
    66e9:	48 89 43 20          	mov    %rax,0x20(%rbx)
                ValueToHex (
    66ed:	8b 32                	mov    (%rdx),%esi
    if (!v) {
    66ef:	48 85 f6             	test   %rsi,%rsi
    66f2:	0f 85 7b fa ff ff    	jne    6173 <_Print+0x3b3>
        Buffer[0] = '0';
    66f8:	c7 44 24 3c 30 00 00 	movl   $0x30,0x3c(%rsp)
    66ff:	00 
        return ;
    6700:	e9 78 fa ff ff       	jmp    617d <_Print+0x3bd>
    6705:	0f 1f 00             	nopl   (%rax)
                ValueToHex (
    6708:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    670c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6710:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6714:	e9 17 f9 ff ff       	jmp    6030 <_Print+0x270>
    6719:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                StatusToString (Item.Scratch, va_arg(ps->args, EFI_STATUS));
    6720:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    6724:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6728:	48 89 43 20          	mov    %rax,0x20(%rbx)
    672c:	e9 5f fb ff ff       	jmp    6290 <_Print+0x4d0>
    6731:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                Item.Item.pc = va_arg(ps->args, CHAR8 *);
    6738:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    673c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6740:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6744:	e9 6f fd ff ff       	jmp    64b8 <_Print+0x6f8>
    6749:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                *Item.WidthParse = va_arg(ps->args, UINTN);
    6750:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    6754:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6758:	48 89 43 20          	mov    %rax,0x20(%rbx)
    675c:	e9 bf fb ff ff       	jmp    6320 <_Print+0x560>
    6761:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    6768:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    676c:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6770:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6774:	e9 2c fe ff ff       	jmp    65a5 <_Print+0x7e5>
                    Item.Long ? va_arg(ps->args, INT64) : va_arg(ps->args, INT32)
    6779:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    677d:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6781:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6785:	e9 7c fd ff ff       	jmp    6506 <_Print+0x746>
                ValueToHex (
    678a:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    678e:	48 8d 42 08          	lea    0x8(%rdx),%rax
    6792:	48 89 43 20          	mov    %rax,0x20(%rbx)
    6796:	e9 cc f9 ff ff       	jmp    6167 <_Print+0x3a7>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    679b:	89 c2                	mov    %eax,%edx
    679d:	83 c0 08             	add    $0x8,%eax
    67a0:	48 03 53 28          	add    0x28(%rbx),%rdx
    67a4:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToString (
    67a7:	8b 12                	mov    (%rdx),%edx
    67a9:	e9 fa fd ff ff       	jmp    65a8 <_Print+0x7e8>
                    Item.Long ? va_arg(ps->args, UINT64) : va_arg(ps->args, UINT32)
    67ae:	89 c2                	mov    %eax,%edx
    67b0:	83 c0 08             	add    $0x8,%eax
    67b3:	48 03 53 28          	add    0x28(%rbx),%rdx
    67b7:	89 43 18             	mov    %eax,0x18(%rbx)
                ValueToHex (
    67ba:	8b 32                	mov    (%rdx),%esi
    67bc:	e9 2e ff ff ff       	jmp    66ef <_Print+0x92f>
    67c1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    67c8:	00 00 00 00 
    67cc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000067d0 <DbgPrint>:
{
    67d0:	f3 0f 1e fa          	endbr64 
    67d4:	41 55                	push   %r13
    67d6:	41 54                	push   %r12
    67d8:	55                   	push   %rbp
    67d9:	48 89 f5             	mov    %rsi,%rbp
    67dc:	53                   	push   %rbx
    67dd:	48 89 fb             	mov    %rdi,%rbx
    67e0:	48 81 ec 98 01 00 00 	sub    $0x198,%rsp
    67e7:	48 89 94 24 f0 00 00 	mov    %rdx,0xf0(%rsp)
    67ee:	00 
    67ef:	48 89 8c 24 f8 00 00 	mov    %rcx,0xf8(%rsp)
    67f6:	00 
    67f7:	4c 89 84 24 00 01 00 	mov    %r8,0x100(%rsp)
    67fe:	00 
    67ff:	4c 89 8c 24 08 01 00 	mov    %r9,0x108(%rsp)
    6806:	00 
    6807:	84 c0                	test   %al,%al
    6809:	74 40                	je     684b <DbgPrint+0x7b>
    680b:	0f 29 84 24 10 01 00 	movaps %xmm0,0x110(%rsp)
    6812:	00 
    6813:	0f 29 8c 24 20 01 00 	movaps %xmm1,0x120(%rsp)
    681a:	00 
    681b:	0f 29 94 24 30 01 00 	movaps %xmm2,0x130(%rsp)
    6822:	00 
    6823:	0f 29 9c 24 40 01 00 	movaps %xmm3,0x140(%rsp)
    682a:	00 
    682b:	0f 29 a4 24 50 01 00 	movaps %xmm4,0x150(%rsp)
    6832:	00 
    6833:	0f 29 ac 24 60 01 00 	movaps %xmm5,0x160(%rsp)
    683a:	00 
    683b:	0f 29 b4 24 70 01 00 	movaps %xmm6,0x170(%rsp)
    6842:	00 
    6843:	0f 29 bc 24 80 01 00 	movaps %xmm7,0x180(%rsp)
    684a:	00 
    if (!(EFIDebug & mask)) {
    684b:	48 89 d8             	mov    %rbx,%rax
    684e:	48 23 05 db 68 01 00 	and    0x168db(%rip),%rax        # 1d130 <EFIDebug>
    6855:	75 19                	jne    6870 <DbgPrint+0xa0>
}
    6857:	48 81 c4 98 01 00 00 	add    $0x198,%rsp
    685e:	31 c0                	xor    %eax,%eax
    6860:	5b                   	pop    %rbx
    6861:	5d                   	pop    %rbp
    6862:	41 5c                	pop    %r12
    6864:	41 5d                	pop    %r13
    6866:	c3                   	ret    
    6867:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    686e:	00 00 
    va_start (args, fmt);
    6870:	48 8d 84 24 c0 01 00 	lea    0x1c0(%rsp),%rax
    6877:	00 
    ZeroMem (&ps, sizeof(ps));
    6878:	4c 8d 6c 24 40       	lea    0x40(%rsp),%r13
    687d:	be 98 00 00 00       	mov    $0x98,%esi
    va_start (args, fmt);
    6882:	c7 44 24 28 10 00 00 	movl   $0x10,0x28(%rsp)
    6889:	00 
    688a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    ZeroMem (&ps, sizeof(ps));
    688f:	4c 89 ef             	mov    %r13,%rdi
    va_start (args, fmt);
    6892:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    6899:	00 
    689a:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    689f:	c7 44 24 2c 30 00 00 	movl   $0x30,0x2c(%rsp)
    68a6:	00 
    ZeroMem (&ps, sizeof(ps));
    68a7:	e8 d4 e0 ff ff       	call   4980 <ZeroMem>
    va_copy(ps.args, args);
    68ac:	f3 0f 6f 44 24 28    	movdqu 0x28(%rsp),%xmm0
    ps.fmt.Ascii = TRUE;
    68b2:	c6 44 24 40 01       	movb   $0x1,0x40(%rsp)
    ps.Output = _DbgOut;
    68b7:	48 8d 05 b2 ea ff ff 	lea    -0x154e(%rip),%rax        # 5370 <_DbgOut>
    68be:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
    68c5:	00 
    DbgOut = LibRuntimeDebugOut;
    68c6:	48 8b 15 93 6d 01 00 	mov    0x16d93(%rip),%rdx        # 1d660 <LibRuntimeDebugOut>
    va_copy(ps.args, args);
    68cd:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    ps.fmt.pc = fmt;
    68d2:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
    ps.Attr = EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_RED);
    68d7:	48 c7 84 24 90 00 00 	movq   $0x47,0x90(%rsp)
    68de:	00 47 00 00 00 
    va_copy(ps.args, args);
    68e3:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    68e8:	0f 11 44 24 58       	movups %xmm0,0x58(%rsp)
    if (!DbgOut) {
    68ed:	48 85 d2             	test   %rdx,%rdx
    68f0:	0f 84 b2 00 00 00    	je     69a8 <_text_size+0xa8>
        ps.Attr = DbgOut->Mode->Attribute;
    68f6:	48 8b 42 48          	mov    0x48(%rdx),%rax
    68fa:	4c 63 60 08          	movslq 0x8(%rax),%r12
        ps.Context = DbgOut;
    68fe:	48 89 94 24 c8 00 00 	mov    %rdx,0xc8(%rsp)
    6905:	00 
        ps.Attr = DbgOut->Mode->Attribute;
    6906:	4c 89 a4 24 90 00 00 	mov    %r12,0x90(%rsp)
    690d:	00 
        ps.SetAttr = (INTN (EFIAPI *)(VOID *, UINTN))  DbgOut->SetAttribute;
    690e:	48 8b 72 28          	mov    0x28(%rdx),%rsi
        ps.Attr = DbgOut->Mode->Attribute;
    6912:	4c 89 e0             	mov    %r12,%rax
    6915:	25 f0 00 00 00       	and    $0xf0,%eax
        ps.SetAttr = (INTN (EFIAPI *)(VOID *, UINTN))  DbgOut->SetAttribute;
    691a:	48 89 b4 24 c0 00 00 	mov    %rsi,0xc0(%rsp)
    6921:	00 
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    6922:	89 c2                	mov    %eax,%edx
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    6924:	89 c1                	mov    %eax,%ecx
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    6926:	83 c8 0e             	or     $0xe,%eax
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    6929:	83 ca 07             	or     $0x7,%edx
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    692c:	83 c9 0f             	or     $0xf,%ecx
        attr = ps.AttrHighlight;
    692f:	f6 c3 02             	test   $0x2,%bl
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    6932:	48 89 94 24 a0 00 00 	mov    %rdx,0xa0(%rsp)
    6939:	00 
        attr = ps.AttrHighlight;
    693a:	48 0f 45 d1          	cmovne %rcx,%rdx
        attr = ps.AttrError;
    693e:	f7 c3 00 00 00 80    	test   $0x80000000,%ebx
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    6944:	48 89 8c 24 a8 00 00 	mov    %rcx,0xa8(%rsp)
    694b:	00 
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    694c:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
    6953:	00 
        attr = ps.AttrError;
    6954:	48 0f 45 d0          	cmovne %rax,%rdx
    if (ps.SetAttr) {
    6958:	48 85 f6             	test   %rsi,%rsi
    695b:	74 12                	je     696f <_text_size+0x6f>
        ps.Attr = attr;
    695d:	48 89 94 24 90 00 00 	mov    %rdx,0x90(%rsp)
    6964:	00 
        uefi_call_wrapper(ps.SetAttr, 2, ps.Context, attr);
    6965:	48 8b 8c 24 c8 00 00 	mov    0xc8(%rsp),%rcx
    696c:	00 
    696d:	ff d6                	call   *%rsi
    _Print (&ps);
    696f:	4c 89 ef             	mov    %r13,%rdi
    6972:	e8 49 f4 ff ff       	call   5dc0 <_Print>
    if (ps.SetAttr) {
    6977:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
    697e:	00 
    697f:	48 85 c0             	test   %rax,%rax
    6982:	0f 84 cf fe ff ff    	je     6857 <DbgPrint+0x87>
        uefi_call_wrapper(ps.SetAttr, 2, ps.Context, SavedAttribute);
    6988:	48 8b 8c 24 c8 00 00 	mov    0xc8(%rsp),%rcx
    698f:	00 
    6990:	4c 89 e2             	mov    %r12,%rdx
    6993:	ff d0                	call   *%rax
}
    6995:	48 81 c4 98 01 00 00 	add    $0x198,%rsp
    699c:	31 c0                	xor    %eax,%eax
    699e:	5b                   	pop    %rbx
    699f:	5d                   	pop    %rbp
    69a0:	41 5c                	pop    %r12
    69a2:	41 5d                	pop    %r13
    69a4:	c3                   	ret    
    69a5:	0f 1f 00             	nopl   (%rax)
        DbgOut = ST->StdErr;
    69a8:	48 8b 05 89 6c 01 00 	mov    0x16c89(%rip),%rax        # 1d638 <ST>
    69af:	48 8b 50 50          	mov    0x50(%rax),%rdx
    if (DbgOut) {
    69b3:	48 85 d2             	test   %rdx,%rdx
    69b6:	0f 85 3a ff ff ff    	jne    68f6 <DbgPrint+0x126>
    if (ps.SetAttr) {
    69bc:	b8 4e 00 00 00       	mov    $0x4e,%eax
    69c1:	b9 4f 00 00 00       	mov    $0x4f,%ecx
    69c6:	ba 47 00 00 00       	mov    $0x47,%edx
    69cb:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
    69d2:	00 
    69d3:	41 bc 47 00 00 00    	mov    $0x47,%r12d
    69d9:	e9 51 ff ff ff       	jmp    692f <_text_size+0x2f>
    69de:	66 90                	xchg   %ax,%ax

00000000000069e0 <_PoolCatPrint>:
{
    69e0:	f3 0f 1e fa          	endbr64 
    69e4:	41 56                	push   %r14
    69e6:	41 55                	push   %r13
    69e8:	49 89 cd             	mov    %rcx,%r13
    69eb:	41 54                	push   %r12
    69ed:	49 89 d4             	mov    %rdx,%r12
    69f0:	55                   	push   %rbp
    69f1:	48 89 fd             	mov    %rdi,%rbp
    69f4:	53                   	push   %rbx
    69f5:	48 89 f3             	mov    %rsi,%rbx
    ZeroMem (&ps, sizeof(ps));
    69f8:	be 98 00 00 00       	mov    $0x98,%esi
{
    69fd:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    ZeroMem (&ps, sizeof(ps));
    6a04:	49 89 e6             	mov    %rsp,%r14
    6a07:	4c 89 f7             	mov    %r14,%rdi
    6a0a:	e8 71 df ff ff       	call   4980 <ZeroMem>
    ps.Output  = Output;
    6a0f:	4c 89 6c 24 78       	mov    %r13,0x78(%rsp)
    _Print (&ps);
    6a14:	4c 89 f7             	mov    %r14,%rdi
    ps.Context = spc;
    6a17:	4c 89 a4 24 88 00 00 	mov    %r12,0x88(%rsp)
    6a1e:	00 
    ps.fmt.pw = fmt;
    6a1f:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
    va_copy(ps.args, args);
    6a24:	f3 0f 6f 03          	movdqu (%rbx),%xmm0
    6a28:	0f 11 44 24 18       	movups %xmm0,0x18(%rsp)
    6a2d:	48 8b 43 10          	mov    0x10(%rbx),%rax
    6a31:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    _Print (&ps);
    6a36:	e8 85 f3 ff ff       	call   5dc0 <_Print>
}
    6a3b:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    6a42:	5b                   	pop    %rbx
    6a43:	5d                   	pop    %rbp
    6a44:	41 5c                	pop    %r12
    6a46:	41 5d                	pop    %r13
    6a48:	41 5e                	pop    %r14
    6a4a:	c3                   	ret    
    6a4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000006a50 <UnicodeVSPrint>:
{
    6a50:	f3 0f 1e fa          	endbr64 
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6a54:	48 d1 ee             	shr    %rsi
{
    6a57:	48 83 ec 28          	sub    $0x28,%rsp
    6a5b:	49 89 c8             	mov    %rcx,%r8
    6a5e:	49 89 f9             	mov    %rdi,%r9
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6a61:	48 83 ee 01          	sub    $0x1,%rsi
{
    6a65:	48 89 d7             	mov    %rdx,%rdi
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6a68:	48 89 e2             	mov    %rsp,%rdx
    spc.str    = Str;
    6a6b:	4c 89 0c 24          	mov    %r9,(%rsp)
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6a6f:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6a74:	48 8d 0d 25 e9 ff ff 	lea    -0x16db(%rip),%rcx        # 53a0 <_SPrint>
    6a7b:	4c 89 c6             	mov    %r8,%rsi
    spc.len    = 0;
    6a7e:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    6a85:	00 00 
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6a87:	e8 54 ff ff ff       	call   69e0 <_PoolCatPrint>
}
    6a8c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    6a91:	48 83 c4 28          	add    $0x28,%rsp
    6a95:	c3                   	ret    
    6a96:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6a9d:	00 00 00 

0000000000006aa0 <VPoolPrint>:
{
    6aa0:	f3 0f 1e fa          	endbr64 
    6aa4:	41 55                	push   %r13
    6aa6:	41 54                	push   %r12
    6aa8:	49 89 f4             	mov    %rsi,%r12
    ZeroMem (&spc, sizeof(spc));
    6aab:	be 18 00 00 00       	mov    $0x18,%esi
{
    6ab0:	55                   	push   %rbp
    6ab1:	48 89 fd             	mov    %rdi,%rbp
    6ab4:	48 83 ec 20          	sub    $0x20,%rsp
    ZeroMem (&spc, sizeof(spc));
    6ab8:	49 89 e5             	mov    %rsp,%r13
    6abb:	4c 89 ef             	mov    %r13,%rdi
    6abe:	e8 bd de ff ff       	call   4980 <ZeroMem>
    _PoolCatPrint (fmt, args, &spc, _PoolPrint);
    6ac3:	4c 89 ea             	mov    %r13,%rdx
    6ac6:	4c 89 e6             	mov    %r12,%rsi
    6ac9:	48 89 ef             	mov    %rbp,%rdi
    6acc:	48 8d 0d fd e9 ff ff 	lea    -0x1603(%rip),%rcx        # 54d0 <_PoolPrint>
    6ad3:	e8 08 ff ff ff       	call   69e0 <_PoolCatPrint>
}
    6ad8:	48 8b 04 24          	mov    (%rsp),%rax
    6adc:	48 83 c4 20          	add    $0x20,%rsp
    6ae0:	5d                   	pop    %rbp
    6ae1:	41 5c                	pop    %r12
    6ae3:	41 5d                	pop    %r13
    6ae5:	c3                   	ret    
    6ae6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    6aed:	00 00 00 

0000000000006af0 <CatPrint>:
{
    6af0:	f3 0f 1e fa          	endbr64 
    6af4:	53                   	push   %rbx
    6af5:	48 89 fb             	mov    %rdi,%rbx
    6af8:	48 89 f7             	mov    %rsi,%rdi
    6afb:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
    6b02:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    6b07:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    6b0c:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6b11:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    6b16:	84 c0                	test   %al,%al
    6b18:	74 37                	je     6b51 <CatPrint+0x61>
    6b1a:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    6b1f:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    6b24:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6b29:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    6b30:	00 
    6b31:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    6b38:	00 
    6b39:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    6b40:	00 
    6b41:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    6b48:	00 
    6b49:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    6b50:	00 
    va_start (args, fmt);
    6b51:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    6b58:	00 
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    6b59:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    6b5e:	48 89 da             	mov    %rbx,%rdx
    va_start (args, fmt);
    6b61:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
    6b68:	00 
    6b69:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    6b6e:	48 8d 0d 5b e9 ff ff 	lea    -0x16a5(%rip),%rcx        # 54d0 <_PoolPrint>
    va_start (args, fmt);
    6b75:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    6b7a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    6b7f:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    6b86:	00 
    _PoolCatPrint (fmt, args, Str, _PoolPrint);
    6b87:	e8 54 fe ff ff       	call   69e0 <_PoolCatPrint>
    return Str->str;
    6b8c:	48 8b 03             	mov    (%rbx),%rax
}
    6b8f:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
    6b96:	5b                   	pop    %rbx
    6b97:	c3                   	ret    
    6b98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    6b9f:	00 

0000000000006ba0 <PoolPrint>:
{
    6ba0:	f3 0f 1e fa          	endbr64 
    6ba4:	41 54                	push   %r12
    6ba6:	55                   	push   %rbp
    6ba7:	48 89 fd             	mov    %rdi,%rbp
    6baa:	48 81 ec e8 00 00 00 	sub    $0xe8,%rsp
    6bb1:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
    6bb6:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
    6bbb:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
    6bc0:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
    6bc5:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
    6bca:	84 c0                	test   %al,%al
    6bcc:	74 3a                	je     6c08 <PoolPrint+0x68>
    6bce:	0f 29 44 24 60       	movaps %xmm0,0x60(%rsp)
    6bd3:	0f 29 4c 24 70       	movaps %xmm1,0x70(%rsp)
    6bd8:	0f 29 94 24 80 00 00 	movaps %xmm2,0x80(%rsp)
    6bdf:	00 
    6be0:	0f 29 9c 24 90 00 00 	movaps %xmm3,0x90(%rsp)
    6be7:	00 
    6be8:	0f 29 a4 24 a0 00 00 	movaps %xmm4,0xa0(%rsp)
    6bef:	00 
    6bf0:	0f 29 ac 24 b0 00 00 	movaps %xmm5,0xb0(%rsp)
    6bf7:	00 
    6bf8:	0f 29 b4 24 c0 00 00 	movaps %xmm6,0xc0(%rsp)
    6bff:	00 
    6c00:	0f 29 bc 24 d0 00 00 	movaps %xmm7,0xd0(%rsp)
    6c07:	00 
    ZeroMem (&spc, sizeof(spc));
    6c08:	49 89 e4             	mov    %rsp,%r12
    va_start (args, fmt);
    6c0b:	48 8d 84 24 00 01 00 	lea    0x100(%rsp),%rax
    6c12:	00 
    ZeroMem (&spc, sizeof(spc));
    6c13:	be 18 00 00 00       	mov    $0x18,%esi
    va_start (args, fmt);
    6c18:	c7 44 24 18 08 00 00 	movl   $0x8,0x18(%rsp)
    6c1f:	00 
    6c20:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    ZeroMem (&spc, sizeof(spc));
    6c25:	4c 89 e7             	mov    %r12,%rdi
    va_start (args, fmt);
    6c28:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
    6c2d:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    6c32:	c7 44 24 1c 30 00 00 	movl   $0x30,0x1c(%rsp)
    6c39:	00 
    ZeroMem (&spc, sizeof(spc));
    6c3a:	e8 41 dd ff ff       	call   4980 <ZeroMem>
    _PoolCatPrint (fmt, args, &spc, _PoolPrint);
    6c3f:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    6c44:	4c 89 e2             	mov    %r12,%rdx
    6c47:	48 89 ef             	mov    %rbp,%rdi
    6c4a:	48 8d 0d 7f e8 ff ff 	lea    -0x1781(%rip),%rcx        # 54d0 <_PoolPrint>
    6c51:	e8 8a fd ff ff       	call   69e0 <_PoolCatPrint>
}
    6c56:	48 8b 04 24          	mov    (%rsp),%rax
    6c5a:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    6c61:	5d                   	pop    %rbp
    6c62:	41 5c                	pop    %r12
    6c64:	c3                   	ret    
    6c65:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    6c6c:	00 00 00 00 

0000000000006c70 <UnicodeSPrint>:
{
    6c70:	f3 0f 1e fa          	endbr64 
    6c74:	48 81 ec e8 00 00 00 	sub    $0xe8,%rsp
    6c7b:	49 89 fa             	mov    %rdi,%r10
    6c7e:	48 89 d7             	mov    %rdx,%rdi
    6c81:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
    6c86:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
    6c8b:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
    6c90:	84 c0                	test   %al,%al
    6c92:	74 3a                	je     6cce <UnicodeSPrint+0x5e>
    6c94:	0f 29 44 24 60       	movaps %xmm0,0x60(%rsp)
    6c99:	0f 29 4c 24 70       	movaps %xmm1,0x70(%rsp)
    6c9e:	0f 29 94 24 80 00 00 	movaps %xmm2,0x80(%rsp)
    6ca5:	00 
    6ca6:	0f 29 9c 24 90 00 00 	movaps %xmm3,0x90(%rsp)
    6cad:	00 
    6cae:	0f 29 a4 24 a0 00 00 	movaps %xmm4,0xa0(%rsp)
    6cb5:	00 
    6cb6:	0f 29 ac 24 b0 00 00 	movaps %xmm5,0xb0(%rsp)
    6cbd:	00 
    6cbe:	0f 29 b4 24 c0 00 00 	movaps %xmm6,0xc0(%rsp)
    6cc5:	00 
    6cc6:	0f 29 bc 24 d0 00 00 	movaps %xmm7,0xd0(%rsp)
    6ccd:	00 
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6cce:	48 d1 ee             	shr    %rsi
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6cd1:	48 89 e2             	mov    %rsp,%rdx
    va_start (args, fmt);
    6cd4:	48 8d 84 24 f0 00 00 	lea    0xf0(%rsp),%rax
    6cdb:	00 
    6cdc:	c7 44 24 18 18 00 00 	movl   $0x18,0x18(%rsp)
    6ce3:	00 
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6ce4:	48 83 ee 01          	sub    $0x1,%rsi
    va_start (args, fmt);
    6ce8:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6ced:	48 8d 0d ac e6 ff ff 	lea    -0x1954(%rip),%rcx        # 53a0 <_SPrint>
    va_start (args, fmt);
    6cf4:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6cf9:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6cfe:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
    va_start (args, fmt);
    6d03:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    6d08:	c7 44 24 1c 30 00 00 	movl   $0x30,0x1c(%rsp)
    6d0f:	00 
    spc.str    = Str;
    6d10:	4c 89 14 24          	mov    %r10,(%rsp)
    spc.len    = 0;
    6d14:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    6d1b:	00 00 
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6d1d:	e8 be fc ff ff       	call   69e0 <_PoolCatPrint>
}
    6d22:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    6d27:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    6d2e:	c3                   	ret    
    6d2f:	90                   	nop

0000000000006d30 <AsciiVSPrint>:
{
    6d30:	f3 0f 1e fa          	endbr64 
    6d34:	41 57                	push   %r15
    6d36:	49 89 d7             	mov    %rdx,%r15
    6d39:	41 56                	push   %r14
    6d3b:	49 89 ce             	mov    %rcx,%r14
    6d3e:	41 55                	push   %r13
    6d40:	49 89 f5             	mov    %rsi,%r13
    6d43:	41 54                	push   %r12
        return 0;
    6d45:	45 31 e4             	xor    %r12d,%r12d
{
    6d48:	55                   	push   %rbp
    6d49:	53                   	push   %rbx
    6d4a:	48 89 fb             	mov    %rdi,%rbx
    UnicodeStr = AllocatePool(StrSize * sizeof(CHAR16));
    6d4d:	48 8d 3c 36          	lea    (%rsi,%rsi,1),%rdi
{
    6d51:	48 83 ec 28          	sub    $0x28,%rsp
    UnicodeStr = AllocatePool(StrSize * sizeof(CHAR16));
    6d55:	e8 e6 da ff ff       	call   4840 <AllocatePool>
    if (!UnicodeStr)
    6d5a:	48 85 c0             	test   %rax,%rax
    6d5d:	74 7f                	je     6dde <AsciiVSPrint+0xae>
    UnicodeFmt = PoolPrint(L"%a", fmt);
    6d5f:	4c 89 fe             	mov    %r15,%rsi
    6d62:	48 89 c5             	mov    %rax,%rbp
    6d65:	48 8d 3d 64 2b 02 00 	lea    0x22b64(%rip),%rdi        # 298d0 <_DYNAMIC+0xb8d0>
    6d6c:	31 c0                	xor    %eax,%eax
    6d6e:	e8 2d fe ff ff       	call   6ba0 <PoolPrint>
    6d73:	49 89 c7             	mov    %rax,%r15
    if (!UnicodeFmt) {
    6d76:	48 85 c0             	test   %rax,%rax
    6d79:	74 5b                	je     6dd6 <AsciiVSPrint+0xa6>
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6d7b:	49 d1 ed             	shr    %r13
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6d7e:	48 89 c7             	mov    %rax,%rdi
    6d81:	48 89 e2             	mov    %rsp,%rdx
    6d84:	4c 89 f6             	mov    %r14,%rsi
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6d87:	49 83 ed 01          	sub    $0x1,%r13
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6d8b:	48 8d 0d 0e e6 ff ff 	lea    -0x19f2(%rip),%rcx        # 53a0 <_SPrint>
    spc.str    = Str;
    6d92:	48 89 2c 24          	mov    %rbp,(%rsp)
    spc.maxlen = StrSize / sizeof(CHAR16) - 1;
    6d96:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
    spc.len    = 0;
    6d9b:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    6da2:	00 00 
    _PoolCatPrint (fmt, args, &spc, _SPrint);
    6da4:	e8 37 fc ff ff       	call   69e0 <_PoolCatPrint>
    return spc.len;
    6da9:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
    FreePool(UnicodeFmt);
    6dae:	4c 89 ff             	mov    %r15,%rdi
    6db1:	e8 aa db ff ff       	call   4960 <FreePool>
    for (i = 0; i < Len; i++)
    6db6:	4d 85 e4             	test   %r12,%r12
    6db9:	74 16                	je     6dd1 <AsciiVSPrint+0xa1>
    6dbb:	31 c0                	xor    %eax,%eax
    6dbd:	0f 1f 00             	nopl   (%rax)
        Str[i] = (CHAR8)UnicodeStr[i];
    6dc0:	0f b7 54 45 00       	movzwl 0x0(%rbp,%rax,2),%edx
    6dc5:	88 14 03             	mov    %dl,(%rbx,%rax,1)
    for (i = 0; i < Len; i++)
    6dc8:	48 83 c0 01          	add    $0x1,%rax
    6dcc:	4c 39 e0             	cmp    %r12,%rax
    6dcf:	75 ef                	jne    6dc0 <AsciiVSPrint+0x90>
    Str[Len] = 0;
    6dd1:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
    FreePool(UnicodeStr);
    6dd6:	48 89 ef             	mov    %rbp,%rdi
    6dd9:	e8 82 db ff ff       	call   4960 <FreePool>
}
    6dde:	48 83 c4 28          	add    $0x28,%rsp
    6de2:	4c 89 e0             	mov    %r12,%rax
    6de5:	5b                   	pop    %rbx
    6de6:	5d                   	pop    %rbp
    6de7:	41 5c                	pop    %r12
    6de9:	41 5d                	pop    %r13
    6deb:	41 5e                	pop    %r14
    6ded:	41 5f                	pop    %r15
    6def:	c3                   	ret    

0000000000006df0 <_IPrint>:
{
    6df0:	f3 0f 1e fa          	endbr64 
    6df4:	41 57                	push   %r15
    6df6:	49 89 f7             	mov    %rsi,%r15
    ZeroMem (&ps, sizeof(ps));
    6df9:	be 98 00 00 00       	mov    $0x98,%esi
{
    6dfe:	41 56                	push   %r14
    6e00:	49 89 fe             	mov    %rdi,%r14
    6e03:	41 55                	push   %r13
    6e05:	49 89 cd             	mov    %rcx,%r13
    6e08:	41 54                	push   %r12
    6e0a:	55                   	push   %rbp
    6e0b:	4c 89 cd             	mov    %r9,%rbp
    6e0e:	53                   	push   %rbx
    6e0f:	48 89 d3             	mov    %rdx,%rbx
    6e12:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    ZeroMem (&ps, sizeof(ps));
    6e19:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
{
    6e1e:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
    ZeroMem (&ps, sizeof(ps));
    6e23:	4c 89 e7             	mov    %r12,%rdi
    6e26:	e8 55 db ff ff       	call   4980 <ZeroMem>
    ps.Output  = (INTN (EFIAPI *)(VOID *, CHAR16 *)) Out->OutputString;
    6e2b:	48 8b 43 08          	mov    0x8(%rbx),%rax
    ps.Context = Out;
    6e2f:	48 89 9c 24 b8 00 00 	mov    %rbx,0xb8(%rsp)
    6e36:	00 
    ps.Output  = (INTN (EFIAPI *)(VOID *, CHAR16 *)) Out->OutputString;
    6e37:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
    6e3e:	00 
    ps.SetAttr = (INTN (EFIAPI *)(VOID *, UINTN))  Out->SetAttribute;
    6e3f:	48 8b 43 28          	mov    0x28(%rbx),%rax
    6e43:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
    6e4a:	00 
    ps.Attr = Out->Mode->Attribute;
    6e4b:	48 8b 43 48          	mov    0x48(%rbx),%rax
    6e4f:	48 63 50 08          	movslq 0x8(%rax),%rdx
    6e53:	48 89 d0             	mov    %rdx,%rax
    6e56:	48 89 94 24 80 00 00 	mov    %rdx,0x80(%rsp)
    6e5d:	00 
    ps.AttrNorm = EFI_TEXT_ATTR(EFI_LIGHTGRAY, back);
    6e5e:	25 f0 00 00 00       	and    $0xf0,%eax
    6e63:	89 c2                	mov    %eax,%edx
    6e65:	83 ca 07             	or     $0x7,%edx
    6e68:	48 89 94 24 90 00 00 	mov    %rdx,0x90(%rsp)
    6e6f:	00 
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    6e70:	89 c2                	mov    %eax,%edx
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    6e72:	83 c8 0e             	or     $0xe,%eax
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    6e75:	83 ca 0f             	or     $0xf,%edx
    ps.AttrError = EFI_TEXT_ATTR(EFI_YELLOW, back);
    6e78:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    6e7f:	00 
    ps.AttrHighlight = EFI_TEXT_ATTR(EFI_WHITE, back);
    6e80:	48 89 94 24 98 00 00 	mov    %rdx,0x98(%rsp)
    6e87:	00 
    if (fmt) {
    6e88:	4d 85 ed             	test   %r13,%r13
    6e8b:	74 4b                	je     6ed8 <_IPrint+0xe8>
        ps.fmt.pw = fmt;
    6e8d:	4c 89 6c 24 40       	mov    %r13,0x40(%rsp)
    va_copy(ps.args, args);
    6e92:	f3 0f 6f 45 00       	movdqu 0x0(%rbp),%xmm0
    6e97:	48 8b 45 10          	mov    0x10(%rbp),%rax
    6e9b:	0f 11 44 24 48       	movups %xmm0,0x48(%rsp)
    6ea0:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    if (Column != (UINTN) -1) {
    6ea5:	49 83 fe ff          	cmp    $0xffffffffffffffff,%r14
    6ea9:	74 0c                	je     6eb7 <_IPrint+0xc7>
        uefi_call_wrapper(Out->SetCursorPosition, 3, Out, Column, Row);
    6eab:	4d 89 f8             	mov    %r15,%r8
    6eae:	4c 89 f2             	mov    %r14,%rdx
    6eb1:	48 89 d9             	mov    %rbx,%rcx
    6eb4:	ff 53 38             	call   *0x38(%rbx)
    back = _Print (&ps);
    6eb7:	4c 89 e7             	mov    %r12,%rdi
    6eba:	e8 01 ef ff ff       	call   5dc0 <_Print>
}
    6ebf:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    6ec6:	5b                   	pop    %rbx
    6ec7:	5d                   	pop    %rbp
    6ec8:	41 5c                	pop    %r12
    6eca:	41 5d                	pop    %r13
    6ecc:	41 5e                	pop    %r14
    6ece:	41 5f                	pop    %r15
    6ed0:	c3                   	ret    
    6ed1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        ps.fmt.pc = fmta;
    6ed8:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
        ps.fmt.Ascii = TRUE;
    6edd:	c6 44 24 30 01       	movb   $0x1,0x30(%rsp)
        ps.fmt.pc = fmta;
    6ee2:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    6ee7:	eb a9                	jmp    6e92 <_IPrint+0xa2>
    6ee9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000006ef0 <Print>:
{
    6ef0:	f3 0f 1e fa          	endbr64 
    6ef4:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    6efb:	49 89 fa             	mov    %rdi,%r10
    6efe:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    6f03:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    6f08:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    6f0d:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6f12:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    6f17:	84 c0                	test   %al,%al
    6f19:	74 37                	je     6f52 <Print+0x62>
    6f1b:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    6f20:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    6f25:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    6f2a:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    6f31:	00 
    6f32:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    6f39:	00 
    6f3a:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    6f41:	00 
    6f42:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    6f49:	00 
    6f4a:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    6f51:	00 
    va_start (args, fmt);
    6f52:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    6f59:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6f5a:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    6f5f:	45 31 c0             	xor    %r8d,%r8d
    6f62:	4c 89 d1             	mov    %r10,%rcx
    va_start (args, fmt);
    6f65:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    6f6a:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6f6f:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    6f76:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    va_start (args, fmt);
    6f7d:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6f82:	48 8b 05 af 66 01 00 	mov    0x166af(%rip),%rax        # 1d638 <ST>
    va_start (args, fmt);
    6f89:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
    6f90:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6f91:	48 8b 50 40          	mov    0x40(%rax),%rdx
    va_start (args, fmt);
    6f95:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    6f9c:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6f9d:	e8 4e fe ff ff       	call   6df0 <_IPrint>
}
    6fa2:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    6fa9:	c3                   	ret    
    6faa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000006fb0 <VPrint>:
{
    6fb0:	f3 0f 1e fa          	endbr64 
    return _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6fb4:	48 8b 05 7d 66 01 00 	mov    0x1667d(%rip),%rax        # 1d638 <ST>
{
    6fbb:	48 89 f9             	mov    %rdi,%rcx
    6fbe:	49 89 f1             	mov    %rsi,%r9
    return _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, fmt, NULL, args);
    6fc1:	45 31 c0             	xor    %r8d,%r8d
    6fc4:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    6fcb:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    6fd2:	48 8b 50 40          	mov    0x40(%rax),%rdx
    6fd6:	e9 15 fe ff ff       	jmp    6df0 <_IPrint>
    6fdb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000006fe0 <PrintAt>:
{
    6fe0:	f3 0f 1e fa          	endbr64 
    6fe4:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    6feb:	49 89 d2             	mov    %rdx,%r10
    6fee:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    6ff3:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    6ff8:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    6ffd:	84 c0                	test   %al,%al
    6fff:	74 37                	je     7038 <PrintAt+0x58>
    7001:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    7006:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    700b:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    7010:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    7017:	00 
    7018:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    701f:	00 
    7020:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    7027:	00 
    7028:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    702f:	00 
    7030:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    7037:	00 
    va_start (args, fmt);
    7038:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    703f:	00 
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    7040:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    7045:	45 31 c0             	xor    %r8d,%r8d
    7048:	4c 89 d1             	mov    %r10,%rcx
    va_start (args, fmt);
    704b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    7050:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    7055:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    705a:	48 8b 05 d7 65 01 00 	mov    0x165d7(%rip),%rax        # 1d638 <ST>
    va_start (args, fmt);
    7061:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%rsp)
    7068:	00 
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    7069:	48 8b 50 40          	mov    0x40(%rax),%rdx
    va_start (args, fmt);
    706d:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    7074:	00 
    back = _IPrint (Column, Row, ST->ConOut, fmt, NULL, args);
    7075:	e8 76 fd ff ff       	call   6df0 <_IPrint>
}
    707a:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    7081:	c3                   	ret    
    7082:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7089:	00 00 00 00 
    708d:	0f 1f 00             	nopl   (%rax)

0000000000007090 <IPrint>:
{
    7090:	f3 0f 1e fa          	endbr64 
    7094:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    709b:	49 89 fa             	mov    %rdi,%r10
    709e:	49 89 f3             	mov    %rsi,%r11
    70a1:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    70a6:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    70ab:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    70b0:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    70b5:	84 c0                	test   %al,%al
    70b7:	74 37                	je     70f0 <IPrint+0x60>
    70b9:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    70be:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    70c3:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    70c8:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    70cf:	00 
    70d0:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    70d7:	00 
    70d8:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    70df:	00 
    70e0:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    70e7:	00 
    70e8:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    70ef:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
    70f0:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    70f5:	45 31 c0             	xor    %r8d,%r8d
    70f8:	4c 89 d9             	mov    %r11,%rcx
    70fb:	4c 89 d2             	mov    %r10,%rdx
    va_start (args, fmt);
    70fe:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    7105:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
    7106:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    710d:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    va_start (args, fmt);
    7114:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
    711b:	00 
    711c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    7121:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    7126:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    712d:	00 
    712e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint ((UINTN) -1, (UINTN) -1, Out, fmt, NULL, args);
    7133:	e8 b8 fc ff ff       	call   6df0 <_IPrint>
}
    7138:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    713f:	c3                   	ret    

0000000000007140 <IPrintAt>:
{
    7140:	f3 0f 1e fa          	endbr64 
    7144:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    714b:	49 89 fa             	mov    %rdi,%r10
    714e:	48 89 f7             	mov    %rsi,%rdi
    7151:	48 89 d6             	mov    %rdx,%rsi
    7154:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    7159:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    715e:	84 c0                	test   %al,%al
    7160:	74 37                	je     7199 <IPrintAt+0x59>
    7162:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    7167:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    716c:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    7171:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    7178:	00 
    7179:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    7180:	00 
    7181:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    7188:	00 
    7189:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    7190:	00 
    7191:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    7198:	00 
    va_start (args, fmt);
    7199:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    71a0:	00 
    back = _IPrint (Column, Row, Out, fmt, NULL, args);
    71a1:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    71a6:	45 31 c0             	xor    %r8d,%r8d
    71a9:	4c 89 d2             	mov    %r10,%rdx
    va_start (args, fmt);
    71ac:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    71b1:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    71b6:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%rsp)
    71bd:	00 
    71be:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    71c5:	00 
    71c6:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint (Column, Row, Out, fmt, NULL, args);
    71cb:	e8 20 fc ff ff       	call   6df0 <_IPrint>
}
    71d0:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    71d7:	c3                   	ret    
    71d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    71df:	00 

00000000000071e0 <AsciiPrint>:
{
    71e0:	f3 0f 1e fa          	endbr64 
    71e4:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    71eb:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    71f0:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    71f5:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    71fa:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    71ff:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    7204:	84 c0                	test   %al,%al
    7206:	74 37                	je     723f <AsciiPrint+0x5f>
    7208:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    720d:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    7212:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    7217:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    721e:	00 
    721f:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    7226:	00 
    7227:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    722e:	00 
    722f:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    7236:	00 
    7237:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    723e:	00 
    va_start (args, fmt);
    723f:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    7246:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    7247:	4c 8d 4c 24 08       	lea    0x8(%rsp),%r9
    724c:	49 89 f8             	mov    %rdi,%r8
    724f:	31 c9                	xor    %ecx,%ecx
    va_start (args, fmt);
    7251:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    7256:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    725b:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    7262:	48 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%rdi
    va_start (args, fmt);
    7269:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    726e:	48 8b 05 c3 63 01 00 	mov    0x163c3(%rip),%rax        # 1d638 <ST>
    va_start (args, fmt);
    7275:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
    727c:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    727d:	48 8b 50 40          	mov    0x40(%rax),%rdx
    va_start (args, fmt);
    7281:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    7288:	00 
    back = _IPrint ((UINTN) -1, (UINTN) -1, ST->ConOut, NULL, fmt, args);
    7289:	e8 62 fb ff ff       	call   6df0 <_IPrint>
}
    728e:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    7295:	c3                   	ret    
    7296:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    729d:	00 00 00 

00000000000072a0 <DumpHex>:
    IN UINTN        Indent,
    IN UINTN        Offset,
    IN UINTN        DataSize,
    IN VOID         *UserData
    )
{
    72a0:	f3 0f 1e fa          	endbr64 
    72a4:	41 57                	push   %r15
    72a6:	41 56                	push   %r14
    72a8:	49 89 d6             	mov    %rdx,%r14
    72ab:	41 55                	push   %r13
    72ad:	41 54                	push   %r12
    72af:	49 89 cc             	mov    %rcx,%r12
    72b2:	55                   	push   %rbp
    72b3:	53                   	push   %rbx
    72b4:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    UINTN           TempColumn;
    UINTN           ScreenSize;
    CHAR16          ReturnStr[1];


    uefi_call_wrapper(ST->ConOut->QueryMode, 4, ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    72bb:	48 8b 05 76 63 01 00 	mov    0x16376(%rip),%rax        # 1d638 <ST>
{
    72c2:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    uefi_call_wrapper(ST->ConOut->QueryMode, 4, ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    72c7:	4c 8d 4c 24 68       	lea    0x68(%rsp),%r9
    72cc:	4c 8d 44 24 60       	lea    0x60(%rsp),%r8
    72d1:	48 8b 40 40          	mov    0x40(%rax),%rax
{
    72d5:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    uefi_call_wrapper(ST->ConOut->QueryMode, 4, ST->ConOut, ST->ConOut->Mode->Mode, &TempColumn, &ScreenSize);
    72da:	48 8b 50 48          	mov    0x48(%rax),%rdx
    72de:	48 89 c1             	mov    %rax,%rcx
    72e1:	48 63 52 04          	movslq 0x4(%rdx),%rdx
    72e5:	ff 50 18             	call   *0x18(%rax)
    ScreenCount = 0;
    ScreenSize -= 2;
    72e8:	48 83 6c 24 68 02    	subq   $0x2,0x68(%rsp)

    Data = UserData;
    while (DataSize) {
    72ee:	4d 85 f6             	test   %r14,%r14
    72f1:	0f 84 51 01 00 00    	je     7448 <DumpHex+0x1a8>
    ScreenCount = 0;
    72f7:	45 31 db             	xor    %r11d,%r11d
            //
            // If ScreenSize == 0 we have the console redirected so don't
            //  block updates
            //
            ScreenCount = 0;
            Print (L"Press Enter to continue :");
    72fa:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    72ff:	4d 89 f2             	mov    %r14,%r10
    7302:	4c 8d 7c 24 70       	lea    0x70(%rsp),%r15
    7307:	48 8d 1d 12 5e 01 00 	lea    0x15e12(%rip),%rbx        # 1d120 <Hex>
    730e:	48 8d 84 24 92 00 00 	lea    0x92(%rsp),%rax
    7315:	00 
            Val[Index*3+2] = (Index == 7)?'-':' ';
    7316:	41 bd 20 00 00 00    	mov    $0x20,%r13d
            Print (L"Press Enter to continue :");
    731c:	4d 89 de             	mov    %r11,%r14
    731f:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    7324:	48 8d 84 24 90 00 00 	lea    0x90(%rsp),%rax
    732b:	00 
    732c:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    7331:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if (Size > DataSize) {
    7338:	49 83 fa 0f          	cmp    $0xf,%r10
    733c:	0f 86 1e 01 00 00    	jbe    7460 <DumpHex+0x1c0>
    7342:	49 83 ea 10          	sub    $0x10,%r10
        Size = 16;
    7346:	bd 10 00 00 00       	mov    $0x10,%ebp
            c = Data[Index];
    734b:	41 0f b6 04 24       	movzbl (%r12),%eax
            Val[Index*3+0] = Hex[c>>4];
    7350:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
            Val[Index*3+2] = (Index == 7)?'-':' ';
    7355:	bf 20 00 00 00       	mov    $0x20,%edi
            Str[Index] = (c < ' ' || c > 'z') ? '.' : c;
    735a:	41 b8 2e 00 00 00    	mov    $0x2e,%r8d
            Val[Index*3+2] = (Index == 7)?'-':' ';
    7360:	41 b9 2d 00 00 00    	mov    $0x2d,%r9d
            Val[Index*3+0] = Hex[c>>4];
    7366:	89 c2                	mov    %eax,%edx
    7368:	c0 ea 04             	shr    $0x4,%dl
    736b:	83 e2 0f             	and    $0xf,%edx
    736e:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    7372:	88 94 24 90 00 00 00 	mov    %dl,0x90(%rsp)
            Val[Index*3+1] = Hex[c&0xF];
    7379:	48 89 c2             	mov    %rax,%rdx
    737c:	83 e2 0f             	and    $0xf,%edx
    737f:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    7383:	88 94 24 91 00 00 00 	mov    %dl,0x91(%rsp)
        for (Index=0; Index < Size; Index += 1) {
    738a:	31 d2                	xor    %edx,%edx
    738c:	eb 35                	jmp    73c3 <DumpHex+0x123>
    738e:	66 90                	xchg   %ax,%ax
            c = Data[Index];
    7390:	41 0f b6 04 14       	movzbl (%r12,%rdx,1),%eax
            Val[Index*3+0] = Hex[c>>4];
    7395:	89 c7                	mov    %eax,%edi
    7397:	40 c0 ef 04          	shr    $0x4,%dil
    739b:	83 e7 0f             	and    $0xf,%edi
    739e:	0f b6 3c 3b          	movzbl (%rbx,%rdi,1),%edi
    73a2:	40 88 7e 01          	mov    %dil,0x1(%rsi)
            Val[Index*3+1] = Hex[c&0xF];
    73a6:	48 89 c7             	mov    %rax,%rdi
    73a9:	83 e7 0f             	and    $0xf,%edi
            Val[Index*3+2] = (Index == 7)?'-':' ';
    73ac:	48 83 fa 07          	cmp    $0x7,%rdx
            Val[Index*3+1] = Hex[c&0xF];
    73b0:	0f b6 3c 3b          	movzbl (%rbx,%rdi,1),%edi
    73b4:	40 88 7e 02          	mov    %dil,0x2(%rsi)
            Val[Index*3+2] = (Index == 7)?'-':' ';
    73b8:	44 89 ef             	mov    %r13d,%edi
    73bb:	41 0f 44 f9          	cmove  %r9d,%edi
    73bf:	48 83 c6 03          	add    $0x3,%rsi
    73c3:	40 88 3e             	mov    %dil,(%rsi)
            Str[Index] = (c < ' ' || c > 'z') ? '.' : c;
    73c6:	8d 78 e0             	lea    -0x20(%rax),%edi
    73c9:	40 80 ff 5b          	cmp    $0x5b,%dil
    73cd:	41 0f 43 c0          	cmovae %r8d,%eax
    73d1:	41 88 04 17          	mov    %al,(%r15,%rdx,1)
        for (Index=0; Index < Size; Index += 1) {
    73d5:	48 83 c2 01          	add    $0x1,%rdx
    73d9:	48 39 d5             	cmp    %rdx,%rbp
    73dc:	75 b2                	jne    7390 <DumpHex+0xf0>
        Val[Index*3] = 0;
    73de:	48 8d 44 6d 00       	lea    0x0(%rbp,%rbp,2),%rax
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    73e3:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
    73e8:	4d 89 f9             	mov    %r15,%r9
        Data += Size;
    73eb:	49 01 ec             	add    %rbp,%r12
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    73ee:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
        Val[Index*3] = 0;
    73f3:	4c 89 54 24 30       	mov    %r10,0x30(%rsp)
        ScreenCount++;
    73f8:	49 83 c6 01          	add    $0x1,%r14
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    73fc:	48 8d 15 d3 24 02 00 	lea    0x224d3(%rip),%rdx        # 298d6 <_DYNAMIC+0xb8d6>
        Val[Index*3] = 0;
    7403:	c6 84 04 90 00 00 00 	movb   $0x0,0x90(%rsp,%rax,1)
    740a:	00 
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    740b:	48 8d 3d c6 24 02 00 	lea    0x224c6(%rip),%rdi        # 298d8 <_DYNAMIC+0xb8d8>
    7412:	31 c0                	xor    %eax,%eax
    7414:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
        Str[Index] = 0;
    7419:	c6 44 2c 70 00       	movb   $0x0,0x70(%rsp,%rbp,1)
        Print (L"%*a%X: %-.48a *%a*\n", Indent, "", Offset, Val, Str);
    741e:	e8 cd fa ff ff       	call   6ef0 <Print>
        Offset += Size;
    7423:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
        if (ScreenCount >= ScreenSize && ScreenSize != 0) {
    7428:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    742d:	4c 8b 54 24 30       	mov    0x30(%rsp),%r10
        Offset += Size;
    7432:	48 01 e9             	add    %rbp,%rcx
        if (ScreenCount >= ScreenSize && ScreenSize != 0) {
    7435:	4c 39 f0             	cmp    %r14,%rax
    7438:	77 05                	ja     743f <DumpHex+0x19f>
    743a:	48 85 c0             	test   %rax,%rax
    743d:	75 31                	jne    7470 <DumpHex+0x1d0>
    while (DataSize) {
    743f:	4d 85 d2             	test   %r10,%r10
    7442:	0f 85 f0 fe ff ff    	jne    7338 <DumpHex+0x98>
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
            Print (L"\n");
        }

    }
}
    7448:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    744f:	5b                   	pop    %rbx
    7450:	5d                   	pop    %rbp
    7451:	41 5c                	pop    %r12
    7453:	41 5d                	pop    %r13
    7455:	41 5e                	pop    %r14
    7457:	41 5f                	pop    %r15
    7459:	c3                   	ret    
    745a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    7460:	4c 89 d5             	mov    %r10,%rbp
    7463:	45 31 d2             	xor    %r10d,%r10d
    7466:	e9 e0 fe ff ff       	jmp    734b <DumpHex+0xab>
    746b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            Print (L"Press Enter to continue :");
    7470:	48 8d 3d 89 24 02 00 	lea    0x22489(%rip),%rdi        # 29900 <_DYNAMIC+0xb900>
    7477:	31 c0                	xor    %eax,%eax
    7479:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
            ScreenCount = 0;
    747e:	45 31 f6             	xor    %r14d,%r14d
            Print (L"Press Enter to continue :");
    7481:	e8 6a fa ff ff       	call   6ef0 <Print>
            Input (L"", ReturnStr, sizeof(ReturnStr)/sizeof(CHAR16));
    7486:	48 8d 74 24 5e       	lea    0x5e(%rsp),%rsi
    748b:	ba 01 00 00 00       	mov    $0x1,%edx
    7490:	48 8d 3d 9d 24 02 00 	lea    0x2249d(%rip),%rdi        # 29934 <_DYNAMIC+0xb934>
    7497:	e8 d4 c0 ff ff       	call   3570 <Input>
            Print (L"\n");
    749c:	48 8d 3d 93 24 02 00 	lea    0x22493(%rip),%rdi        # 29936 <_DYNAMIC+0xb936>
    74a3:	31 c0                	xor    %eax,%eax
    74a5:	e8 46 fa ff ff       	call   6ef0 <Print>
            ScreenCount = 0;
    74aa:	4c 8b 54 24 30       	mov    0x30(%rsp),%r10
    74af:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    74b4:	eb 89                	jmp    743f <DumpHex+0x19f>
    74b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    74bd:	00 00 00 

00000000000074c0 <StrCmp>:
StrCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    )
// compare strings
{
    74c0:	f3 0f 1e fa          	endbr64 
    return RtStrCmp(s1, s2);
    74c4:	e9 37 07 00 00       	jmp    7c00 <RtStrCmp>
    74c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000074d0 <StrnCmp>:
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2,
    IN UINTN    len
    )
// compare strings
{
    74d0:	f3 0f 1e fa          	endbr64 
    while (*s1  &&  len) {
    74d4:	0f b7 07             	movzwl (%rdi),%eax
    74d7:	66 85 c0             	test   %ax,%ax
    74da:	75 21                	jne    74fd <StrnCmp+0x2d>
    74dc:	eb 2a                	jmp    7508 <StrnCmp+0x38>
    74de:	66 90                	xchg   %ax,%ax
        if (*s1 != *s2) {
    74e0:	0f b7 0e             	movzwl (%rsi),%ecx
    74e3:	66 39 c1             	cmp    %ax,%cx
    74e6:	75 2a                	jne    7512 <StrnCmp+0x42>
    while (*s1  &&  len) {
    74e8:	0f b7 47 02          	movzwl 0x2(%rdi),%eax
            break;
        }

        s1  += 1;
    74ec:	48 83 c7 02          	add    $0x2,%rdi
        s2  += 1;
    74f0:	48 83 c6 02          	add    $0x2,%rsi
        len -= 1;
    74f4:	48 83 ea 01          	sub    $0x1,%rdx
    while (*s1  &&  len) {
    74f8:	66 85 c0             	test   %ax,%ax
    74fb:	74 0b                	je     7508 <StrnCmp+0x38>
    74fd:	48 85 d2             	test   %rdx,%rdx
    7500:	75 de                	jne    74e0 <StrnCmp+0x10>
    }

    return len ? *s1 - *s2 : 0;
    7502:	31 c0                	xor    %eax,%eax
}
    7504:	c3                   	ret    
    7505:	0f 1f 00             	nopl   (%rax)
    return len ? *s1 - *s2 : 0;
    7508:	31 c0                	xor    %eax,%eax
    750a:	48 85 d2             	test   %rdx,%rdx
    750d:	74 f5                	je     7504 <StrnCmp+0x34>
    750f:	0f b7 0e             	movzwl (%rsi),%ecx
    7512:	29 c8                	sub    %ecx,%eax
    7514:	48 98                	cltq   
    7516:	c3                   	ret    
    7517:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    751e:	00 00 

0000000000007520 <LibStubStriCmp>:
LibStubStriCmp (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This EFI_UNUSED,
    IN CHAR16                           *s1,
    IN CHAR16                           *s2
    )
{
    7520:	f3 0f 1e fa          	endbr64 
    7524:	57                   	push   %rdi
    7525:	48 89 d7             	mov    %rdx,%rdi
    7528:	56                   	push   %rsi
    7529:	4c 89 c6             	mov    %r8,%rsi
    752c:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    7533:	0f 29 34 24          	movaps %xmm6,(%rsp)
    7537:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    753c:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    7542:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    7548:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    754e:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    7554:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    755a:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    7560:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    7567:	00 00 
    7569:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    7570:	00 00 
    return RtStrCmp(s1, s2);
    7572:	e8 89 06 00 00       	call   7c00 <RtStrCmp>
    return StrCmp (s1, s2);
}
    7577:	0f 28 34 24          	movaps (%rsp),%xmm6
    757b:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    7580:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    7586:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    758c:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    7592:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    7598:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    759e:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    75a4:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    75ab:	00 00 
    75ad:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    75b4:	00 00 
    75b6:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    75bd:	5e                   	pop    %rsi
    75be:	5f                   	pop    %rdi
    75bf:	c3                   	ret    

00000000000075c0 <LibStubStrLwrUpr>:
VOID EFIAPI
LibStubStrLwrUpr (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This EFI_UNUSED,
    IN CHAR16                           *Str EFI_UNUSED
    )
{
    75c0:	f3 0f 1e fa          	endbr64 
}
    75c4:	c3                   	ret    
    75c5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    75cc:	00 00 00 00 

00000000000075d0 <StriCmp>:
StriCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    )
// compare strings
{
    75d0:	f3 0f 1e fa          	endbr64 
    75d4:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    75d8:	48 8b 05 41 58 01 00 	mov    0x15841(%rip),%rax        # 1ce20 <UnicodeInterface>
{
    75df:	48 89 fa             	mov    %rdi,%rdx
    75e2:	49 89 f0             	mov    %rsi,%r8
    	return UnicodeInterface->StriColl(UnicodeInterface, (CHAR16 *)s1, (CHAR16 *)s2);
    75e5:	48 89 c1             	mov    %rax,%rcx
    else
	return uefi_call_wrapper(UnicodeInterface->StriColl, 3, UnicodeInterface, (CHAR16 *)s1, (CHAR16 *)s2);
    75e8:	ff 10                	call   *(%rax)
}
    75ea:	48 83 c4 28          	add    $0x28,%rsp
    75ee:	c3                   	ret    
    75ef:	90                   	nop

00000000000075f0 <StrLwr>:
VOID
StrLwr (
    IN CHAR16   *Str
    )
// lwoer case string
{
    75f0:	f3 0f 1e fa          	endbr64 
    75f4:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    75f8:	48 8b 05 21 58 01 00 	mov    0x15821(%rip),%rax        # 1ce20 <UnicodeInterface>
{
    75ff:	48 89 fa             	mov    %rdi,%rdx
    	UnicodeInterface->StrLwr(UnicodeInterface, Str);
    7602:	48 89 c1             	mov    %rax,%rcx
    else uefi_call_wrapper(UnicodeInterface->StrLwr, 2, UnicodeInterface, Str);
    7605:	ff 50 10             	call   *0x10(%rax)
}
    7608:	48 83 c4 28          	add    $0x28,%rsp
    760c:	c3                   	ret    
    760d:	0f 1f 00             	nopl   (%rax)

0000000000007610 <StrUpr>:
VOID
StrUpr (
    IN CHAR16   *Str
    )
// upper case string
{
    7610:	f3 0f 1e fa          	endbr64 
    7614:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    7618:	48 8b 05 01 58 01 00 	mov    0x15801(%rip),%rax        # 1ce20 <UnicodeInterface>
{
    761f:	48 89 fa             	mov    %rdi,%rdx
        UnicodeInterface->StrUpr(UnicodeInterface, Str);
    7622:	48 89 c1             	mov    %rax,%rcx
    else uefi_call_wrapper(UnicodeInterface->StrUpr, 2, UnicodeInterface, Str);
    7625:	ff 50 18             	call   *0x18(%rax)
}
    7628:	48 83 c4 28          	add    $0x28,%rsp
    762c:	c3                   	ret    
    762d:	0f 1f 00             	nopl   (%rax)

0000000000007630 <StrCpy>:
StrCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
// copy strings
{
    7630:	f3 0f 1e fa          	endbr64 
    RtStrCpy (Dest, Src);
    7634:	e9 17 06 00 00       	jmp    7c50 <RtStrCpy>
    7639:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007640 <StrnCpy>:
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
// copy strings
{
    7640:	f3 0f 1e fa          	endbr64 
    RtStrnCpy (Dest, Src, Len);
    7644:	e9 37 06 00 00       	jmp    7c80 <RtStrnCpy>
    7649:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007650 <StpCpy>:
StpCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
// copy strings
{
    7650:	f3 0f 1e fa          	endbr64 
    return RtStpCpy (Dest, Src);
    7654:	e9 97 06 00 00       	jmp    7cf0 <RtStpCpy>
    7659:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007660 <StpnCpy>:
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
// copy strings
{
    7660:	f3 0f 1e fa          	endbr64 
    return RtStpnCpy (Dest, Src, Len);
    7664:	e9 b7 06 00 00       	jmp    7d20 <RtStpnCpy>
    7669:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007670 <StrCat>:
VOID
StrCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
{
    7670:	f3 0f 1e fa          	endbr64 
    RtStrCat(Dest, Src);
    7674:	e9 37 07 00 00       	jmp    7db0 <RtStrCat>
    7679:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007680 <StrnCat>:
StrnCat (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
{
    7680:	f3 0f 1e fa          	endbr64 
    RtStrnCat(Dest, Src, Len);
    7684:	e9 77 07 00 00       	jmp    7e00 <RtStrnCat>
    7689:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007690 <StrnLen>:
StrnLen (
    IN CONST CHAR16   *s1,
    IN UINTN           Len
    )
// string length
{
    7690:	f3 0f 1e fa          	endbr64 
    return RtStrnLen(s1, Len);
    7694:	e9 27 08 00 00       	jmp    7ec0 <RtStrnLen>
    7699:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000076a0 <StrLen>:
UINTN
StrLen (
    IN CONST CHAR16   *s1
    )
// string length
{
    76a0:	f3 0f 1e fa          	endbr64 
    return RtStrLen(s1);
    76a4:	e9 e7 07 00 00       	jmp    7e90 <RtStrLen>
    76a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000076b0 <StrSize>:
UINTN
StrSize (
    IN CONST CHAR16   *s1
    )
// string size
{
    76b0:	f3 0f 1e fa          	endbr64 
    return RtStrSize(s1);
    76b4:	e9 47 08 00 00       	jmp    7f00 <RtStrSize>
    76b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000076c0 <StrDuplicate>:
CHAR16 *
StrDuplicate (
    IN CONST CHAR16   *Src
    )
// duplicate a string
{
    76c0:	f3 0f 1e fa          	endbr64 
    76c4:	41 55                	push   %r13
    76c6:	49 89 fd             	mov    %rdi,%r13
    76c9:	41 54                	push   %r12
    76cb:	53                   	push   %rbx
    76cc:	48 83 ec 20          	sub    $0x20,%rsp
    return RtStrSize(s1);
    76d0:	e8 2b 08 00 00       	call   7f00 <RtStrSize>
    CHAR16      *Dest;
    UINTN       Size;

    Size = StrSize(Src);
    Dest = AllocatePool (Size);
    76d5:	48 89 c7             	mov    %rax,%rdi
    return RtStrSize(s1);
    76d8:	48 89 c3             	mov    %rax,%rbx
    Dest = AllocatePool (Size);
    76db:	e8 60 d1 ff ff       	call   4840 <AllocatePool>
    76e0:	49 89 c4             	mov    %rax,%r12
    if (Dest) {
    76e3:	48 85 c0             	test   %rax,%rax
    76e6:	74 0e                	je     76f6 <StrDuplicate+0x36>
        CopyMem (Dest, (void *)Src, Size);
    76e8:	49 89 d8             	mov    %rbx,%r8
    76eb:	4c 89 ea             	mov    %r13,%rdx
    76ee:	48 89 c1             	mov    %rax,%rcx
    76f1:	e8 4a d3 ff ff       	call   4a40 <CopyMem>
    }
    return Dest;
}
    76f6:	48 83 c4 20          	add    $0x20,%rsp
    76fa:	4c 89 e0             	mov    %r12,%rax
    76fd:	5b                   	pop    %rbx
    76fe:	41 5c                	pop    %r12
    7700:	41 5d                	pop    %r13
    7702:	c3                   	ret    
    7703:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    770a:	00 00 00 00 
    770e:	66 90                	xchg   %ax,%ax

0000000000007710 <strlena>:
UINTN
strlena (
    IN CONST CHAR8    *s1
    )
// string length
{
    7710:	f3 0f 1e fa          	endbr64 
    UINTN        len;

    for (len=0; *s1; s1+=1, len+=1) ;
    7714:	31 c0                	xor    %eax,%eax
    7716:	80 3f 00             	cmpb   $0x0,(%rdi)
    7719:	74 15                	je     7730 <strlena+0x20>
    771b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    7720:	48 83 c0 01          	add    $0x1,%rax
    7724:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
    7728:	75 f6                	jne    7720 <strlena+0x10>
    772a:	c3                   	ret    
    772b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    return len;
}
    7730:	c3                   	ret    
    7731:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7738:	00 00 00 00 
    773c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007740 <strcmpa>:
strcmpa (
    IN CONST CHAR8    *s1,
    IN CONST CHAR8    *s2
    )
// compare strings
{
    7740:	f3 0f 1e fa          	endbr64 
    while (*s1) {
    7744:	0f b6 07             	movzbl (%rdi),%eax
    7747:	84 c0                	test   %al,%al
    7749:	75 18                	jne    7763 <strcmpa+0x23>
    774b:	eb 2e                	jmp    777b <strcmpa+0x3b>
    774d:	0f 1f 00             	nopl   (%rax)
    7750:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
    7754:	48 83 c7 01          	add    $0x1,%rdi
        s2 += 1;
    7758:	48 8d 56 01          	lea    0x1(%rsi),%rdx
    while (*s1) {
    775c:	84 c0                	test   %al,%al
    775e:	74 10                	je     7770 <strcmpa+0x30>
        s2 += 1;
    7760:	48 89 d6             	mov    %rdx,%rsi
        if (*s1 != *s2) {
    7763:	0f b6 16             	movzbl (%rsi),%edx
    7766:	38 c2                	cmp    %al,%dl
    7768:	74 e6                	je     7750 <strcmpa+0x10>
    }

    return *s1 - *s2;
    776a:	29 d0                	sub    %edx,%eax
    776c:	48 98                	cltq   
}
    776e:	c3                   	ret    
    776f:	90                   	nop
    return *s1 - *s2;
    7770:	0f b6 56 01          	movzbl 0x1(%rsi),%edx
    7774:	31 c0                	xor    %eax,%eax
    7776:	29 d0                	sub    %edx,%eax
    7778:	48 98                	cltq   
}
    777a:	c3                   	ret    
    return *s1 - *s2;
    777b:	0f b6 16             	movzbl (%rsi),%edx
    777e:	31 c0                	xor    %eax,%eax
    7780:	eb e8                	jmp    776a <strcmpa+0x2a>
    7782:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7789:	00 00 00 00 
    778d:	0f 1f 00             	nopl   (%rax)

0000000000007790 <strncmpa>:
    IN CONST CHAR8    *s1,
    IN CONST CHAR8    *s2,
    IN UINTN    len
    )
// compare strings
{
    7790:	f3 0f 1e fa          	endbr64 
    while (*s1  &&  len) {
    7794:	0f b6 07             	movzbl (%rdi),%eax
    7797:	84 c0                	test   %al,%al
    7799:	75 20                	jne    77bb <strncmpa+0x2b>
    779b:	eb 2b                	jmp    77c8 <strncmpa+0x38>
    779d:	0f 1f 00             	nopl   (%rax)
        if (*s1 != *s2) {
    77a0:	0f b6 0e             	movzbl (%rsi),%ecx
    77a3:	38 c1                	cmp    %al,%cl
    77a5:	75 2b                	jne    77d2 <strncmpa+0x42>
    while (*s1  &&  len) {
    77a7:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
            break;
        }

        s1  += 1;
    77ab:	48 83 c7 01          	add    $0x1,%rdi
        s2  += 1;
    77af:	48 83 c6 01          	add    $0x1,%rsi
        len -= 1;
    77b3:	48 83 ea 01          	sub    $0x1,%rdx
    while (*s1  &&  len) {
    77b7:	84 c0                	test   %al,%al
    77b9:	74 0d                	je     77c8 <strncmpa+0x38>
    77bb:	48 85 d2             	test   %rdx,%rdx
    77be:	75 e0                	jne    77a0 <strncmpa+0x10>
    }

    return len ? *s1 - *s2 : 0;
    77c0:	31 c0                	xor    %eax,%eax
}
    77c2:	c3                   	ret    
    77c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    return len ? *s1 - *s2 : 0;
    77c8:	31 c0                	xor    %eax,%eax
    77ca:	48 85 d2             	test   %rdx,%rdx
    77cd:	74 f3                	je     77c2 <strncmpa+0x32>
    77cf:	0f b6 0e             	movzbl (%rsi),%ecx
    77d2:	29 c8                	sub    %ecx,%eax
    77d4:	48 98                	cltq   
    77d6:	c3                   	ret    
    77d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    77de:	00 00 

00000000000077e0 <xtoi>:
UINTN
xtoi (
    CONST CHAR16  *str
    )
// convert hex string to uint
{
    77e0:	f3 0f 1e fa          	endbr64 
    77e4:	0f 1f 40 00          	nopl   0x0(%rax)
    UINTN       u;
    CHAR16      c;

    // skip preceeding white space
    while (*str == ' ') {
    77e8:	0f b7 17             	movzwl (%rdi),%edx
        str += 1;
    77eb:	48 83 c7 02          	add    $0x2,%rdi
    while (*str == ' ') {
    77ef:	66 83 fa 20          	cmp    $0x20,%dx
    77f3:	74 f3                	je     77e8 <xtoi+0x8>
    }

    // convert hex digits
    u = 0;
    77f5:	31 c0                	xor    %eax,%eax
    while ((c = *(str++))) {
    77f7:	66 85 d2             	test   %dx,%dx
    77fa:	75 26                	jne    7822 <xtoi+0x42>
    77fc:	eb 5a                	jmp    7858 <xtoi+0x78>
    77fe:	66 90                	xchg   %ax,%ax
        if (c >= 'a'  &&  c <= 'f') {
            c -= 'a' - 'A';
    7800:	83 ea 20             	sub    $0x20,%edx
        }

        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F')) {
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    7803:	48 c1 e0 04          	shl    $0x4,%rax
    7807:	0f b7 ca             	movzwl %dx,%ecx
    780a:	ba 37 00 00 00       	mov    $0x37,%edx
    while ((c = *(str++))) {
    780f:	48 83 c7 02          	add    $0x2,%rdi
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    7813:	48 29 d1             	sub    %rdx,%rcx
    while ((c = *(str++))) {
    7816:	0f b7 57 fe          	movzwl -0x2(%rdi),%edx
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    781a:	48 09 c8             	or     %rcx,%rax
    while ((c = *(str++))) {
    781d:	66 85 d2             	test   %dx,%dx
    7820:	74 3e                	je     7860 <xtoi+0x80>
        if (c >= 'a'  &&  c <= 'f') {
    7822:	8d 4a 9f             	lea    -0x61(%rdx),%ecx
    7825:	66 83 f9 05          	cmp    $0x5,%cx
    7829:	76 d5                	jbe    7800 <xtoi+0x20>
        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F')) {
    782b:	8d 4a d0             	lea    -0x30(%rdx),%ecx
    782e:	66 83 f9 09          	cmp    $0x9,%cx
    7832:	76 09                	jbe    783d <xtoi+0x5d>
    7834:	8d 4a bf             	lea    -0x41(%rdx),%ecx
    7837:	66 83 f9 05          	cmp    $0x5,%cx
    783b:	77 1b                	ja     7858 <xtoi+0x78>
            u = (u << 4)  |  ((UINTN)c - (c >= 'A' ? 'A'-10 : '0'));
    783d:	48 c1 e0 04          	shl    $0x4,%rax
    7841:	66 83 fa 41          	cmp    $0x41,%dx
    7845:	0f b7 ca             	movzwl %dx,%ecx
    7848:	48 19 d2             	sbb    %rdx,%rdx
    784b:	48 83 e2 f9          	and    $0xfffffffffffffff9,%rdx
    784f:	48 83 c2 37          	add    $0x37,%rdx
    7853:	eb ba                	jmp    780f <xtoi+0x2f>
    7855:	0f 1f 00             	nopl   (%rax)
            break;
        }
    }

    return u;
}
    7858:	c3                   	ret    
    7859:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    7860:	c3                   	ret    
    7861:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7868:	00 00 00 00 
    786c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007870 <Atoi>:
UINTN
Atoi (
    CONST CHAR16  *str
    )
// convert hex string to uint
{
    7870:	f3 0f 1e fa          	endbr64 
    7874:	0f 1f 40 00          	nopl   0x0(%rax)
    UINTN       u;
    CHAR16      c;

    // skip preceeding white space
    while (*str == ' ') {
    7878:	0f b7 07             	movzwl (%rdi),%eax
        str += 1;
    787b:	48 83 c7 02          	add    $0x2,%rdi
    while (*str == ' ') {
    787f:	66 83 f8 20          	cmp    $0x20,%ax
    7883:	74 f3                	je     7878 <Atoi+0x8>
    }

    // convert digits
    u = 0;
    7885:	45 31 c0             	xor    %r8d,%r8d
    while ((c = *(str++))) {
    7888:	66 85 c0             	test   %ax,%ax
    788b:	75 19                	jne    78a6 <Atoi+0x36>
    788d:	eb 20                	jmp    78af <Atoi+0x3f>
    788f:	90                   	nop
        if (c >= '0' && c <= '9') {
            u = (u * 10) + c - '0';
    7890:	4b 8d 14 80          	lea    (%r8,%r8,4),%rdx
    while ((c = *(str++))) {
    7894:	48 83 c7 02          	add    $0x2,%rdi
            u = (u * 10) + c - '0';
    7898:	4c 8d 44 50 d0       	lea    -0x30(%rax,%rdx,2),%r8
    while ((c = *(str++))) {
    789d:	0f b7 47 fe          	movzwl -0x2(%rdi),%eax
    78a1:	66 85 c0             	test   %ax,%ax
    78a4:	74 09                	je     78af <Atoi+0x3f>
        if (c >= '0' && c <= '9') {
    78a6:	8d 50 d0             	lea    -0x30(%rax),%edx
    78a9:	66 83 fa 09          	cmp    $0x9,%dx
    78ad:	76 e1                	jbe    7890 <Atoi+0x20>
            break;
        }
    }

    return u;
}
    78af:	4c 89 c0             	mov    %r8,%rax
    78b2:	c3                   	ret    
    78b3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    78ba:	00 00 00 00 
    78be:	66 90                	xchg   %ax,%ax

00000000000078c0 <MetaMatch>:
BOOLEAN
MetaMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    )
{
    78c0:	f3 0f 1e fa          	endbr64 
    78c4:	55                   	push   %rbp
    78c5:	48 89 fd             	mov    %rdi,%rbp
    78c8:	53                   	push   %rbx
    78c9:	48 89 f3             	mov    %rsi,%rbx
    78cc:	48 83 ec 08          	sub    $0x8,%rsp
    78d0:	48 8d 75 02          	lea    0x2(%rbp),%rsi
    CHAR16  c, p, l;

    for (; ;) {
        p = *Pattern;
    78d4:	0f b7 03             	movzwl (%rbx),%eax
            // End of pattern.  If end of string, TRUE match
            return *String ? FALSE : TRUE;

        case '*':
            // Match zero or more chars
            while (*String) {
    78d7:	0f b7 4e fe          	movzwl -0x2(%rsi),%ecx
    78db:	48 8d 6e fe          	lea    -0x2(%rsi),%rbp
        Pattern += 1;
    78df:	48 83 c3 02          	add    $0x2,%rbx
        switch (p) {
    78e3:	66 83 f8 3f          	cmp    $0x3f,%ax
    78e7:	0f 84 eb 00 00 00    	je     79d8 <MetaMatch+0x118>
    78ed:	77 51                	ja     7940 <MetaMatch+0x80>
    78ef:	66 85 c0             	test   %ax,%ax
    78f2:	0f 84 08 01 00 00    	je     7a00 <MetaMatch+0x140>
    78f8:	66 83 f8 2a          	cmp    $0x2a,%ax
    78fc:	0f 85 ee 00 00 00    	jne    79f0 <MetaMatch+0x130>
            while (*String) {
    7902:	66 85 c9             	test   %cx,%cx
    7905:	74 c9                	je     78d0 <MetaMatch+0x10>
                if (MetaMatch (String, Pattern)) {
    7907:	48 89 de             	mov    %rbx,%rsi
    790a:	48 89 ef             	mov    %rbp,%rdi
    790d:	e8 ae ff ff ff       	call   78c0 <MetaMatch>
    7912:	84 c0                	test   %al,%al
    7914:	75 1a                	jne    7930 <MetaMatch+0x70>
                    return TRUE;
                }
                String += 1;
    7916:	48 83 c5 02          	add    $0x2,%rbp
            while (*String) {
    791a:	66 83 7d 00 00       	cmpw   $0x0,0x0(%rbp)
    791f:	74 af                	je     78d0 <MetaMatch+0x10>
                if (MetaMatch (String, Pattern)) {
    7921:	48 89 de             	mov    %rbx,%rsi
    7924:	48 89 ef             	mov    %rbp,%rdi
    7927:	e8 94 ff ff ff       	call   78c0 <MetaMatch>
    792c:	84 c0                	test   %al,%al
    792e:	74 e6                	je     7916 <MetaMatch+0x56>

            String += 1;
            break;
        }
    }
}
    7930:	48 83 c4 08          	add    $0x8,%rsp
    7934:	5b                   	pop    %rbx
    7935:	5d                   	pop    %rbp
    7936:	c3                   	ret    
    7937:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    793e:	00 00 
        switch (p) {
    7940:	66 83 f8 5b          	cmp    $0x5b,%ax
    7944:	0f 85 a6 00 00 00    	jne    79f0 <MetaMatch+0x130>
            if (!c) {
    794a:	66 85 c9             	test   %cx,%cx
    794d:	0f 84 8a 00 00 00    	je     79dd <MetaMatch+0x11d>
            l = 0;
    7953:	31 d2                	xor    %edx,%edx
    7955:	eb 10                	jmp    7967 <MetaMatch+0xa7>
    7957:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    795e:	00 00 
    7960:	89 c2                	mov    %eax,%edx
                if (c == p) {                       // if char matches
    7962:	66 39 c8             	cmp    %cx,%ax
    7965:	74 39                	je     79a0 <MetaMatch+0xe0>
            while ((p = *Pattern++)) {
    7967:	0f b7 03             	movzwl (%rbx),%eax
    796a:	48 83 c3 02          	add    $0x2,%rbx
    796e:	66 85 c0             	test   %ax,%ax
    7971:	74 3d                	je     79b0 <MetaMatch+0xf0>
                if (p == ']') {
    7973:	66 83 f8 5d          	cmp    $0x5d,%ax
    7977:	74 64                	je     79dd <MetaMatch+0x11d>
                if (p == '-') {                     // if range of chars,
    7979:	66 83 f8 2d          	cmp    $0x2d,%ax
    797d:	75 e1                	jne    7960 <MetaMatch+0xa0>
                    p = *Pattern;                   // get high range
    797f:	0f b7 03             	movzwl (%rbx),%eax
                    if (p == 0 || p == ']') {
    7982:	66 85 c0             	test   %ax,%ax
    7985:	74 56                	je     79dd <MetaMatch+0x11d>
    7987:	66 83 f8 5d          	cmp    $0x5d,%ax
    798b:	74 50                	je     79dd <MetaMatch+0x11d>
                    if (c >= l && c <= p) {         // if in range,
    798d:	66 39 ca             	cmp    %cx,%dx
    7990:	77 ce                	ja     7960 <MetaMatch+0xa0>
    7992:	66 39 c8             	cmp    %cx,%ax
    7995:	73 2f                	jae    79c6 <MetaMatch+0x106>
    7997:	89 c2                	mov    %eax,%edx
                if (c == p) {                       // if char matches
    7999:	66 39 c8             	cmp    %cx,%ax
    799c:	75 c9                	jne    7967 <MetaMatch+0xa7>
    799e:	66 90                	xchg   %ax,%ax
            while (p && p != ']') {
    79a0:	66 83 f8 5d          	cmp    $0x5d,%ax
    79a4:	75 20                	jne    79c6 <MetaMatch+0x106>
    79a6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    79ad:	00 00 00 
    79b0:	48 83 c6 02          	add    $0x2,%rsi
    79b4:	e9 1b ff ff ff       	jmp    78d4 <MetaMatch+0x14>
    79b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    79c0:	66 83 f8 5d          	cmp    $0x5d,%ax
    79c4:	74 ea                	je     79b0 <MetaMatch+0xf0>
                p = *Pattern;
    79c6:	0f b7 03             	movzwl (%rbx),%eax
                Pattern += 1;
    79c9:	48 83 c3 02          	add    $0x2,%rbx
            while (p && p != ']') {
    79cd:	66 85 c0             	test   %ax,%ax
    79d0:	75 ee                	jne    79c0 <MetaMatch+0x100>
    79d2:	eb dc                	jmp    79b0 <MetaMatch+0xf0>
    79d4:	0f 1f 40 00          	nopl   0x0(%rax)
            if (!*String) {
    79d8:	66 85 c9             	test   %cx,%cx
    79db:	75 d3                	jne    79b0 <MetaMatch+0xf0>
}
    79dd:	48 83 c4 08          	add    $0x8,%rsp
                return FALSE;
    79e1:	31 c0                	xor    %eax,%eax
}
    79e3:	5b                   	pop    %rbx
    79e4:	5d                   	pop    %rbp
    79e5:	c3                   	ret    
    79e6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    79ed:	00 00 00 
            if (c != p) {
    79f0:	66 39 c8             	cmp    %cx,%ax
    79f3:	75 e8                	jne    79dd <MetaMatch+0x11d>
    79f5:	48 83 c6 02          	add    $0x2,%rsi
    79f9:	e9 d6 fe ff ff       	jmp    78d4 <MetaMatch+0x14>
    79fe:	66 90                	xchg   %ax,%ax
            return *String ? FALSE : TRUE;
    7a00:	66 85 c9             	test   %cx,%cx
    7a03:	0f 94 c0             	sete   %al
}
    7a06:	48 83 c4 08          	add    $0x8,%rsp
    7a0a:	5b                   	pop    %rbx
    7a0b:	5d                   	pop    %rbp
    7a0c:	c3                   	ret    
    7a0d:	0f 1f 00             	nopl   (%rax)

0000000000007a10 <LibStubMetaiMatch>:
LibStubMetaiMatch (
    IN EFI_UNICODE_COLLATION_INTERFACE  *This EFI_UNUSED,
    IN CHAR16                           *String,
    IN CHAR16                           *Pattern
    )
{
    7a10:	f3 0f 1e fa          	endbr64 
    7a14:	57                   	push   %rdi
    7a15:	48 89 d7             	mov    %rdx,%rdi
    7a18:	56                   	push   %rsi
    7a19:	4c 89 c6             	mov    %r8,%rsi
    7a1c:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    7a23:	0f 29 34 24          	movaps %xmm6,(%rsp)
    7a27:	0f 29 7c 24 10       	movaps %xmm7,0x10(%rsp)
    7a2c:	44 0f 29 44 24 20    	movaps %xmm8,0x20(%rsp)
    7a32:	44 0f 29 4c 24 30    	movaps %xmm9,0x30(%rsp)
    7a38:	44 0f 29 54 24 40    	movaps %xmm10,0x40(%rsp)
    7a3e:	44 0f 29 5c 24 50    	movaps %xmm11,0x50(%rsp)
    7a44:	44 0f 29 64 24 60    	movaps %xmm12,0x60(%rsp)
    7a4a:	44 0f 29 6c 24 70    	movaps %xmm13,0x70(%rsp)
    7a50:	44 0f 29 b4 24 80 00 	movaps %xmm14,0x80(%rsp)
    7a57:	00 00 
    7a59:	44 0f 29 bc 24 90 00 	movaps %xmm15,0x90(%rsp)
    7a60:	00 00 
    return MetaMatch (String, Pattern);
    7a62:	e8 59 fe ff ff       	call   78c0 <MetaMatch>
}
    7a67:	0f 28 34 24          	movaps (%rsp),%xmm6
    7a6b:	0f 28 7c 24 10       	movaps 0x10(%rsp),%xmm7
    7a70:	44 0f 28 44 24 20    	movaps 0x20(%rsp),%xmm8
    7a76:	44 0f 28 4c 24 30    	movaps 0x30(%rsp),%xmm9
    7a7c:	44 0f 28 54 24 40    	movaps 0x40(%rsp),%xmm10
    7a82:	44 0f 28 5c 24 50    	movaps 0x50(%rsp),%xmm11
    7a88:	44 0f 28 64 24 60    	movaps 0x60(%rsp),%xmm12
    7a8e:	44 0f 28 6c 24 70    	movaps 0x70(%rsp),%xmm13
    7a94:	44 0f 28 b4 24 80 00 	movaps 0x80(%rsp),%xmm14
    7a9b:	00 00 
    7a9d:	44 0f 28 bc 24 90 00 	movaps 0x90(%rsp),%xmm15
    7aa4:	00 00 
    7aa6:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    7aad:	5e                   	pop    %rsi
    7aae:	5f                   	pop    %rdi
    7aaf:	c3                   	ret    

0000000000007ab0 <MetaiMatch>:
BOOLEAN
MetaiMatch (
    IN CHAR16   *String,
    IN CHAR16   *Pattern
    )
{
    7ab0:	f3 0f 1e fa          	endbr64 
    7ab4:	48 83 ec 28          	sub    $0x28,%rsp
    if (UnicodeInterface == &LibStubUnicodeInterface)
    7ab8:	48 8b 05 61 53 01 00 	mov    0x15361(%rip),%rax        # 1ce20 <UnicodeInterface>
{
    7abf:	48 89 fa             	mov    %rdi,%rdx
    7ac2:	49 89 f0             	mov    %rsi,%r8
    	return UnicodeInterface->MetaiMatch(UnicodeInterface, String, Pattern);
    7ac5:	48 89 c1             	mov    %rax,%rcx
    else return uefi_call_wrapper(UnicodeInterface->MetaiMatch, 3, UnicodeInterface, String, Pattern);
    7ac8:	ff 50 08             	call   *0x8(%rax)
}
    7acb:	48 83 c4 28          	add    $0x28,%rsp
    7acf:	c3                   	ret    

0000000000007ad0 <RtZeroMem>:
RUNTIMEFUNCTION
RtZeroMem (
    IN VOID     *Buffer,
    IN UINTN     Size
    )
{
    7ad0:	f3 0f 1e fa          	endbr64 
    INT8        *pt;

    pt = Buffer;
    while (Size--) {
    7ad4:	48 85 f6             	test   %rsi,%rsi
    7ad7:	74 14                	je     7aed <RtZeroMem+0x1d>
    7ad9:	48 01 fe             	add    %rdi,%rsi
    7adc:	0f 1f 40 00          	nopl   0x0(%rax)
        *(pt++) = 0;
    7ae0:	48 83 c7 01          	add    $0x1,%rdi
    7ae4:	c6 47 ff 00          	movb   $0x0,-0x1(%rdi)
    while (Size--) {
    7ae8:	48 39 f7             	cmp    %rsi,%rdi
    7aeb:	75 f3                	jne    7ae0 <RtZeroMem+0x10>
    }
}
    7aed:	c3                   	ret    
    7aee:	66 90                	xchg   %ax,%ax

0000000000007af0 <RtSetMem>:
RtSetMem (
    IN VOID     *Buffer,
    IN UINTN    Size,
    IN UINT8    Value
    )
{
    7af0:	f3 0f 1e fa          	endbr64 
    INT8        *pt;

    pt = Buffer;
    while (Size--) {
    7af4:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
    7af8:	48 85 f6             	test   %rsi,%rsi
    7afb:	74 0f                	je     7b0c <RtSetMem+0x1c>
    7afd:	0f 1f 00             	nopl   (%rax)
        *(pt++) = Value;
    7b00:	48 83 c7 01          	add    $0x1,%rdi
    7b04:	88 57 ff             	mov    %dl,-0x1(%rdi)
    while (Size--) {
    7b07:	48 39 c7             	cmp    %rax,%rdi
    7b0a:	75 f4                	jne    7b00 <RtSetMem+0x10>
    }
}
    7b0c:	c3                   	ret    
    7b0d:	0f 1f 00             	nopl   (%rax)

0000000000007b10 <RtCopyMem>:
RtCopyMem (
    IN VOID        *Dest,
    IN CONST VOID  *Src,
    IN UINTN       len
    )
{
    7b10:	f3 0f 1e fa          	endbr64 
    CHAR8 *d = (CHAR8*)Dest;
    CHAR8 *s = (CHAR8*)Src;

    if (d == NULL || s == NULL || s == d)
    7b14:	48 85 ff             	test   %rdi,%rdi
    7b17:	0f 94 c0             	sete   %al
    7b1a:	48 39 f7             	cmp    %rsi,%rdi
    7b1d:	0f 94 c1             	sete   %cl
    7b20:	08 c8                	or     %cl,%al
    7b22:	75 2c                	jne    7b50 <RtCopyMem+0x40>
    7b24:	48 85 f6             	test   %rsi,%rsi
    7b27:	74 27                	je     7b50 <RtCopyMem+0x40>
    // we don't end up overwriting source data that we need for the copy.
    if ((d > s) && (d < s + len)) {
        for (d += len, s += len; len--; )
            *--d = *--s;
    } else {
        while (len--)
    7b29:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    if ((d > s) && (d < s + len)) {
    7b2d:	48 39 f7             	cmp    %rsi,%rdi
    7b30:	77 26                	ja     7b58 <RtCopyMem+0x48>
        while (len--)
    7b32:	31 c0                	xor    %eax,%eax
    7b34:	48 85 d2             	test   %rdx,%rdx
    7b37:	74 47                	je     7b80 <RtCopyMem+0x70>
    7b39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            *d++ = *s++;
    7b40:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
    7b44:	88 0c 07             	mov    %cl,(%rdi,%rax,1)
        while (len--)
    7b47:	48 83 c0 01          	add    $0x1,%rax
    7b4b:	48 39 c2             	cmp    %rax,%rdx
    7b4e:	75 f0                	jne    7b40 <RtCopyMem+0x30>
    }
}
    7b50:	c3                   	ret    
    7b51:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if ((d > s) && (d < s + len)) {
    7b58:	48 8d 0c 16          	lea    (%rsi,%rdx,1),%rcx
    7b5c:	48 39 cf             	cmp    %rcx,%rdi
    7b5f:	73 d1                	jae    7b32 <RtCopyMem+0x22>
        for (d += len, s += len; len--; )
    7b61:	48 85 d2             	test   %rdx,%rdx
    7b64:	74 ea                	je     7b50 <RtCopyMem+0x40>
    7b66:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7b6d:	00 00 00 
            *--d = *--s;
    7b70:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
    7b74:	88 14 07             	mov    %dl,(%rdi,%rax,1)
        for (d += len, s += len; len--; )
    7b77:	48 83 e8 01          	sub    $0x1,%rax
    7b7b:	73 f3                	jae    7b70 <RtCopyMem+0x60>
    7b7d:	c3                   	ret    
    7b7e:	66 90                	xchg   %ax,%ax
    7b80:	c3                   	ret    
    7b81:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7b88:	00 00 00 00 
    7b8c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007b90 <RtCompareMem>:
RtCompareMem (
    IN CONST VOID     *Dest,
    IN CONST VOID     *Src,
    IN UINTN    len
    )
{
    7b90:	f3 0f 1e fa          	endbr64 
    CONST CHAR8    *d = Dest, *s = Src;
    while (len--) {
    7b94:	31 c0                	xor    %eax,%eax
    7b96:	48 85 d2             	test   %rdx,%rdx
    7b99:	75 0e                	jne    7ba9 <RtCompareMem+0x19>
    7b9b:	eb 26                	jmp    7bc3 <RtCompareMem+0x33>
    7b9d:	0f 1f 00             	nopl   (%rax)
    7ba0:	48 83 c0 01          	add    $0x1,%rax
    7ba4:	48 39 c2             	cmp    %rax,%rdx
    7ba7:	74 17                	je     7bc0 <RtCompareMem+0x30>
        if (*d != *s) {
    7ba9:	0f b6 0c 07          	movzbl (%rdi,%rax,1),%ecx
    7bad:	44 0f b6 04 06       	movzbl (%rsi,%rax,1),%r8d
    7bb2:	44 38 c1             	cmp    %r8b,%cl
    7bb5:	74 e9                	je     7ba0 <RtCompareMem+0x10>
            return *d - *s;
    7bb7:	0f b6 c1             	movzbl %cl,%eax
    7bba:	44 29 c0             	sub    %r8d,%eax
    7bbd:	48 98                	cltq   
    7bbf:	c3                   	ret    

        d += 1;
        s += 1;
    }

    return 0;
    7bc0:	31 c0                	xor    %eax,%eax
    7bc2:	c3                   	ret    
}
    7bc3:	c3                   	ret    
    7bc4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7bcb:	00 00 00 00 
    7bcf:	90                   	nop

0000000000007bd0 <RtCompareGuid>:

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    7bd0:	f3 0f 1e fa          	endbr64 
    //

    g1 = (INT32 *) Guid1;
    g2 = (INT32 *) Guid2;

    r  = g1[0] - g2[0];
    7bd4:	8b 17                	mov    (%rdi),%edx
    r |= g1[1] - g2[1];
    7bd6:	8b 47 04             	mov    0x4(%rdi),%eax
    r  = g1[0] - g2[0];
    7bd9:	2b 16                	sub    (%rsi),%edx
    r |= g1[1] - g2[1];
    7bdb:	2b 46 04             	sub    0x4(%rsi),%eax
    7bde:	09 d0                	or     %edx,%eax
    r |= g1[2] - g2[2];
    7be0:	8b 57 08             	mov    0x8(%rdi),%edx
    7be3:	2b 56 08             	sub    0x8(%rsi),%edx
    7be6:	09 c2                	or     %eax,%edx
    r |= g1[3] - g2[3];
    7be8:	8b 47 0c             	mov    0xc(%rdi),%eax
    7beb:	2b 46 0c             	sub    0xc(%rsi),%eax
    7bee:	09 d0                	or     %edx,%eax

    return r;
    7bf0:	48 98                	cltq   
}
    7bf2:	c3                   	ret    
    7bf3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7bfa:	00 00 00 
    7bfd:	0f 1f 00             	nopl   (%rax)

0000000000007c00 <RtStrCmp>:
RtStrCmp (
    IN CONST CHAR16   *s1,
    IN CONST CHAR16   *s2
    )
// compare strings
{
    7c00:	f3 0f 1e fa          	endbr64 
    while (*s1) {
    7c04:	0f b7 07             	movzwl (%rdi),%eax
    7c07:	66 85 c0             	test   %ax,%ax
    7c0a:	75 18                	jne    7c24 <RtStrCmp+0x24>
    7c0c:	eb 35                	jmp    7c43 <RtStrCmp+0x43>
    7c0e:	66 90                	xchg   %ax,%ax
    7c10:	0f b7 47 02          	movzwl 0x2(%rdi),%eax
        if (*s1 != *s2) {
            break;
        }

        s1 += 1;
    7c14:	48 83 c7 02          	add    $0x2,%rdi
        s2 += 1;
    7c18:	48 8d 56 02          	lea    0x2(%rsi),%rdx
    while (*s1) {
    7c1c:	66 85 c0             	test   %ax,%ax
    7c1f:	74 17                	je     7c38 <RtStrCmp+0x38>
        s2 += 1;
    7c21:	48 89 d6             	mov    %rdx,%rsi
        if (*s1 != *s2) {
    7c24:	0f b7 16             	movzwl (%rsi),%edx
    7c27:	66 39 c2             	cmp    %ax,%dx
    7c2a:	74 e4                	je     7c10 <RtStrCmp+0x10>
    }

    return *s1 - *s2;
    7c2c:	29 d0                	sub    %edx,%eax
    7c2e:	48 98                	cltq   
}
    7c30:	c3                   	ret    
    7c31:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    return *s1 - *s2;
    7c38:	0f b7 56 02          	movzwl 0x2(%rsi),%edx
    7c3c:	31 c0                	xor    %eax,%eax
    7c3e:	29 d0                	sub    %edx,%eax
    7c40:	48 98                	cltq   
}
    7c42:	c3                   	ret    
    return *s1 - *s2;
    7c43:	0f b7 16             	movzwl (%rsi),%edx
    7c46:	31 c0                	xor    %eax,%eax
    7c48:	eb e2                	jmp    7c2c <RtStrCmp+0x2c>
    7c4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000007c50 <RtStrCpy>:
RtStrCpy (
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src
    )
// copy strings
{
    7c50:	f3 0f 1e fa          	endbr64 
    while (*Src) {
    7c54:	eb 15                	jmp    7c6b <RtStrCpy+0x1b>
    7c56:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7c5d:	00 00 00 
        *(Dest++) = *(Src++);
    7c60:	66 89 07             	mov    %ax,(%rdi)
    7c63:	48 83 c7 02          	add    $0x2,%rdi
    7c67:	48 83 c6 02          	add    $0x2,%rsi
    while (*Src) {
    7c6b:	0f b7 06             	movzwl (%rsi),%eax
    7c6e:	66 85 c0             	test   %ax,%ax
    7c71:	75 ed                	jne    7c60 <RtStrCpy+0x10>
    }
    *Dest = 0;
    7c73:	31 c0                	xor    %eax,%eax
    7c75:	66 89 07             	mov    %ax,(%rdi)
}
    7c78:	c3                   	ret    
    7c79:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007c80 <RtStrnCpy>:
    IN CHAR16   *Dest,
    IN CONST CHAR16   *Src,
    IN UINTN     Len
    )
// copy strings
{
    7c80:	f3 0f 1e fa          	endbr64 
    7c84:	41 55                	push   %r13
    7c86:	41 54                	push   %r12
    7c88:	49 89 fc             	mov    %rdi,%r12
    7c8b:	55                   	push   %rbp
    IN UINTN           Len
    )
// string length
{
    UINTN i;
    for (i = 0; *s1 && i < Len; i++)
    7c8c:	66 83 3e 00          	cmpw   $0x0,(%rsi)
{
    7c90:	48 89 f5             	mov    %rsi,%rbp
    for (i = 0; *s1 && i < Len; i++)
    7c93:	74 4b                	je     7ce0 <RtStrnCpy+0x60>
    7c95:	48 85 d2             	test   %rdx,%rdx
    7c98:	74 46                	je     7ce0 <RtStrnCpy+0x60>
    7c9a:	31 c0                	xor    %eax,%eax
    7c9c:	eb 07                	jmp    7ca5 <RtStrnCpy+0x25>
    7c9e:	66 90                	xchg   %ax,%ax
    7ca0:	48 39 c2             	cmp    %rax,%rdx
    7ca3:	76 0c                	jbe    7cb1 <RtStrnCpy+0x31>
    7ca5:	48 83 c0 01          	add    $0x1,%rax
    7ca9:	66 83 7c 45 00 00    	cmpw   $0x0,0x0(%rbp,%rax,2)
    7caf:	75 ef                	jne    7ca0 <RtStrnCpy+0x20>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    7cb1:	4c 8d 2c 00          	lea    (%rax,%rax,1),%r13
    if (Size != Len)
    7cb5:	48 39 c2             	cmp    %rax,%rdx
    7cb8:	74 12                	je     7ccc <RtStrnCpy+0x4c>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    7cba:	48 29 c2             	sub    %rax,%rdx
    7cbd:	4b 8d 3c 2c          	lea    (%r12,%r13,1),%rdi
    7cc1:	48 8d 34 12          	lea    (%rdx,%rdx,1),%rsi
    7cc5:	31 d2                	xor    %edx,%edx
    7cc7:	e8 24 fe ff ff       	call   7af0 <RtSetMem>
    RtCopyMem(Dest, Src, Size * sizeof(CHAR16));
    7ccc:	4c 89 ea             	mov    %r13,%rdx
    7ccf:	48 89 ee             	mov    %rbp,%rsi
    7cd2:	4c 89 e7             	mov    %r12,%rdi
}
    7cd5:	5d                   	pop    %rbp
    7cd6:	41 5c                	pop    %r12
    7cd8:	41 5d                	pop    %r13
    RtCopyMem(Dest, Src, Size * sizeof(CHAR16));
    7cda:	e9 31 fe ff ff       	jmp    7b10 <RtCopyMem>
    7cdf:	90                   	nop
    for (i = 0; *s1 && i < Len; i++)
    7ce0:	45 31 ed             	xor    %r13d,%r13d
    7ce3:	31 c0                	xor    %eax,%eax
    7ce5:	eb ce                	jmp    7cb5 <RtStrnCpy+0x35>
    7ce7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    7cee:	00 00 

0000000000007cf0 <RtStpCpy>:
{
    7cf0:	f3 0f 1e fa          	endbr64 
    while (*Src) {
    7cf4:	0f b7 16             	movzwl (%rsi),%edx
{
    7cf7:	48 89 f8             	mov    %rdi,%rax
    while (*Src) {
    7cfa:	66 85 d2             	test   %dx,%dx
    7cfd:	74 14                	je     7d13 <RtStpCpy+0x23>
    7cff:	90                   	nop
        *(Dest++) = *(Src++);
    7d00:	48 83 c6 02          	add    $0x2,%rsi
    7d04:	66 89 10             	mov    %dx,(%rax)
    7d07:	48 83 c0 02          	add    $0x2,%rax
    while (*Src) {
    7d0b:	0f b7 16             	movzwl (%rsi),%edx
    7d0e:	66 85 d2             	test   %dx,%dx
    7d11:	75 ed                	jne    7d00 <RtStpCpy+0x10>
    *Dest = 0;
    7d13:	31 d2                	xor    %edx,%edx
    7d15:	66 89 10             	mov    %dx,(%rax)
}
    7d18:	c3                   	ret    
    7d19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007d20 <RtStpnCpy>:
{
    7d20:	f3 0f 1e fa          	endbr64 
    7d24:	41 56                	push   %r14
    7d26:	41 55                	push   %r13
    7d28:	41 54                	push   %r12
    7d2a:	49 89 fc             	mov    %rdi,%r12
    7d2d:	55                   	push   %rbp
    7d2e:	48 89 f5             	mov    %rsi,%rbp
    7d31:	48 83 ec 08          	sub    $0x8,%rsp
    for (i = 0; *s1 && i < Len; i++)
    7d35:	66 83 3e 00          	cmpw   $0x0,(%rsi)
    7d39:	74 5d                	je     7d98 <RtStpnCpy+0x78>
    7d3b:	48 85 d2             	test   %rdx,%rdx
    7d3e:	74 58                	je     7d98 <RtStpnCpy+0x78>
    7d40:	31 c0                	xor    %eax,%eax
    7d42:	eb 09                	jmp    7d4d <RtStpnCpy+0x2d>
    7d44:	0f 1f 40 00          	nopl   0x0(%rax)
    7d48:	48 39 c2             	cmp    %rax,%rdx
    7d4b:	76 0c                	jbe    7d59 <RtStpnCpy+0x39>
    7d4d:	48 83 c0 01          	add    $0x1,%rax
    7d51:	66 83 7c 45 00 00    	cmpw   $0x0,0x0(%rbp,%rax,2)
    7d57:	75 ef                	jne    7d48 <RtStpnCpy+0x28>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    7d59:	4c 8d 2c 00          	lea    (%rax,%rax,1),%r13
    7d5d:	4f 8d 34 2c          	lea    (%r12,%r13,1),%r14
    if (Size != Len)
    7d61:	48 39 c2             	cmp    %rax,%rdx
    7d64:	74 11                	je     7d77 <RtStpnCpy+0x57>
        RtSetMem(Dest + Size, (Len - Size) * sizeof(CHAR16), '\0');
    7d66:	48 29 c2             	sub    %rax,%rdx
    7d69:	4c 89 f7             	mov    %r14,%rdi
    7d6c:	48 8d 34 12          	lea    (%rdx,%rdx,1),%rsi
    7d70:	31 d2                	xor    %edx,%edx
    7d72:	e8 79 fd ff ff       	call   7af0 <RtSetMem>
    RtCopyMem(Dest, Src, Size * sizeof(CHAR16));
    7d77:	4c 89 ea             	mov    %r13,%rdx
    7d7a:	48 89 ee             	mov    %rbp,%rsi
    7d7d:	4c 89 e7             	mov    %r12,%rdi
    7d80:	e8 8b fd ff ff       	call   7b10 <RtCopyMem>
}
    7d85:	48 83 c4 08          	add    $0x8,%rsp
    7d89:	4c 89 f0             	mov    %r14,%rax
    7d8c:	5d                   	pop    %rbp
    7d8d:	41 5c                	pop    %r12
    7d8f:	41 5d                	pop    %r13
    7d91:	41 5e                	pop    %r14
    7d93:	c3                   	ret    
    7d94:	0f 1f 40 00          	nopl   0x0(%rax)
    for (i = 0; *s1 && i < Len; i++)
    7d98:	4d 89 e6             	mov    %r12,%r14
    7d9b:	45 31 ed             	xor    %r13d,%r13d
    7d9e:	31 c0                	xor    %eax,%eax
    7da0:	eb bf                	jmp    7d61 <RtStpnCpy+0x41>
    7da2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7da9:	00 00 00 00 
    7dad:	0f 1f 00             	nopl   (%rax)

0000000000007db0 <RtStrCat>:
{
    7db0:	f3 0f 1e fa          	endbr64 
    for (len=0; *s1; s1+=1, len+=1) ;
    7db4:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    7db8:	74 31                	je     7deb <RtStrCat+0x3b>
    7dba:	31 c0                	xor    %eax,%eax
    7dbc:	0f 1f 40 00          	nopl   0x0(%rax)
    7dc0:	48 83 c0 01          	add    $0x1,%rax
    7dc4:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    7dc9:	75 f5                	jne    7dc0 <RtStrCat+0x10>
    RtStrCpy(Dest+RtStrLen(Dest), Src);
    7dcb:	48 8d 3c 47          	lea    (%rdi,%rax,2),%rdi
    while (*Src) {
    7dcf:	0f b7 06             	movzwl (%rsi),%eax
    7dd2:	66 85 c0             	test   %ax,%ax
    7dd5:	74 1c                	je     7df3 <RtStrCat+0x43>
    7dd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    7dde:	00 00 
        *(Dest++) = *(Src++);
    7de0:	66 89 07             	mov    %ax,(%rdi)
    7de3:	48 83 c7 02          	add    $0x2,%rdi
    7de7:	48 83 c6 02          	add    $0x2,%rsi
    while (*Src) {
    7deb:	0f b7 06             	movzwl (%rsi),%eax
    7dee:	66 85 c0             	test   %ax,%ax
    7df1:	75 ed                	jne    7de0 <RtStrCat+0x30>
    *Dest = 0;
    7df3:	31 c0                	xor    %eax,%eax
    7df5:	66 89 07             	mov    %ax,(%rdi)
}
    7df8:	c3                   	ret    
    7df9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000007e00 <RtStrnCat>:
{
    7e00:	f3 0f 1e fa          	endbr64 
    7e04:	53                   	push   %rbx
    for (len=0; *s1; s1+=1, len+=1) ;
    7e05:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    7e09:	74 55                	je     7e60 <RtStrnCat+0x60>
    7e0b:	31 c9                	xor    %ecx,%ecx
    7e0d:	0f 1f 00             	nopl   (%rax)
    7e10:	48 83 c1 01          	add    $0x1,%rcx
    7e14:	66 83 3c 4f 00       	cmpw   $0x0,(%rdi,%rcx,2)
    7e19:	75 f5                	jne    7e10 <RtStrnCat+0x10>
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    7e1b:	4c 8d 04 4f          	lea    (%rdi,%rcx,2),%r8
    for (i = 0; *s1 && i < Len; i++)
    7e1f:	66 83 3e 00          	cmpw   $0x0,(%rsi)
    7e23:	74 4b                	je     7e70 <RtStrnCat+0x70>
    7e25:	48 85 d2             	test   %rdx,%rdx
    7e28:	74 46                	je     7e70 <RtStrnCat+0x70>
    7e2a:	31 c0                	xor    %eax,%eax
    7e2c:	eb 07                	jmp    7e35 <RtStrnCat+0x35>
    7e2e:	66 90                	xchg   %ax,%ax
    7e30:	48 39 c2             	cmp    %rax,%rdx
    7e33:	76 0b                	jbe    7e40 <RtStrnCat+0x40>
    7e35:	48 83 c0 01          	add    $0x1,%rax
    7e39:	66 83 3c 46 00       	cmpw   $0x0,(%rsi,%rax,2)
    7e3e:	75 f0                	jne    7e30 <RtStrnCat+0x30>
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    7e40:	48 8d 14 00          	lea    (%rax,%rax,1),%rdx
    Dest[DestSize + Size] = '\0';
    7e44:	48 01 c8             	add    %rcx,%rax
    7e47:	48 8d 1c 47          	lea    (%rdi,%rax,2),%rbx
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    7e4b:	4c 89 c7             	mov    %r8,%rdi
    7e4e:	e8 bd fc ff ff       	call   7b10 <RtCopyMem>
    Dest[DestSize + Size] = '\0';
    7e53:	31 c0                	xor    %eax,%eax
    7e55:	66 89 03             	mov    %ax,(%rbx)
}
    7e58:	5b                   	pop    %rbx
    7e59:	c3                   	ret    
    7e5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for (len=0; *s1; s1+=1, len+=1) ;
    7e60:	49 89 f8             	mov    %rdi,%r8
    7e63:	31 c9                	xor    %ecx,%ecx
    7e65:	eb b8                	jmp    7e1f <RtStrnCat+0x1f>
    7e67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    7e6e:	00 00 
    for (i = 0; *s1 && i < Len; i++)
    7e70:	31 d2                	xor    %edx,%edx
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    7e72:	4c 89 c7             	mov    %r8,%rdi
    for (i = 0; *s1 && i < Len; i++)
    7e75:	4c 89 c3             	mov    %r8,%rbx
    RtCopyMem(Dest + DestSize, Src, Size * sizeof(CHAR16));
    7e78:	e8 93 fc ff ff       	call   7b10 <RtCopyMem>
    Dest[DestSize + Size] = '\0';
    7e7d:	31 c0                	xor    %eax,%eax
    7e7f:	66 89 03             	mov    %ax,(%rbx)
}
    7e82:	5b                   	pop    %rbx
    7e83:	c3                   	ret    
    7e84:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7e8b:	00 00 00 00 
    7e8f:	90                   	nop

0000000000007e90 <RtStrLen>:
{
    7e90:	f3 0f 1e fa          	endbr64 
    for (len=0; *s1; s1+=1, len+=1) ;
    7e94:	31 c0                	xor    %eax,%eax
    7e96:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    7e9a:	74 14                	je     7eb0 <RtStrLen+0x20>
    7e9c:	0f 1f 40 00          	nopl   0x0(%rax)
    7ea0:	48 83 c0 01          	add    $0x1,%rax
    7ea4:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    7ea9:	75 f5                	jne    7ea0 <RtStrLen+0x10>
    7eab:	c3                   	ret    
    7eac:	0f 1f 40 00          	nopl   0x0(%rax)
}
    7eb0:	c3                   	ret    
    7eb1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7eb8:	00 00 00 00 
    7ebc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007ec0 <RtStrnLen>:
{
    7ec0:	f3 0f 1e fa          	endbr64 
    for (i = 0; *s1 && i < Len; i++)
    7ec4:	31 c0                	xor    %eax,%eax
    7ec6:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    7eca:	74 1c                	je     7ee8 <RtStrnLen+0x28>
    7ecc:	48 85 f6             	test   %rsi,%rsi
    7ecf:	75 0c                	jne    7edd <RtStrnLen+0x1d>
    7ed1:	eb 15                	jmp    7ee8 <RtStrnLen+0x28>
    7ed3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    7ed8:	48 39 c6             	cmp    %rax,%rsi
    7edb:	76 13                	jbe    7ef0 <RtStrnLen+0x30>
    7edd:	48 83 c0 01          	add    $0x1,%rax
    7ee1:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    7ee6:	75 f0                	jne    7ed8 <RtStrnLen+0x18>
        s1++;
    return i;
}
    7ee8:	c3                   	ret    
    7ee9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    7ef0:	c3                   	ret    
    7ef1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7ef8:	00 00 00 00 
    7efc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007f00 <RtStrSize>:
RUNTIMEFUNCTION
RtStrSize (
    IN CONST CHAR16   *s1
    )
// string size
{
    7f00:	f3 0f 1e fa          	endbr64 
    UINTN        len;

    for (len=0; *s1; s1+=1, len+=1) ;
    7f04:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    7f08:	74 1e                	je     7f28 <RtStrSize+0x28>
    7f0a:	31 c0                	xor    %eax,%eax
    7f0c:	0f 1f 40 00          	nopl   0x0(%rax)
    7f10:	48 89 c2             	mov    %rax,%rdx
    7f13:	48 83 c0 01          	add    $0x1,%rax
    7f17:	66 83 3c 47 00       	cmpw   $0x0,(%rdi,%rax,2)
    7f1c:	75 f2                	jne    7f10 <RtStrSize+0x10>
    return (len + 1) * sizeof(CHAR16);
    7f1e:	48 8d 44 12 04       	lea    0x4(%rdx,%rdx,1),%rax
    7f23:	c3                   	ret    
    7f24:	0f 1f 40 00          	nopl   0x0(%rax)
    for (len=0; *s1; s1+=1, len+=1) ;
    7f28:	b8 02 00 00 00       	mov    $0x2,%eax
}
    7f2d:	c3                   	ret    
    7f2e:	66 90                	xchg   %ax,%ax

0000000000007f30 <RtBCDtoDecimal>:
UINT8
RUNTIMEFUNCTION
RtBCDtoDecimal(
    IN  UINT8 BcdValue
    )
{
    7f30:	f3 0f 1e fa          	endbr64 
    UINTN   High, Low;

    High    = BcdValue >> 4;
    7f34:	89 f8                	mov    %edi,%eax
    Low     = BcdValue - (High << 4);
    7f36:	83 e7 0f             	and    $0xf,%edi
    High    = BcdValue >> 4;
    7f39:	c0 e8 04             	shr    $0x4,%al

    return ((UINT8)(Low + (High * 10)));
    7f3c:	8d 04 80             	lea    (%rax,%rax,4),%eax
    7f3f:	8d 04 47             	lea    (%rdi,%rax,2),%eax
}
    7f42:	c3                   	ret    
    7f43:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7f4a:	00 00 00 00 
    7f4e:	66 90                	xchg   %ax,%ax

0000000000007f50 <RtDecimaltoBCD>:
UINT8
RUNTIMEFUNCTION
RtDecimaltoBCD (
    IN  UINT8 DecValue
    )
{
    7f50:	f3 0f 1e fa          	endbr64 
    UINTN   High, Low;

    High    = DecValue / 10;
    7f54:	b8 cd ff ff ff       	mov    $0xffffffcd,%eax
    7f59:	40 f6 e7             	mul    %dil
    Low     = DecValue - (High * 10);
    7f5c:	40 0f b6 ff          	movzbl %dil,%edi
    High    = DecValue / 10;
    7f60:	66 c1 e8 0b          	shr    $0xb,%ax
    7f64:	0f b6 d0             	movzbl %al,%edx

    return ((UINT8)(Low + (High << 4)));
    7f67:	c1 e0 04             	shl    $0x4,%eax
    Low     = DecValue - (High * 10);
    7f6a:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
    7f6e:	48 01 d2             	add    %rdx,%rdx
    7f71:	48 29 d7             	sub    %rdx,%rdi
    return ((UINT8)(Low + (High << 4)));
    7f74:	01 f8                	add    %edi,%eax
}
    7f76:	c3                   	ret    
    7f77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    7f7e:	00 00 

0000000000007f80 <InitializeLibPlatform>:
VOID
InitializeLibPlatform (
    IN EFI_HANDLE           ImageHandle EFI_UNUSED,
    IN EFI_SYSTEM_TABLE     *SystemTable EFI_UNUSED
    )
{
    7f80:	f3 0f 1e fa          	endbr64 
}
    7f84:	c3                   	ret    
    7f85:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    7f8c:	00 00 00 
    7f8f:	90                   	nop

0000000000007f90 <LShiftU64>:
LShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
// Left shift 64bit by 32bit and get a 64bit result
{
    7f90:	f3 0f 1e fa          	endbr64 
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    return Operand << Count;
    7f94:	48 89 f8             	mov    %rdi,%rax
    7f97:	89 f1                	mov    %esi,%ecx
    7f99:	48 d3 e0             	shl    %cl,%rax
        mov     dword ptr Result[4], edx
    }

    return Result;
#endif
}
    7f9c:	c3                   	ret    
    7f9d:	0f 1f 00             	nopl   (%rax)

0000000000007fa0 <RShiftU64>:
RShiftU64 (
    IN UINT64   Operand,
    IN UINTN    Count
    )
// Right shift 64bit by 32bit and get a 64bit result
{
    7fa0:	f3 0f 1e fa          	endbr64 
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    return Operand >> Count;
    7fa4:	48 89 f8             	mov    %rdi,%rax
    7fa7:	89 f1                	mov    %esi,%ecx
    7fa9:	48 d3 e8             	shr    %cl,%rax
        mov     dword ptr Result[4], edx
    }

    return Result;
#endif
}
    7fac:	c3                   	ret    
    7fad:	0f 1f 00             	nopl   (%rax)

0000000000007fb0 <MultU64x32>:
MultU64x32 (
    IN UINT64   Multiplicand,
    IN UINTN    Multiplier
    )
// Multiple 64bit by 32bit and get a 64bit result
{
    7fb0:	f3 0f 1e fa          	endbr64 
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    return Multiplicand * Multiplier;
    7fb4:	48 89 f8             	mov    %rdi,%rax
    7fb7:	48 0f af c6          	imul   %rsi,%rax
        add     dword ptr Result[4], eax
    }

    return Result;
#endif
}
    7fbb:	c3                   	ret    
    7fbc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007fc0 <DivU64x32>:
    IN UINTN    Divisor,
    OUT UINTN   *Remainder OPTIONAL
    )
// divide 64bit by 32bit and get a 64bit result
// N.B. only works for 31bit divisors!!
{
    7fc0:	f3 0f 1e fa          	endbr64 
    7fc4:	48 89 d1             	mov    %rdx,%rcx
#if defined(__GNUC__) || defined(_MSC_EXTENSIONS)
    if (Remainder)
    7fc7:	48 85 d2             	test   %rdx,%rdx
    7fca:	74 0b                	je     7fd7 <DivU64x32+0x17>
	*Remainder = Dividend % Divisor;
    7fcc:	48 89 f8             	mov    %rdi,%rax
    7fcf:	31 d2                	xor    %edx,%edx
    7fd1:	48 f7 f6             	div    %rsi
    7fd4:	48 89 11             	mov    %rdx,(%rcx)
    return Dividend / Divisor;
    7fd7:	48 89 f8             	mov    %rdi,%rax
    7fda:	31 d2                	xor    %edx,%edx
    7fdc:	48 f7 f6             	div    %rsi
        *Remainder = Rem;
    }

    return Dividend;
#endif
}
    7fdf:	c3                   	ret    

0000000000007fe0 <_DevPathEndInstance>:
static VOID
_DevPathEndInstance (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath EFI_UNUSED
    )
{
    7fe0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L",");
    7fe4:	48 8d 35 6d 19 02 00 	lea    0x2196d(%rip),%rsi        # 29958 <_DYNAMIC+0xb958>
    7feb:	31 c0                	xor    %eax,%eax
    7fed:	e9 fe ea ff ff       	jmp    6af0 <CatPrint>
    7ff2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    7ff9:	00 00 00 00 
    7ffd:	0f 1f 00             	nopl   (%rax)

0000000000008000 <_DevPathBssBss>:
{
    8000:	f3 0f 1e fa          	endbr64 
    switch (Bss->DeviceType) {
    8004:	66 83 7e 04 06       	cmpw   $0x6,0x4(%rsi)
    8009:	77 7e                	ja     8089 <_DevPathBssBss+0x89>
    800b:	0f b7 46 04          	movzwl 0x4(%rsi),%eax
    800f:	48 8d 15 ae 19 02 00 	lea    0x219ae(%rip),%rdx        # 299c4 <_DYNAMIC+0xb9c4>
    8016:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    801a:	48 01 d0             	add    %rdx,%rax
    801d:	3e ff e0             	notrack jmp *%rax
    8020:	48 8d 15 43 19 02 00 	lea    0x21943(%rip),%rdx        # 2996a <_DYNAMIC+0xb96a>
    CatPrint(Str, L"Bss-%s(%a)", Type, Bss->String);
    8027:	48 8d 4e 08          	lea    0x8(%rsi),%rcx
    802b:	31 c0                	xor    %eax,%eax
    802d:	48 8d 35 78 19 02 00 	lea    0x21978(%rip),%rsi        # 299ac <_DYNAMIC+0xb9ac>
    8034:	e9 b7 ea ff ff       	jmp    6af0 <CatPrint>
    8039:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_FLOPPY:               Type = L"Floppy";       break;
    8040:	48 8d 15 15 19 02 00 	lea    0x21915(%rip),%rdx        # 2995c <_DYNAMIC+0xb95c>
    8047:	eb de                	jmp    8027 <_DevPathBssBss+0x27>
    8049:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_EMBEDDED_NETWORK:     Type = L"Net";          break;
    8050:	48 8d 15 49 19 02 00 	lea    0x21949(%rip),%rdx        # 299a0 <_DYNAMIC+0xb9a0>
    8057:	eb ce                	jmp    8027 <_DevPathBssBss+0x27>
    8059:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_CDROM:                Type = L"CDROM";        break;
    8060:	48 8d 15 17 19 02 00 	lea    0x21917(%rip),%rdx        # 2997e <_DYNAMIC+0xb97e>
    8067:	eb be                	jmp    8027 <_DevPathBssBss+0x27>
    8069:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_PCMCIA:               Type = L"PCMCIA";       break;
    8070:	48 8d 15 13 19 02 00 	lea    0x21913(%rip),%rdx        # 2998a <_DYNAMIC+0xb98a>
    8077:	eb ae                	jmp    8027 <_DevPathBssBss+0x27>
    8079:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    case BBS_TYPE_USB:                  Type = L"Usb";          break;
    8080:	48 8d 15 11 19 02 00 	lea    0x21911(%rip),%rdx        # 29998 <_DYNAMIC+0xb998>
    8087:	eb 9e                	jmp    8027 <_DevPathBssBss+0x27>
    default:                            Type = L"?";            break;
    8089:	48 8d 15 18 19 02 00 	lea    0x21918(%rip),%rdx        # 299a8 <_DYNAMIC+0xb9a8>
    8090:	eb 95                	jmp    8027 <_DevPathBssBss+0x27>
    8092:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8099:	00 00 00 00 
    809d:	0f 1f 00             	nopl   (%rax)

00000000000080a0 <_DevPathMediaProtocol>:
{
    80a0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"%g", &MediaProt->Protocol);
    80a4:	48 8d 56 04          	lea    0x4(%rsi),%rdx
    80a8:	31 c0                	xor    %eax,%eax
    80aa:	48 8d 35 2f 19 02 00 	lea    0x2192f(%rip),%rsi        # 299e0 <_DYNAMIC+0xb9e0>
    80b1:	e9 3a ea ff ff       	jmp    6af0 <CatPrint>
    80b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    80bd:	00 00 00 

00000000000080c0 <_DevPathFilePath>:
{
    80c0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"%s", Fp->PathName);
    80c4:	48 8d 56 04          	lea    0x4(%rsi),%rdx
    80c8:	31 c0                	xor    %eax,%eax
    80ca:	48 8d 35 15 19 02 00 	lea    0x21915(%rip),%rsi        # 299e6 <_DYNAMIC+0xb9e6>
    80d1:	e9 1a ea ff ff       	jmp    6af0 <CatPrint>
    80d6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    80dd:	00 00 00 

00000000000080e0 <_DevPathCDROM>:
{
    80e0:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"CDROM(0x%x)" , Cd-> BootEntry ) ;
    80e4:	8b 56 04             	mov    0x4(%rsi),%edx
    80e7:	31 c0                	xor    %eax,%eax
    80e9:	48 8d 35 fc 18 02 00 	lea    0x218fc(%rip),%rsi        # 299ec <_DYNAMIC+0xb9ec>
    80f0:	e9 fb e9 ff ff       	jmp    6af0 <CatPrint>
    80f5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    80fc:	00 00 00 00 

0000000000008100 <_DevPathSata>:
{
    8100:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"Sata(0x%x,0x%x,0x%x)" , Sata-> HBAPortNumber ,
    8104:	0f b7 4e 06          	movzwl 0x6(%rsi),%ecx
    8108:	0f b7 56 04          	movzwl 0x4(%rsi),%edx
    810c:	31 c0                	xor    %eax,%eax
    810e:	44 0f b7 46 08       	movzwl 0x8(%rsi),%r8d
    8113:	48 8d 35 ee 18 02 00 	lea    0x218ee(%rip),%rsi        # 29a08 <_DYNAMIC+0xba08>
    811a:	e9 d1 e9 ff ff       	jmp    6af0 <CatPrint>
    811f:	90                   	nop

0000000000008120 <_DevPathUart>:
{
    8120:	f3 0f 1e fa          	endbr64 
    8124:	41 54                	push   %r12
    8126:	41 bc 78 00 00 00    	mov    $0x78,%r12d
    812c:	55                   	push   %rbp
    812d:	48 89 fd             	mov    %rdi,%rbp
    8130:	53                   	push   %rbx
    switch (Uart->Parity) {
    8131:	0f b6 46 11          	movzbl 0x11(%rsi),%eax
{
    8135:	48 89 f3             	mov    %rsi,%rbx
    8138:	3c 05                	cmp    $0x5,%al
    813a:	77 0c                	ja     8148 <_DevPathUart+0x28>
    CatPrint(Str, L"%c,", Parity);
    813c:	48 8d 15 37 1e 02 00 	lea    0x21e37(%rip),%rdx        # 29f7a <CSWTCH.43>
    8143:	44 0f b6 24 02       	movzbl (%rdx,%rax,1),%r12d
    if (Uart->BaudRate == 0) {
    8148:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    814c:	48 85 d2             	test   %rdx,%rdx
    814f:	0f 85 9b 00 00 00    	jne    81f0 <_DevPathUart+0xd0>
        CatPrint(Str, L"Uart(DEFAULT,");
    8155:	48 8d 35 d6 18 02 00 	lea    0x218d6(%rip),%rsi        # 29a32 <_DYNAMIC+0xba32>
    815c:	48 89 ef             	mov    %rbp,%rdi
    815f:	31 c0                	xor    %eax,%eax
    8161:	e8 8a e9 ff ff       	call   6af0 <CatPrint>
    if (Uart->DataBits == 0) {
    8166:	0f b6 53 10          	movzbl 0x10(%rbx),%edx
    816a:	84 d2                	test   %dl,%dl
    816c:	0f 85 9b 00 00 00    	jne    820d <_DevPathUart+0xed>
        CatPrint(Str, L"DEFAULT,");
    8172:	48 8d 35 e9 18 02 00 	lea    0x218e9(%rip),%rsi        # 29a62 <_DYNAMIC+0xba62>
    8179:	48 89 ef             	mov    %rbp,%rdi
    817c:	31 c0                	xor    %eax,%eax
    817e:	e8 6d e9 ff ff       	call   6af0 <CatPrint>
    CatPrint(Str, L"%c,", Parity);
    8183:	48 8d 35 f2 18 02 00 	lea    0x218f2(%rip),%rsi        # 29a7c <_DYNAMIC+0xba7c>
    818a:	44 89 e2             	mov    %r12d,%edx
    818d:	48 89 ef             	mov    %rbp,%rdi
    8190:	31 c0                	xor    %eax,%eax
    8192:	e8 59 e9 ff ff       	call   6af0 <CatPrint>
    switch (Uart->StopBits) {
    8197:	0f b6 43 12          	movzbl 0x12(%rbx),%eax
        case 2  : CatPrint(Str, L"1.5)"); break;
    819b:	48 8d 35 ee 18 02 00 	lea    0x218ee(%rip),%rsi        # 29a90 <_DYNAMIC+0xba90>
    switch (Uart->StopBits) {
    81a2:	3c 02                	cmp    $0x2,%al
    81a4:	74 0d                	je     81b3 <_DevPathUart+0x93>
    81a6:	77 20                	ja     81c8 <_DevPathUart+0xa8>
        case 1  : CatPrint(Str, L"1)");   break;
    81a8:	48 8d 35 db 18 02 00 	lea    0x218db(%rip),%rsi        # 29a8a <_DYNAMIC+0xba8a>
    switch (Uart->StopBits) {
    81af:	84 c0                	test   %al,%al
    81b1:	74 75                	je     8228 <_DevPathUart+0x108>
}
    81b3:	5b                   	pop    %rbx
        default : CatPrint(Str, L"x)");   break;
    81b4:	48 89 ef             	mov    %rbp,%rdi
    81b7:	31 c0                	xor    %eax,%eax
}
    81b9:	5d                   	pop    %rbp
    81ba:	41 5c                	pop    %r12
        default : CatPrint(Str, L"x)");   break;
    81bc:	e9 2f e9 ff ff       	jmp    6af0 <CatPrint>
    81c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case 3  : CatPrint(Str, L"2)");   break;
    81c8:	48 8d 35 cb 18 02 00 	lea    0x218cb(%rip),%rsi        # 29a9a <_DYNAMIC+0xba9a>
    switch (Uart->StopBits) {
    81cf:	3c 03                	cmp    $0x3,%al
    81d1:	74 e0                	je     81b3 <_DevPathUart+0x93>
}
    81d3:	5b                   	pop    %rbx
        default : CatPrint(Str, L"x)");   break;
    81d4:	48 89 ef             	mov    %rbp,%rdi
    81d7:	48 8d 35 c2 18 02 00 	lea    0x218c2(%rip),%rsi        # 29aa0 <_DYNAMIC+0xbaa0>
}
    81de:	5d                   	pop    %rbp
        default : CatPrint(Str, L"x)");   break;
    81df:	31 c0                	xor    %eax,%eax
}
    81e1:	41 5c                	pop    %r12
        default : CatPrint(Str, L"x)");   break;
    81e3:	e9 08 e9 ff ff       	jmp    6af0 <CatPrint>
    81e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    81ef:	00 
        CatPrint(Str, L"Uart(%ld,", Uart->BaudRate);
    81f0:	48 8d 35 57 18 02 00 	lea    0x21857(%rip),%rsi        # 29a4e <_DYNAMIC+0xba4e>
    81f7:	48 89 ef             	mov    %rbp,%rdi
    81fa:	31 c0                	xor    %eax,%eax
    81fc:	e8 ef e8 ff ff       	call   6af0 <CatPrint>
    if (Uart->DataBits == 0) {
    8201:	0f b6 53 10          	movzbl 0x10(%rbx),%edx
    8205:	84 d2                	test   %dl,%dl
    8207:	0f 84 65 ff ff ff    	je     8172 <_DevPathUart+0x52>
        CatPrint(Str, L"%d,", Uart->DataBits);
    820d:	48 8d 35 60 18 02 00 	lea    0x21860(%rip),%rsi        # 29a74 <_DYNAMIC+0xba74>
    8214:	48 89 ef             	mov    %rbp,%rdi
    8217:	31 c0                	xor    %eax,%eax
    8219:	e8 d2 e8 ff ff       	call   6af0 <CatPrint>
    821e:	e9 60 ff ff ff       	jmp    8183 <_DevPathUart+0x63>
    8223:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
}
    8228:	5b                   	pop    %rbx
        default : CatPrint(Str, L"x)");   break;
    8229:	48 89 ef             	mov    %rbp,%rdi
        case 0  : CatPrint(Str, L"D)");   break;
    822c:	48 8d 35 51 18 02 00 	lea    0x21851(%rip),%rsi        # 29a84 <_DYNAMIC+0xba84>
}
    8233:	5d                   	pop    %rbp
        default : CatPrint(Str, L"x)");   break;
    8234:	31 c0                	xor    %eax,%eax
}
    8236:	41 5c                	pop    %r12
        default : CatPrint(Str, L"x)");   break;
    8238:	e9 b3 e8 ff ff       	jmp    6af0 <CatPrint>
    823d:	0f 1f 00             	nopl   (%rax)

0000000000008240 <_DevPathInfiniBand>:
{
    8240:	f3 0f 1e fa          	endbr64 
    8244:	48 83 ec 18          	sub    $0x18,%rsp
    CatPrint(Str, L"Infiniband(0x%x,%g,0x%lx,0x%lx,0x%lx)",
    8248:	48 8b 46 28          	mov    0x28(%rsi),%rax
    824c:	8b 56 04             	mov    0x4(%rsi),%edx
        InfiniBand->ResourceFlags, InfiniBand->PortGid, InfiniBand->ServiceId,
    824f:	48 8d 4e 08          	lea    0x8(%rsi),%rcx
    CatPrint(Str, L"Infiniband(0x%x,%g,0x%lx,0x%lx,0x%lx)",
    8253:	48 89 04 24          	mov    %rax,(%rsp)
    8257:	4c 8b 4e 20          	mov    0x20(%rsi),%r9
    825b:	31 c0                	xor    %eax,%eax
    825d:	4c 8b 46 18          	mov    0x18(%rsi),%r8
    8261:	48 8d 35 40 18 02 00 	lea    0x21840(%rip),%rsi        # 29aa8 <_DYNAMIC+0xbaa8>
    8268:	e8 83 e8 ff ff       	call   6af0 <CatPrint>
}
    826d:	48 83 c4 18          	add    $0x18,%rsp
    8271:	c3                   	ret    
    8272:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8279:	00 00 00 00 
    827d:	0f 1f 00             	nopl   (%rax)

0000000000008280 <_DevPathUri>:
{
    8280:	f3 0f 1e fa          	endbr64 
    CatPrint( Str, L"Uri(%a)", Uri->Uri );
    8284:	48 8d 56 04          	lea    0x4(%rsi),%rdx
    8288:	31 c0                	xor    %eax,%eax
    828a:	48 8d 35 63 18 02 00 	lea    0x21863(%rip),%rsi        # 29af4 <_DYNAMIC+0xbaf4>
    8291:	e9 5a e8 ff ff       	jmp    6af0 <CatPrint>
    8296:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    829d:	00 00 00 

00000000000082a0 <_DevPathMacAddr>:
{
    82a0:	f3 0f 1e fa          	endbr64 
    82a4:	41 56                	push   %r14
    82a6:	41 55                	push   %r13
    82a8:	41 54                	push   %r12
    82aa:	49 89 fc             	mov    %rdi,%r12
    82ad:	55                   	push   %rbp
    82ae:	48 89 f5             	mov    %rsi,%rbp
    82b1:	53                   	push   %rbx
    if (MAC->IfType == 0x01 || MAC->IfType == 0x00) {
    82b2:	80 7e 24 01          	cmpb   $0x1,0x24(%rsi)
    82b6:	0f b7 46 02          	movzwl 0x2(%rsi),%eax
    82ba:	76 64                	jbe    8320 <_DevPathMacAddr+0x80>
    HwAddressSize -= sizeof( MAC-> IfType ) ;
    82bc:	4c 8d 70 fb          	lea    -0x5(%rax),%r14
    CatPrint(Str, L"Mac(");
    82c0:	48 8d 35 3d 18 02 00 	lea    0x2183d(%rip),%rsi        # 29b04 <_DYNAMIC+0xbb04>
    82c7:	31 c0                	xor    %eax,%eax
    82c9:	e8 22 e8 ff ff       	call   6af0 <CatPrint>
    for(Index = 0; Index < HwAddressSize; Index++) {
    82ce:	4d 85 f6             	test   %r14,%r14
    82d1:	74 28                	je     82fb <_DevPathMacAddr+0x5b>
    82d3:	31 db                	xor    %ebx,%ebx
    82d5:	4c 8d 2d 32 18 02 00 	lea    0x21832(%rip),%r13        # 29b0e <_DYNAMIC+0xbb0e>
    82dc:	0f 1f 40 00          	nopl   0x0(%rax)
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    82e0:	0f b6 54 1d 04       	movzbl 0x4(%rbp,%rbx,1),%edx
    82e5:	4c 89 ee             	mov    %r13,%rsi
    82e8:	4c 89 e7             	mov    %r12,%rdi
    82eb:	31 c0                	xor    %eax,%eax
    for(Index = 0; Index < HwAddressSize; Index++) {
    82ed:	48 83 c3 01          	add    $0x1,%rbx
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    82f1:	e8 fa e7 ff ff       	call   6af0 <CatPrint>
    for(Index = 0; Index < HwAddressSize; Index++) {
    82f6:	4c 39 f3             	cmp    %r14,%rbx
    82f9:	72 e5                	jb     82e0 <_DevPathMacAddr+0x40>
    if ( MAC-> IfType != 0 ) {
    82fb:	0f b6 55 24          	movzbl 0x24(%rbp),%edx
    82ff:	84 d2                	test   %dl,%dl
    8301:	75 3d                	jne    8340 <_DevPathMacAddr+0xa0>
}
    8303:	5b                   	pop    %rbx
    CatPrint(Str, L")");
    8304:	4c 89 e7             	mov    %r12,%rdi
}
    8307:	5d                   	pop    %rbp
    CatPrint(Str, L")");
    8308:	31 c0                	xor    %eax,%eax
}
    830a:	41 5c                	pop    %r12
    CatPrint(Str, L")");
    830c:	48 8d 35 0d 18 02 00 	lea    0x2180d(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
}
    8313:	41 5d                	pop    %r13
    8315:	41 5e                	pop    %r14
    CatPrint(Str, L")");
    8317:	e9 d4 e7 ff ff       	jmp    6af0 <CatPrint>
    831c:	0f 1f 40 00          	nopl   0x0(%rax)
    CatPrint(Str, L"Mac(");
    8320:	48 8d 35 dd 17 02 00 	lea    0x217dd(%rip),%rsi        # 29b04 <_DYNAMIC+0xbb04>
    8327:	31 c0                	xor    %eax,%eax
        HwAddressSize = 6;
    8329:	41 be 06 00 00 00    	mov    $0x6,%r14d
    CatPrint(Str, L"Mac(");
    832f:	e8 bc e7 ff ff       	call   6af0 <CatPrint>
    for(Index = 0; Index < HwAddressSize; Index++) {
    8334:	eb 9d                	jmp    82d3 <_DevPathMacAddr+0x33>
    8336:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    833d:	00 00 00 
        CatPrint(Str, L",%d" , MAC-> IfType ) ;
    8340:	48 8d 35 d1 17 02 00 	lea    0x217d1(%rip),%rsi        # 29b18 <_DYNAMIC+0xbb18>
    8347:	4c 89 e7             	mov    %r12,%rdi
    834a:	31 c0                	xor    %eax,%eax
    834c:	e8 9f e7 ff ff       	call   6af0 <CatPrint>
    8351:	eb b0                	jmp    8303 <_DevPathMacAddr+0x63>
    8353:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    835a:	00 00 00 00 
    835e:	66 90                	xchg   %ax,%ax

0000000000008360 <_DevPathI2O>:
{
    8360:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"I2O(0x%X)", I2O->Tid);
    8364:	8b 56 04             	mov    0x4(%rsi),%edx
    8367:	31 c0                	xor    %eax,%eax
    8369:	48 8d 35 b4 17 02 00 	lea    0x217b4(%rip),%rsi        # 29b24 <_DYNAMIC+0xbb24>
    8370:	e9 7b e7 ff ff       	jmp    6af0 <CatPrint>
    8375:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    837c:	00 00 00 00 

0000000000008380 <_DevPathUsb>:
{
    8380:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"Usb(0x%x,0x%x)" , Usb-> Port , Usb-> Endpoint ) ;
    8384:	0f b6 4e 05          	movzbl 0x5(%rsi),%ecx
    8388:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    838c:	31 c0                	xor    %eax,%eax
    838e:	48 8d 35 a3 17 02 00 	lea    0x217a3(%rip),%rsi        # 29b38 <_DYNAMIC+0xbb38>
    8395:	e9 56 e7 ff ff       	jmp    6af0 <CatPrint>
    839a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000083a0 <_DevPath1394>:
{
    83a0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"I1394(%016lx)", F1394->Guid);
    83a4:	48 8b 56 08          	mov    0x8(%rsi),%rdx
    83a8:	31 c0                	xor    %eax,%eax
    83aa:	48 8d 35 a5 17 02 00 	lea    0x217a5(%rip),%rsi        # 29b56 <_DYNAMIC+0xbb56>
    83b1:	e9 3a e7 ff ff       	jmp    6af0 <CatPrint>
    83b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    83bd:	00 00 00 

00000000000083c0 <_DevPathFibre>:
{
    83c0:	f3 0f 1e fa          	endbr64 
    CatPrint( Str , L"Fibre%s(0x%016lx,0x%016lx)" ,
    83c4:	0f b6 06             	movzbl (%rsi),%eax
    83c7:	48 8d 15 a4 17 02 00 	lea    0x217a4(%rip),%rdx        # 29b72 <_DYNAMIC+0xbb72>
    83ce:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
    83d2:	4c 8b 46 10          	mov    0x10(%rsi),%r8
    83d6:	48 8d 35 a3 17 02 00 	lea    0x217a3(%rip),%rsi        # 29b80 <_DYNAMIC+0xbb80>
    83dd:	83 e0 7f             	and    $0x7f,%eax
    83e0:	3c 03                	cmp    $0x3,%al
    83e2:	48 8d 05 8b 17 02 00 	lea    0x2178b(%rip),%rax        # 29b74 <_DYNAMIC+0xbb74>
    83e9:	48 0f 45 d0          	cmovne %rax,%rdx
    83ed:	31 c0                	xor    %eax,%eax
    83ef:	e9 fc e6 ff ff       	jmp    6af0 <CatPrint>
    83f4:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    83fb:	00 00 00 00 
    83ff:	90                   	nop

0000000000008400 <_DevPathScsi>:
{
    8400:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Scsi(%d,%d)", Scsi->Pun, Scsi->Lun);
    8404:	0f b7 4e 06          	movzwl 0x6(%rsi),%ecx
    8408:	0f b7 56 04          	movzwl 0x4(%rsi),%edx
    840c:	31 c0                	xor    %eax,%eax
    840e:	48 8d 35 a1 17 02 00 	lea    0x217a1(%rip),%rsi        # 29bb6 <_DYNAMIC+0xbbb6>
    8415:	e9 d6 e6 ff ff       	jmp    6af0 <CatPrint>
    841a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000008420 <_DevPathAtapi>:
{
    8420:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Ata(%s,%s)",
    8424:	80 7e 05 00          	cmpb   $0x0,0x5(%rsi)
    8428:	48 8d 05 ab 17 02 00 	lea    0x217ab(%rip),%rax        # 29bda <_DYNAMIC+0xbbda>
    842f:	48 8d 0d 98 17 02 00 	lea    0x21798(%rip),%rcx        # 29bce <_DYNAMIC+0xbbce>
    8436:	48 0f 44 c8          	cmove  %rax,%rcx
    843a:	48 8d 15 a7 17 02 00 	lea    0x217a7(%rip),%rdx        # 29be8 <_DYNAMIC+0xbbe8>
    8441:	80 7e 04 00          	cmpb   $0x0,0x4(%rsi)
    8445:	48 8d 05 b0 17 02 00 	lea    0x217b0(%rip),%rax        # 29bfc <_DYNAMIC+0xbbfc>
    844c:	48 8d 35 b9 17 02 00 	lea    0x217b9(%rip),%rsi        # 29c0c <_DYNAMIC+0xbc0c>
    8453:	48 0f 44 d0          	cmove  %rax,%rdx
    8457:	31 c0                	xor    %eax,%eax
    8459:	e9 92 e6 ff ff       	jmp    6af0 <CatPrint>
    845e:	66 90                	xchg   %ax,%ax

0000000000008460 <_DevPathAcpi>:
{
    8460:	f3 0f 1e fa          	endbr64 
    8464:	55                   	push   %rbp
    8465:	48 89 fd             	mov    %rdi,%rbp
    8468:	53                   	push   %rbx
    8469:	48 89 f3             	mov    %rsi,%rbx
    846c:	48 83 ec 08          	sub    $0x8,%rsp
    if ((Acpi->HID & PNP_EISA_ID_MASK) == PNP_EISA_ID_CONST) {
    8470:	8b 56 04             	mov    0x4(%rsi),%edx
    8473:	66 81 fa d0 41       	cmp    $0x41d0,%dx
    8478:	75 7e                	jne    84f8 <_DevPathAcpi+0x98>
        switch ( EISA_ID_TO_NUM( Acpi-> HID ) ) {
    847a:	c1 ea 10             	shr    $0x10,%edx
    847d:	81 fa 04 06 00 00    	cmp    $0x604,%edx
    8483:	0f 84 f7 00 00 00    	je     8580 <_DevPathAcpi+0x120>
    8489:	77 35                	ja     84c0 <_DevPathAcpi+0x60>
    848b:	81 fa 01 04 00 00    	cmp    $0x401,%edx
    8491:	0f 84 d9 00 00 00    	je     8570 <_DevPathAcpi+0x110>
    8497:	81 fa 01 05 00 00    	cmp    $0x501,%edx
    849d:	75 41                	jne    84e0 <_DevPathAcpi+0x80>
                CatPrint( Str , L"Serial(%d)" , Acpi-> UID ) ;
    849f:	8b 56 08             	mov    0x8(%rsi),%edx
    84a2:	48 8d 35 b9 17 02 00 	lea    0x217b9(%rip),%rsi        # 29c62 <_DYNAMIC+0xbc62>
}
    84a9:	48 83 c4 08          	add    $0x8,%rsp
                CatPrint( Str , L"ParallelPort(%d)" , Acpi-> UID ) ;
    84ad:	48 89 ef             	mov    %rbp,%rdi
    84b0:	31 c0                	xor    %eax,%eax
}
    84b2:	5b                   	pop    %rbx
    84b3:	5d                   	pop    %rbp
                CatPrint( Str , L"ParallelPort(%d)" , Acpi-> UID ) ;
    84b4:	e9 37 e6 ff ff       	jmp    6af0 <CatPrint>
    84b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        switch ( EISA_ID_TO_NUM( Acpi-> HID ) ) {
    84c0:	81 fa 03 0a 00 00    	cmp    $0xa03,%edx
    84c6:	74 68                	je     8530 <_DevPathAcpi+0xd0>
    84c8:	81 fa 08 0a 00 00    	cmp    $0xa08,%edx
    84ce:	75 70                	jne    8540 <_DevPathAcpi+0xe0>
                CatPrint( Str , L"PcieRoot(%d)" , Acpi-> UID ) ;
    84d0:	8b 56 08             	mov    0x8(%rsi),%edx
    84d3:	48 8d 35 cc 17 02 00 	lea    0x217cc(%rip),%rsi        # 29ca6 <_DYNAMIC+0xbca6>
    84da:	eb cd                	jmp    84a9 <_DevPathAcpi+0x49>
    84dc:	0f 1f 40 00          	nopl   0x0(%rax)
        switch ( EISA_ID_TO_NUM( Acpi-> HID ) ) {
    84e0:	81 fa 01 03 00 00    	cmp    $0x301,%edx
    84e6:	75 58                	jne    8540 <_DevPathAcpi+0xe0>
                CatPrint( Str , L"Keyboard(%d)" , Acpi-> UID ) ;
    84e8:	8b 56 08             	mov    0x8(%rsi),%edx
    84eb:	48 8d 35 30 17 02 00 	lea    0x21730(%rip),%rsi        # 29c22 <_DYNAMIC+0xbc22>
    84f2:	eb b5                	jmp    84a9 <_DevPathAcpi+0x49>
    84f4:	0f 1f 40 00          	nopl   0x0(%rax)
        CatPrint( Str , L"Acpi(0x%X" , Acpi-> HID ) ;
    84f8:	48 8d 35 db 17 02 00 	lea    0x217db(%rip),%rsi        # 29cda <_DYNAMIC+0xbcda>
    84ff:	31 c0                	xor    %eax,%eax
    8501:	e8 ea e5 ff ff       	call   6af0 <CatPrint>
        if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    8506:	8b 4b 08             	mov    0x8(%rbx),%ecx
    8509:	85 c9                	test   %ecx,%ecx
    850b:	0f 85 7f 00 00 00    	jne    8590 <_DevPathAcpi+0x130>
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    8511:	8b 53 04             	mov    0x4(%rbx),%edx
}
    8514:	48 83 c4 08          	add    $0x8,%rsp
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    8518:	48 89 ef             	mov    %rbp,%rdi
    851b:	31 c0                	xor    %eax,%eax
}
    851d:	5b                   	pop    %rbx
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    851e:	48 8d 35 fb 15 02 00 	lea    0x215fb(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
}
    8525:	5d                   	pop    %rbp
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    8526:	e9 c5 e5 ff ff       	jmp    6af0 <CatPrint>
    852b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                CatPrint( Str , L"PciRoot(%d)" , Acpi-> UID ) ;
    8530:	8b 56 08             	mov    0x8(%rsi),%edx
    8533:	48 8d 35 54 17 02 00 	lea    0x21754(%rip),%rsi        # 29c8e <_DYNAMIC+0xbc8e>
    853a:	e9 6a ff ff ff       	jmp    84a9 <_DevPathAcpi+0x49>
    853f:	90                   	nop
                CatPrint( Str , L"Acpi(PNP%04x" , EISA_ID_TO_NUM( Acpi-> HID ) ) ;
    8540:	48 8d 35 79 17 02 00 	lea    0x21779(%rip),%rsi        # 29cc0 <_DYNAMIC+0xbcc0>
    8547:	48 89 ef             	mov    %rbp,%rdi
    854a:	31 c0                	xor    %eax,%eax
    854c:	e8 9f e5 ff ff       	call   6af0 <CatPrint>
                if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    8551:	8b 53 08             	mov    0x8(%rbx),%edx
    8554:	85 d2                	test   %edx,%edx
    8556:	75 58                	jne    85b0 <_DevPathAcpi+0x150>
}
    8558:	48 83 c4 08          	add    $0x8,%rsp
                CatPrint( Str , L")" ) ;
    855c:	48 89 ef             	mov    %rbp,%rdi
    855f:	48 8d 35 ba 15 02 00 	lea    0x215ba(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
    8566:	31 c0                	xor    %eax,%eax
}
    8568:	5b                   	pop    %rbx
    8569:	5d                   	pop    %rbp
                CatPrint( Str , L")" ) ;
    856a:	e9 81 e5 ff ff       	jmp    6af0 <CatPrint>
    856f:	90                   	nop
                CatPrint( Str , L"ParallelPort(%d)" , Acpi-> UID ) ;
    8570:	8b 56 08             	mov    0x8(%rsi),%edx
    8573:	48 8d 35 c6 16 02 00 	lea    0x216c6(%rip),%rsi        # 29c40 <_DYNAMIC+0xbc40>
    857a:	e9 2a ff ff ff       	jmp    84a9 <_DevPathAcpi+0x49>
    857f:	90                   	nop
                CatPrint( Str , L"Floppy(%d)" , Acpi-> UID ) ;
    8580:	8b 56 08             	mov    0x8(%rsi),%edx
    8583:	48 8d 35 ee 16 02 00 	lea    0x216ee(%rip),%rsi        # 29c78 <_DYNAMIC+0xbc78>
    858a:	e9 1a ff ff ff       	jmp    84a9 <_DevPathAcpi+0x49>
    858f:	90                   	nop
        if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    8590:	89 ca                	mov    %ecx,%edx
    8592:	48 8d 35 7f 15 02 00 	lea    0x2157f(%rip),%rsi        # 29b18 <_DYNAMIC+0xbb18>
    8599:	48 89 ef             	mov    %rbp,%rdi
    859c:	31 c0                	xor    %eax,%eax
    859e:	e8 4d e5 ff ff       	call   6af0 <CatPrint>
        CatPrint( Str , L")" , Acpi-> HID , Acpi-> UID ) ;
    85a3:	8b 4b 08             	mov    0x8(%rbx),%ecx
    85a6:	e9 66 ff ff ff       	jmp    8511 <_DevPathAcpi+0xb1>
    85ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                if ( Acpi-> UID ) CatPrint( Str , L",%d" , Acpi-> UID ) ;
    85b0:	48 8d 35 61 15 02 00 	lea    0x21561(%rip),%rsi        # 29b18 <_DYNAMIC+0xbb18>
    85b7:	48 89 ef             	mov    %rbp,%rdi
    85ba:	31 c0                	xor    %eax,%eax
    85bc:	e8 2f e5 ff ff       	call   6af0 <CatPrint>
    85c1:	eb 95                	jmp    8558 <_DevPathAcpi+0xf8>
    85c3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    85ca:	00 00 00 00 
    85ce:	66 90                	xchg   %ax,%ax

00000000000085d0 <_DevPathController>:
{
    85d0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Ctrl(%d)",
    85d4:	8b 56 04             	mov    0x4(%rsi),%edx
    85d7:	31 c0                	xor    %eax,%eax
    85d9:	48 8d 35 0e 17 02 00 	lea    0x2170e(%rip),%rsi        # 29cee <_DYNAMIC+0xbcee>
    85e0:	e9 0b e5 ff ff       	jmp    6af0 <CatPrint>
    85e5:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    85ec:	00 00 00 00 

00000000000085f0 <_DevPathMemMap>:
{
    85f0:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"MemMap(%d,0x%x,0x%x)",
    85f4:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
    85f8:	8b 56 04             	mov    0x4(%rsi),%edx
    85fb:	31 c0                	xor    %eax,%eax
    85fd:	4c 8b 46 10          	mov    0x10(%rsi),%r8
    8601:	48 8d 35 f8 16 02 00 	lea    0x216f8(%rip),%rsi        # 29d00 <_DYNAMIC+0xbd00>
    8608:	e9 e3 e4 ff ff       	jmp    6af0 <CatPrint>
    860d:	0f 1f 00             	nopl   (%rax)

0000000000008610 <_DevPathPccard>:
{
    8610:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Pccard(0x%x)", Pccard-> FunctionNumber );
    8614:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    8618:	31 c0                	xor    %eax,%eax
    861a:	48 8d 35 09 17 02 00 	lea    0x21709(%rip),%rsi        # 29d2a <_DYNAMIC+0xbd2a>
    8621:	e9 ca e4 ff ff       	jmp    6af0 <CatPrint>
    8626:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    862d:	00 00 00 

0000000000008630 <_DevPathPci>:
{
    8630:	f3 0f 1e fa          	endbr64 
    CatPrint(Str, L"Pci(0x%x,0x%x)", Pci->Device, Pci->Function);
    8634:	0f b6 4e 04          	movzbl 0x4(%rsi),%ecx
    8638:	0f b6 56 05          	movzbl 0x5(%rsi),%edx
    863c:	31 c0                	xor    %eax,%eax
    863e:	48 8d 35 ff 16 02 00 	lea    0x216ff(%rip),%rsi        # 29d44 <_DYNAMIC+0xbd44>
    8645:	e9 a6 e4 ff ff       	jmp    6af0 <CatPrint>
    864a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000008650 <_DevPathNodeUnknown>:
static VOID
_DevPathNodeUnknown (
    IN OUT POOL_PRINT       *Str,
    IN VOID                 *DevPath
    )
{
    8650:	f3 0f 1e fa          	endbr64 
    8654:	41 57                	push   %r15
    8656:	49 89 ff             	mov    %rdi,%r15
    8659:	41 56                	push   %r14
    865b:	41 55                	push   %r13
    865d:	41 54                	push   %r12
    865f:	55                   	push   %rbp
    8660:	48 89 f5             	mov    %rsi,%rbp
    8663:	53                   	push   %rbx
    8664:	48 83 ec 08          	sub    $0x8,%rsp
    UINT8 * value ;
    int length , index ;
    Path = DevPath ;
    value = DevPath ;
    value += 4 ;
    switch ( Path-> Type ) {
    8668:	0f b6 16             	movzbl (%rsi),%edx
        case HARDWARE_DEVICE_PATH : { /* Unknown Hardware Device Path */
            CatPrint( Str , L"HardwarePath(%d" , Path-> SubType ) ;
    866b:	44 0f b6 46 01       	movzbl 0x1(%rsi),%r8d
    switch ( Path-> Type ) {
    8670:	80 fa 05             	cmp    $0x5,%dl
    8673:	0f 87 26 01 00 00    	ja     879f <_DevPathNodeUnknown+0x14f>
    8679:	48 8d 0d 7c 17 02 00 	lea    0x2177c(%rip),%rcx        # 29dfc <_DYNAMIC+0xbdfc>
    8680:	0f b6 c2             	movzbl %dl,%eax
    8683:	48 63 04 81          	movslq (%rcx,%rax,4),%rax
    8687:	48 01 c8             	add    %rcx,%rax
    868a:	3e ff e0             	notrack jmp *%rax
    868d:	0f 1f 00             	nopl   (%rax)
        case MEDIA_DEVICE_PATH : { /* Unknown Media Device Path */
            CatPrint( Str , L"MediaPath(%d" , Path-> SubType ) ;
            break ;
        }
        case BBS_DEVICE_PATH : { /* Unknown BIOS Boot Specification Device Path */
            CatPrint( Str , L"BbsPath(%d" , Path-> SubType ) ;
    8690:	44 89 c2             	mov    %r8d,%edx
    8693:	48 8d 35 2e 17 02 00 	lea    0x2172e(%rip),%rsi        # 29dc8 <_DYNAMIC+0xbdc8>
    869a:	31 c0                	xor    %eax,%eax
    869c:	e8 4f e4 ff ff       	call   6af0 <CatPrint>
            break ;
    86a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        default : { /* Unknown Device Path */
            CatPrint( Str , L"Path(%d,%d" , Path-> Type , Path-> SubType ) ;
            break ;
        }
    }
    length = DevicePathNodeLength( Path ) ;
    86a8:	44 0f b7 65 02       	movzwl 0x2(%rbp),%r12d
    for ( index = 0 ; index < length ; index ++ ) {
    86ad:	31 db                	xor    %ebx,%ebx
    86af:	4c 8d 2d 58 14 02 00 	lea    0x21458(%rip),%r13        # 29b0e <_DYNAMIC+0xbb0e>
        if ( index == 0 ) CatPrint( Str , L",0x" ) ;
    86b6:	4c 8d 35 37 17 02 00 	lea    0x21737(%rip),%r14        # 29df4 <_DYNAMIC+0xbdf4>
    for ( index = 0 ; index < length ; index ++ ) {
    86bd:	45 85 e4             	test   %r12d,%r12d
    86c0:	75 2d                	jne    86ef <_DevPathNodeUnknown+0x9f>
    86c2:	e9 b9 00 00 00       	jmp    8780 <_DevPathNodeUnknown+0x130>
    86c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    86ce:	00 00 
        CatPrint( Str , L"%02x" , * value ) ;
    86d0:	0f b6 54 1d 04       	movzbl 0x4(%rbp,%rbx,1),%edx
    86d5:	4c 89 ee             	mov    %r13,%rsi
    86d8:	4c 89 ff             	mov    %r15,%rdi
    86db:	31 c0                	xor    %eax,%eax
    for ( index = 0 ; index < length ; index ++ ) {
    86dd:	48 83 c3 01          	add    $0x1,%rbx
        CatPrint( Str , L"%02x" , * value ) ;
    86e1:	e8 0a e4 ff ff       	call   6af0 <CatPrint>
    for ( index = 0 ; index < length ; index ++ ) {
    86e6:	41 39 dc             	cmp    %ebx,%r12d
    86e9:	0f 8e 91 00 00 00    	jle    8780 <_DevPathNodeUnknown+0x130>
        if ( index == 0 ) CatPrint( Str , L",0x" ) ;
    86ef:	48 85 db             	test   %rbx,%rbx
    86f2:	75 dc                	jne    86d0 <_DevPathNodeUnknown+0x80>
    86f4:	4c 89 f6             	mov    %r14,%rsi
    86f7:	4c 89 ff             	mov    %r15,%rdi
    86fa:	31 c0                	xor    %eax,%eax
    86fc:	e8 ef e3 ff ff       	call   6af0 <CatPrint>
    8701:	eb cd                	jmp    86d0 <_DevPathNodeUnknown+0x80>
    8703:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            CatPrint( Str , L"HardwarePath(%d" , Path-> SubType ) ;
    8708:	44 89 c2             	mov    %r8d,%edx
    870b:	48 8d 35 56 16 02 00 	lea    0x21656(%rip),%rsi        # 29d68 <_DYNAMIC+0xbd68>
    8712:	31 c0                	xor    %eax,%eax
    8714:	e8 d7 e3 ff ff       	call   6af0 <CatPrint>
            break ;
    8719:	eb 8d                	jmp    86a8 <_DevPathNodeUnknown+0x58>
    871b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            CatPrint( Str , L"AcpiPath(%d" , Path-> SubType ) ;
    8720:	44 89 c2             	mov    %r8d,%edx
    8723:	48 8d 35 5e 16 02 00 	lea    0x2165e(%rip),%rsi        # 29d88 <_DYNAMIC+0xbd88>
    872a:	31 c0                	xor    %eax,%eax
    872c:	e8 bf e3 ff ff       	call   6af0 <CatPrint>
            break ;
    8731:	e9 72 ff ff ff       	jmp    86a8 <_DevPathNodeUnknown+0x58>
    8736:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    873d:	00 00 00 
            CatPrint( Str , L"Msg(%d" , Path-> SubType ) ;
    8740:	44 89 c2             	mov    %r8d,%edx
    8743:	48 8d 35 56 16 02 00 	lea    0x21656(%rip),%rsi        # 29da0 <_DYNAMIC+0xbda0>
    874a:	31 c0                	xor    %eax,%eax
    874c:	e8 9f e3 ff ff       	call   6af0 <CatPrint>
            break ;
    8751:	e9 52 ff ff ff       	jmp    86a8 <_DevPathNodeUnknown+0x58>
    8756:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    875d:	00 00 00 
            CatPrint( Str , L"MediaPath(%d" , Path-> SubType ) ;
    8760:	44 89 c2             	mov    %r8d,%edx
    8763:	48 8d 35 44 16 02 00 	lea    0x21644(%rip),%rsi        # 29dae <_DYNAMIC+0xbdae>
    876a:	31 c0                	xor    %eax,%eax
    876c:	e8 7f e3 ff ff       	call   6af0 <CatPrint>
            break ;
    8771:	e9 32 ff ff ff       	jmp    86a8 <_DevPathNodeUnknown+0x58>
    8776:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    877d:	00 00 00 
	value ++ ;
    }
    CatPrint( Str , L")" ) ;
}
    8780:	48 83 c4 08          	add    $0x8,%rsp
    CatPrint( Str , L")" ) ;
    8784:	4c 89 ff             	mov    %r15,%rdi
    8787:	48 8d 35 92 13 02 00 	lea    0x21392(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
    878e:	31 c0                	xor    %eax,%eax
}
    8790:	5b                   	pop    %rbx
    8791:	5d                   	pop    %rbp
    8792:	41 5c                	pop    %r12
    8794:	41 5d                	pop    %r13
    8796:	41 5e                	pop    %r14
    8798:	41 5f                	pop    %r15
    CatPrint( Str , L")" ) ;
    879a:	e9 51 e3 ff ff       	jmp    6af0 <CatPrint>
            CatPrint( Str , L"Path(%d,%d" , Path-> Type , Path-> SubType ) ;
    879f:	44 89 c1             	mov    %r8d,%ecx
    87a2:	48 8d 35 35 16 02 00 	lea    0x21635(%rip),%rsi        # 29dde <_DYNAMIC+0xbdde>
    87a9:	4c 89 ff             	mov    %r15,%rdi
    87ac:	31 c0                	xor    %eax,%eax
    87ae:	e8 3d e3 ff ff       	call   6af0 <CatPrint>
            break ;
    87b3:	e9 f0 fe ff ff       	jmp    86a8 <_DevPathNodeUnknown+0x58>
    87b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    87bf:	00 

00000000000087c0 <_DevPathVendor>:
{
    87c0:	f3 0f 1e fa          	endbr64 
    87c4:	41 54                	push   %r12
    switch (DevicePathType(&Vendor->Header)) {
    87c6:	48 8d 15 4d 16 02 00 	lea    0x2164d(%rip),%rdx        # 29e1a <_DYNAMIC+0xbe1a>
{
    87cd:	55                   	push   %rbp
    87ce:	48 89 fd             	mov    %rdi,%rbp
    87d1:	53                   	push   %rbx
    87d2:	0f b6 06             	movzbl (%rsi),%eax
    87d5:	48 89 f3             	mov    %rsi,%rbx
    87d8:	83 e0 7f             	and    $0x7f,%eax
    switch (DevicePathType(&Vendor->Header)) {
    87db:	3c 03                	cmp    $0x3,%al
    87dd:	74 1f                	je     87fe <_DevPathVendor+0x3e>
    case MEDIA_DEVICE_PATH:     Type = L"Media";     break;
    87df:	48 8d 15 3c 16 02 00 	lea    0x2163c(%rip),%rdx        # 29e22 <_DYNAMIC+0xbe22>
    switch (DevicePathType(&Vendor->Header)) {
    87e6:	3c 04                	cmp    $0x4,%al
    87e8:	74 14                	je     87fe <_DevPathVendor+0x3e>
    case HARDWARE_DEVICE_PATH:  Type = L"Hw";        break;
    87ea:	3c 01                	cmp    $0x1,%al
    87ec:	48 8d 15 b5 11 02 00 	lea    0x211b5(%rip),%rdx        # 299a8 <_DYNAMIC+0xb9a8>
    87f3:	48 8d 05 1a 16 02 00 	lea    0x2161a(%rip),%rax        # 29e14 <_DYNAMIC+0xbe14>
    87fa:	48 0f 44 d0          	cmove  %rax,%rdx
    CatPrint(Str, L"Ven%s(%g", Type, &Vendor->Guid);
    87fe:	4c 8d 63 04          	lea    0x4(%rbx),%r12
    8802:	48 8d 35 25 16 02 00 	lea    0x21625(%rip),%rsi        # 29e2e <_DYNAMIC+0xbe2e>
    8809:	48 89 ef             	mov    %rbp,%rdi
    880c:	31 c0                	xor    %eax,%eax
    880e:	4c 89 e1             	mov    %r12,%rcx
    8811:	e8 da e2 ff ff       	call   6af0 <CatPrint>
    if (CompareGuid (&Vendor->Guid, &UnknownDevice) == 0) {
    8816:	48 8d 35 93 42 01 00 	lea    0x14293(%rip),%rsi        # 1cab0 <UnknownDevice>
    881d:	4c 89 e7             	mov    %r12,%rdi
    8820:	e8 2b 0f 00 00       	call   9750 <CompareGuid>
    8825:	48 85 c0             	test   %rax,%rax
    8828:	75 1e                	jne    8848 <_DevPathVendor+0x88>
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    882a:	0f b6 53 14          	movzbl 0x14(%rbx),%edx
    882e:	48 89 ef             	mov    %rbp,%rdi
}
    8831:	5b                   	pop    %rbx
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    8832:	48 8d 35 07 16 02 00 	lea    0x21607(%rip),%rsi        # 29e40 <_DYNAMIC+0xbe40>
}
    8839:	5d                   	pop    %rbp
    883a:	41 5c                	pop    %r12
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    883c:	e9 af e2 ff ff       	jmp    6af0 <CatPrint>
    8841:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
}
    8848:	5b                   	pop    %rbx
        CatPrint(Str, L")");
    8849:	48 89 ef             	mov    %rbp,%rdi
    884c:	48 8d 35 cd 12 02 00 	lea    0x212cd(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
}
    8853:	5d                   	pop    %rbp
        CatPrint(Str, L")");
    8854:	31 c0                	xor    %eax,%eax
}
    8856:	41 5c                	pop    %r12
        CatPrint(Str, L")");
    8858:	e9 93 e2 ff ff       	jmp    6af0 <CatPrint>
    885d:	0f 1f 00             	nopl   (%rax)

0000000000008860 <_DevPathHardDrive>:
{
    8860:	f3 0f 1e fa          	endbr64 
    switch (Hd->SignatureType) {
    8864:	0f b6 4e 29          	movzbl 0x29(%rsi),%ecx
            CatPrint(Str, L"HD(%d,MBR,0x%08x)",
    8868:	8b 56 04             	mov    0x4(%rsi),%edx
    switch (Hd->SignatureType) {
    886b:	80 f9 01             	cmp    $0x1,%cl
    886e:	74 18                	je     8888 <_DevPathHardDrive+0x28>
    8870:	80 f9 02             	cmp    $0x2,%cl
    8873:	74 2b                	je     88a0 <_DevPathHardDrive+0x40>
            CatPrint(Str, L"HD(%d,%d,0)",
    8875:	48 8d 35 14 16 02 00 	lea    0x21614(%rip),%rsi        # 29e90 <_DYNAMIC+0xbe90>
    887c:	31 c0                	xor    %eax,%eax
    887e:	e9 6d e2 ff ff       	jmp    6af0 <CatPrint>
    8883:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            CatPrint(Str, L"HD(%d,MBR,0x%08x)",
    8888:	8b 4e 18             	mov    0x18(%rsi),%ecx
    888b:	31 c0                	xor    %eax,%eax
    888d:	48 8d 35 bc 15 02 00 	lea    0x215bc(%rip),%rsi        # 29e50 <_DYNAMIC+0xbe50>
    8894:	e9 57 e2 ff ff       	jmp    6af0 <CatPrint>
    8899:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                (EFI_GUID *) &(Hd->Signature[0])
    88a0:	48 8d 4e 18          	lea    0x18(%rsi),%rcx
            CatPrint(Str, L"HD(%d,GPT,%g)",
    88a4:	31 c0                	xor    %eax,%eax
    88a6:	48 8d 35 c7 15 02 00 	lea    0x215c7(%rip),%rsi        # 29e74 <_DYNAMIC+0xbe74>
    88ad:	e9 3e e2 ff ff       	jmp    6af0 <CatPrint>
    88b2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    88b9:	00 00 00 00 
    88bd:	0f 1f 00             	nopl   (%rax)

00000000000088c0 <CatPrintIPv6.isra.0>:
        CatPrintIPv6_ADD( Address-> Addr[ 2 ] , Address-> Addr[ 3 ] ) ,
    88c0:	0f b6 c9             	movzbl %cl,%ecx
CatPrintIPv6(
    88c3:	41 55                	push   %r13
    88c5:	49 89 fa             	mov    %rdi,%r10
        CatPrintIPv6_ADD( Address-> Addr[ 2 ] , Address-> Addr[ 3 ] ) ,
    88c8:	45 0f b6 c0          	movzbl %r8b,%r8d
CatPrintIPv6(
    88cc:	41 54                	push   %r12
        CatPrintIPv6_ADD( Address-> Addr[ 2 ] , Address-> Addr[ 3 ] ) ,
    88ce:	c1 e1 08             	shl    $0x8,%ecx
CatPrintIPv6(
    88d1:	41 89 f4             	mov    %esi,%r12d
        CatPrintIPv6_ADD( Address-> Addr[ 4 ] , Address-> Addr[ 5 ] ) ,
    88d4:	41 0f b6 f1          	movzbl %r9b,%esi
CatPrintIPv6(
    88d8:	55                   	push   %rbp
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    88d9:	44 09 c1             	or     %r8d,%ecx
CatPrintIPv6(
    88dc:	44 0f b6 ea          	movzbl %dl,%r13d
        CatPrintIPv6_ADD( Address-> Addr[ 4 ] , Address-> Addr[ 5 ] ) ,
    88e0:	c1 e6 08             	shl    $0x8,%esi
CatPrintIPv6(
    88e3:	53                   	push   %rbx
        CatPrintIPv6_ADD( Address-> Addr[ 14 ] , Address-> Addr[ 15 ] ) ) ;
    88e4:	0f b6 7c 24 70       	movzbl 0x70(%rsp),%edi
        CatPrintIPv6_ADD( Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ) ,
    88e9:	41 0f b6 d4          	movzbl %r12b,%edx
        CatPrintIPv6_ADD( Address-> Addr[ 14 ] , Address-> Addr[ 15 ] ) ) ;
    88ed:	44 0f b6 44 24 78    	movzbl 0x78(%rsp),%r8d
CatPrintIPv6(
    88f3:	0f b6 44 24 40       	movzbl 0x40(%rsp),%eax
        CatPrintIPv6_ADD( Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ) ,
    88f8:	c1 e2 08             	shl    $0x8,%edx
        CatPrintIPv6_ADD( Address-> Addr[ 14 ] , Address-> Addr[ 15 ] ) ) ;
    88fb:	c1 e7 08             	shl    $0x8,%edi
        CatPrintIPv6_ADD( Address-> Addr[ 6 ] , Address-> Addr[ 7 ] ) ,
    88fe:	0f b6 6c 24 38       	movzbl 0x38(%rsp),%ebp
        CatPrintIPv6_ADD( Address-> Addr[ 4 ] , Address-> Addr[ 5 ] ) ,
    8903:	0f b6 5c 24 28       	movzbl 0x28(%rsp),%ebx
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    8908:	44 09 ea             	or     %r13d,%edx
    890b:	44 09 c7             	or     %r8d,%edi
        CatPrintIPv6_ADD( Address-> Addr[ 12 ] , Address-> Addr[ 13 ] ) ,
    890e:	44 0f b6 44 24 68    	movzbl 0x68(%rsp),%r8d
        CatPrintIPv6_ADD( Address-> Addr[ 6 ] , Address-> Addr[ 7 ] ) ,
    8914:	44 0f b6 5c 24 30    	movzbl 0x30(%rsp),%r11d
        CatPrintIPv6_ADD( Address-> Addr[ 8 ] , Address-> Addr[ 9 ] ) ,
    891a:	c1 e0 08             	shl    $0x8,%eax
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    891d:	89 7c 24 40          	mov    %edi,0x40(%rsp)
        CatPrintIPv6_ADD( Address-> Addr[ 12 ] , Address-> Addr[ 13 ] ) ,
    8921:	0f b6 7c 24 60       	movzbl 0x60(%rsp),%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    8926:	09 de                	or     %ebx,%esi
        CatPrintIPv6_ADD( Address-> Addr[ 6 ] , Address-> Addr[ 7 ] ) ,
    8928:	41 c1 e3 08          	shl    $0x8,%r11d
        CatPrintIPv6_ADD( Address-> Addr[ 12 ] , Address-> Addr[ 13 ] ) ,
    892c:	c1 e7 08             	shl    $0x8,%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    892f:	45 89 d9             	mov    %r11d,%r9d
    8932:	44 09 c7             	or     %r8d,%edi
        CatPrintIPv6_ADD( Address-> Addr[ 10 ] , Address-> Addr[ 11 ] ) ,
    8935:	44 0f b6 44 24 58    	movzbl 0x58(%rsp),%r8d
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    893b:	41 09 e9             	or     %ebp,%r9d
    893e:	89 7c 24 38          	mov    %edi,0x38(%rsp)
        CatPrintIPv6_ADD( Address-> Addr[ 10 ] , Address-> Addr[ 11 ] ) ,
    8942:	0f b6 7c 24 50       	movzbl 0x50(%rsp),%edi
    8947:	c1 e7 08             	shl    $0x8,%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    894a:	44 09 c7             	or     %r8d,%edi
    894d:	41 89 f0             	mov    %esi,%r8d
    8950:	48 8d 35 51 15 02 00 	lea    0x21551(%rip),%rsi        # 29ea8 <_DYNAMIC+0xbea8>
    8957:	89 7c 24 30          	mov    %edi,0x30(%rsp)
        CatPrintIPv6_ADD( Address-> Addr[ 8 ] , Address-> Addr[ 9 ] ) ,
    895b:	0f b6 7c 24 48       	movzbl 0x48(%rsp),%edi
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    8960:	09 f8                	or     %edi,%eax
    8962:	4c 89 d7             	mov    %r10,%rdi
    8965:	89 44 24 28          	mov    %eax,0x28(%rsp)
}
    8969:	5b                   	pop    %rbx
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    896a:	31 c0                	xor    %eax,%eax
}
    896c:	5d                   	pop    %rbp
    896d:	41 5c                	pop    %r12
    896f:	41 5d                	pop    %r13
    CatPrint( Str , L"%x:%x:%x:%x:%x:%x:%x:%x" ,
    8971:	e9 7a e1 ff ff       	jmp    6af0 <CatPrint>
    8976:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    897d:	00 00 00 

0000000000008980 <_DevPathIPv6>:
{
    8980:	f3 0f 1e fa          	endbr64 
    8984:	41 54                	push   %r12
    CatPrint( Str , L"IPv6(") ;
    8986:	31 c0                	xor    %eax,%eax
    CatPrint( Str , L",") ;
    8988:	4c 8d 25 c9 0f 02 00 	lea    0x20fc9(%rip),%r12        # 29958 <_DYNAMIC+0xb958>
{
    898f:	55                   	push   %rbp
    8990:	48 89 fd             	mov    %rdi,%rbp
    8993:	53                   	push   %rbx
    8994:	48 89 f3             	mov    %rsi,%rbx
    CatPrint( Str , L"IPv6(") ;
    8997:	48 8d 35 76 15 02 00 	lea    0x21576(%rip),%rsi        # 29f14 <_DYNAMIC+0xbf14>
{
    899e:	48 83 ec 60          	sub    $0x60,%rsp
    CatPrint( Str , L"IPv6(") ;
    89a2:	e8 49 e1 ff ff       	call   6af0 <CatPrint>
    CatPrintIPv6( Str , & IP-> RemoteIpAddress ) ;
    89a7:	0f b6 43 23          	movzbl 0x23(%rbx),%eax
    89ab:	0f b6 53 15          	movzbl 0x15(%rbx),%edx
    89af:	48 89 ef             	mov    %rbp,%rdi
    89b2:	0f b6 4b 16          	movzbl 0x16(%rbx),%ecx
    89b6:	0f b6 73 14          	movzbl 0x14(%rbx),%esi
    89ba:	44 0f b6 4b 18       	movzbl 0x18(%rbx),%r9d
    89bf:	44 0f b6 43 17       	movzbl 0x17(%rbx),%r8d
    89c4:	88 44 24 50          	mov    %al,0x50(%rsp)
    89c8:	0f b6 43 22          	movzbl 0x22(%rbx),%eax
    89cc:	88 44 24 48          	mov    %al,0x48(%rsp)
    89d0:	0f b6 43 21          	movzbl 0x21(%rbx),%eax
    89d4:	88 44 24 40          	mov    %al,0x40(%rsp)
    89d8:	0f b6 43 20          	movzbl 0x20(%rbx),%eax
    89dc:	88 44 24 38          	mov    %al,0x38(%rsp)
    89e0:	0f b6 43 1f          	movzbl 0x1f(%rbx),%eax
    89e4:	88 44 24 30          	mov    %al,0x30(%rsp)
    89e8:	0f b6 43 1e          	movzbl 0x1e(%rbx),%eax
    89ec:	88 44 24 28          	mov    %al,0x28(%rsp)
    89f0:	0f b6 43 1d          	movzbl 0x1d(%rbx),%eax
    89f4:	88 44 24 20          	mov    %al,0x20(%rsp)
    89f8:	0f b6 43 1c          	movzbl 0x1c(%rbx),%eax
    89fc:	88 44 24 18          	mov    %al,0x18(%rsp)
    8a00:	0f b6 43 1b          	movzbl 0x1b(%rbx),%eax
    8a04:	88 44 24 10          	mov    %al,0x10(%rsp)
    8a08:	0f b6 43 1a          	movzbl 0x1a(%rbx),%eax
    8a0c:	88 44 24 08          	mov    %al,0x8(%rsp)
    8a10:	0f b6 43 19          	movzbl 0x19(%rbx),%eax
    8a14:	88 04 24             	mov    %al,(%rsp)
    8a17:	e8 a4 fe ff ff       	call   88c0 <CatPrintIPv6.isra.0>
    CatPrint( Str , L",") ;
    8a1c:	4c 89 e6             	mov    %r12,%rsi
    8a1f:	48 89 ef             	mov    %rbp,%rdi
    8a22:	31 c0                	xor    %eax,%eax
    8a24:	e8 c7 e0 ff ff       	call   6af0 <CatPrint>
    CatPrintNetworkProtocol( Str, IP-> Protocol ) ;
    8a29:	0f b7 53 28          	movzwl 0x28(%rbx),%edx
    if ( Proto == 6 ) {
    8a2d:	66 83 fa 06          	cmp    $0x6,%dx
    8a31:	0f 84 f9 00 00 00    	je     8b30 <_DevPathIPv6+0x1b0>
    } else if ( Proto == 17 ) {
    8a37:	66 83 fa 11          	cmp    $0x11,%dx
    8a3b:	0f 84 cf 00 00 00    	je     8b10 <_DevPathIPv6+0x190>
        CatPrint( Str , L"%d" , Proto ) ;
    8a41:	48 8d 35 e8 14 02 00 	lea    0x214e8(%rip),%rsi        # 29f30 <_DYNAMIC+0xbf30>
    8a48:	48 89 ef             	mov    %rbp,%rdi
    8a4b:	31 c0                	xor    %eax,%eax
    8a4d:	e8 9e e0 ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L",%s," , IP-> IPAddressOrigin ?
    8a52:	80 7b 2a 00          	cmpb   $0x0,0x2a(%rbx)
    8a56:	48 8d 05 7b 14 02 00 	lea    0x2147b(%rip),%rax        # 29ed8 <_DYNAMIC+0xbed8>
    8a5d:	48 89 ef             	mov    %rbp,%rdi
    8a60:	48 8d 15 9f 14 02 00 	lea    0x2149f(%rip),%rdx        # 29f06 <_DYNAMIC+0xbf06>
    8a67:	48 8d 35 c8 14 02 00 	lea    0x214c8(%rip),%rsi        # 29f36 <_DYNAMIC+0xbf36>
    8a6e:	48 0f 45 d0          	cmovne %rax,%rdx
    8a72:	31 c0                	xor    %eax,%eax
    8a74:	e8 77 e0 ff ff       	call   6af0 <CatPrint>
    CatPrintIPv6( Str , & IP-> LocalIpAddress ) ;
    8a79:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    8a7d:	0f b6 4b 06          	movzbl 0x6(%rbx),%ecx
    8a81:	48 89 ef             	mov    %rbp,%rdi
    8a84:	0f b6 53 05          	movzbl 0x5(%rbx),%edx
    8a88:	0f b6 73 04          	movzbl 0x4(%rbx),%esi
    8a8c:	44 0f b6 4b 08       	movzbl 0x8(%rbx),%r9d
    8a91:	44 0f b6 43 07       	movzbl 0x7(%rbx),%r8d
    8a96:	88 44 24 50          	mov    %al,0x50(%rsp)
    8a9a:	0f b6 43 12          	movzbl 0x12(%rbx),%eax
    8a9e:	88 44 24 48          	mov    %al,0x48(%rsp)
    8aa2:	0f b6 43 11          	movzbl 0x11(%rbx),%eax
    8aa6:	88 44 24 40          	mov    %al,0x40(%rsp)
    8aaa:	0f b6 43 10          	movzbl 0x10(%rbx),%eax
    8aae:	88 44 24 38          	mov    %al,0x38(%rsp)
    8ab2:	0f b6 43 0f          	movzbl 0xf(%rbx),%eax
    8ab6:	88 44 24 30          	mov    %al,0x30(%rsp)
    8aba:	0f b6 43 0e          	movzbl 0xe(%rbx),%eax
    8abe:	88 44 24 28          	mov    %al,0x28(%rsp)
    8ac2:	0f b6 43 0d          	movzbl 0xd(%rbx),%eax
    8ac6:	88 44 24 20          	mov    %al,0x20(%rsp)
    8aca:	0f b6 43 0c          	movzbl 0xc(%rbx),%eax
    8ace:	88 44 24 18          	mov    %al,0x18(%rsp)
    8ad2:	0f b6 43 0b          	movzbl 0xb(%rbx),%eax
    8ad6:	88 44 24 10          	mov    %al,0x10(%rsp)
    8ada:	0f b6 43 0a          	movzbl 0xa(%rbx),%eax
    8ade:	88 44 24 08          	mov    %al,0x8(%rsp)
    8ae2:	0f b6 43 09          	movzbl 0x9(%rbx),%eax
    8ae6:	88 04 24             	mov    %al,(%rsp)
    8ae9:	e8 d2 fd ff ff       	call   88c0 <CatPrintIPv6.isra.0>
    if ( DevicePathNodeLength( & IP-> Header ) == sizeof( IPv6_DEVICE_PATH ) ) {
    8aee:	66 83 7b 02 3c       	cmpw   $0x3c,0x2(%rbx)
    8af3:	74 5b                	je     8b50 <_DevPathIPv6+0x1d0>
}
    8af5:	48 83 c4 60          	add    $0x60,%rsp
    CatPrint( Str , L")") ;
    8af9:	48 89 ef             	mov    %rbp,%rdi
    8afc:	48 8d 35 1d 10 02 00 	lea    0x2101d(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
    8b03:	31 c0                	xor    %eax,%eax
}
    8b05:	5b                   	pop    %rbx
    8b06:	5d                   	pop    %rbp
    8b07:	41 5c                	pop    %r12
    CatPrint( Str , L")") ;
    8b09:	e9 e2 df ff ff       	jmp    6af0 <CatPrint>
    8b0e:	66 90                	xchg   %ax,%ax
        CatPrint( Str , L"UDP" ) ;
    8b10:	48 8d 35 11 14 02 00 	lea    0x21411(%rip),%rsi        # 29f28 <_DYNAMIC+0xbf28>
    8b17:	48 89 ef             	mov    %rbp,%rdi
    8b1a:	31 c0                	xor    %eax,%eax
    8b1c:	e8 cf df ff ff       	call   6af0 <CatPrint>
    8b21:	e9 2c ff ff ff       	jmp    8a52 <_DevPathIPv6+0xd2>
    8b26:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    8b2d:	00 00 00 
        CatPrint( Str , L"TCP" ) ;
    8b30:	48 8d 35 e9 13 02 00 	lea    0x213e9(%rip),%rsi        # 29f20 <_DYNAMIC+0xbf20>
    8b37:	48 89 ef             	mov    %rbp,%rdi
    8b3a:	31 c0                	xor    %eax,%eax
    8b3c:	e8 af df ff ff       	call   6af0 <CatPrint>
    8b41:	e9 0c ff ff ff       	jmp    8a52 <_DevPathIPv6+0xd2>
    8b46:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    8b4d:	00 00 00 
        CatPrint( Str , L",") ;
    8b50:	4c 89 e6             	mov    %r12,%rsi
    8b53:	48 89 ef             	mov    %rbp,%rdi
    8b56:	31 c0                	xor    %eax,%eax
    8b58:	e8 93 df ff ff       	call   6af0 <CatPrint>
        CatPrintIPv6( Str , & IP-> GatewayIpAddress ) ;
    8b5d:	0f b6 43 3b          	movzbl 0x3b(%rbx),%eax
    8b61:	0f b6 53 2d          	movzbl 0x2d(%rbx),%edx
    8b65:	48 89 ef             	mov    %rbp,%rdi
    8b68:	0f b6 4b 2e          	movzbl 0x2e(%rbx),%ecx
    8b6c:	0f b6 73 2c          	movzbl 0x2c(%rbx),%esi
    8b70:	44 0f b6 4b 30       	movzbl 0x30(%rbx),%r9d
    8b75:	44 0f b6 43 2f       	movzbl 0x2f(%rbx),%r8d
    8b7a:	88 44 24 50          	mov    %al,0x50(%rsp)
    8b7e:	0f b6 43 3a          	movzbl 0x3a(%rbx),%eax
    8b82:	88 44 24 48          	mov    %al,0x48(%rsp)
    8b86:	0f b6 43 39          	movzbl 0x39(%rbx),%eax
    8b8a:	88 44 24 40          	mov    %al,0x40(%rsp)
    8b8e:	0f b6 43 38          	movzbl 0x38(%rbx),%eax
    8b92:	88 44 24 38          	mov    %al,0x38(%rsp)
    8b96:	0f b6 43 37          	movzbl 0x37(%rbx),%eax
    8b9a:	88 44 24 30          	mov    %al,0x30(%rsp)
    8b9e:	0f b6 43 36          	movzbl 0x36(%rbx),%eax
    8ba2:	88 44 24 28          	mov    %al,0x28(%rsp)
    8ba6:	0f b6 43 35          	movzbl 0x35(%rbx),%eax
    8baa:	88 44 24 20          	mov    %al,0x20(%rsp)
    8bae:	0f b6 43 34          	movzbl 0x34(%rbx),%eax
    8bb2:	88 44 24 18          	mov    %al,0x18(%rsp)
    8bb6:	0f b6 43 33          	movzbl 0x33(%rbx),%eax
    8bba:	88 44 24 10          	mov    %al,0x10(%rsp)
    8bbe:	0f b6 43 32          	movzbl 0x32(%rbx),%eax
    8bc2:	88 44 24 08          	mov    %al,0x8(%rsp)
    8bc6:	0f b6 43 31          	movzbl 0x31(%rbx),%eax
    8bca:	88 04 24             	mov    %al,(%rsp)
    8bcd:	e8 ee fc ff ff       	call   88c0 <CatPrintIPv6.isra.0>
        CatPrint( Str , L",") ;
    8bd2:	4c 89 e6             	mov    %r12,%rsi
    8bd5:	48 89 ef             	mov    %rbp,%rdi
    8bd8:	31 c0                	xor    %eax,%eax
    8bda:	e8 11 df ff ff       	call   6af0 <CatPrint>
        CatPrint( Str , L"%d" , & IP-> PrefixLength ) ;
    8bdf:	48 8d 53 2b          	lea    0x2b(%rbx),%rdx
    8be3:	48 89 ef             	mov    %rbp,%rdi
    8be6:	31 c0                	xor    %eax,%eax
    8be8:	48 8d 35 41 13 02 00 	lea    0x21341(%rip),%rsi        # 29f30 <_DYNAMIC+0xbf30>
    8bef:	e8 fc de ff ff       	call   6af0 <CatPrint>
    8bf4:	e9 fc fe ff ff       	jmp    8af5 <_DevPathIPv6+0x175>
    8bf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000008c00 <_DevPathIPv4>:
{
    8c00:	f3 0f 1e fa          	endbr64 
    8c04:	41 55                	push   %r13
    CatPrint( Str , L"IPv4(") ;
    8c06:	31 c0                	xor    %eax,%eax
    CatPrint( Str , L",") ;
    8c08:	4c 8d 2d 49 0d 02 00 	lea    0x20d49(%rip),%r13        # 29958 <_DYNAMIC+0xb958>
{
    8c0f:	41 54                	push   %r12
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    8c11:	4c 8d 25 3e 13 02 00 	lea    0x2133e(%rip),%r12        # 29f56 <_DYNAMIC+0xbf56>
{
    8c18:	55                   	push   %rbp
    8c19:	48 89 fd             	mov    %rdi,%rbp
    8c1c:	53                   	push   %rbx
    8c1d:	48 89 f3             	mov    %rsi,%rbx
    CatPrint( Str , L"IPv4(") ;
    8c20:	48 8d 35 23 13 02 00 	lea    0x21323(%rip),%rsi        # 29f4a <_DYNAMIC+0xbf4a>
{
    8c27:	48 83 ec 08          	sub    $0x8,%rsp
    CatPrint( Str , L"IPv4(") ;
    8c2b:	e8 c0 de ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    8c30:	0f b6 53 08          	movzbl 0x8(%rbx),%edx
    8c34:	0f b6 4b 09          	movzbl 0x9(%rbx),%ecx
    8c38:	4c 89 e6             	mov    %r12,%rsi
    8c3b:	44 0f b6 4b 0b       	movzbl 0xb(%rbx),%r9d
    8c40:	44 0f b6 43 0a       	movzbl 0xa(%rbx),%r8d
    8c45:	48 89 ef             	mov    %rbp,%rdi
    8c48:	31 c0                	xor    %eax,%eax
    8c4a:	e8 a1 de ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L",") ;
    8c4f:	4c 89 ee             	mov    %r13,%rsi
    8c52:	48 89 ef             	mov    %rbp,%rdi
    8c55:	31 c0                	xor    %eax,%eax
    8c57:	e8 94 de ff ff       	call   6af0 <CatPrint>
    CatPrintNetworkProtocol( Str , IP-> Protocol ) ;
    8c5c:	0f b7 53 10          	movzwl 0x10(%rbx),%edx
    if ( Proto == 6 ) {
    8c60:	66 83 fa 06          	cmp    $0x6,%dx
    8c64:	0f 84 e6 00 00 00    	je     8d50 <_DevPathIPv4+0x150>
    } else if ( Proto == 17 ) {
    8c6a:	66 83 fa 11          	cmp    $0x11,%dx
    8c6e:	0f 84 c4 00 00 00    	je     8d38 <_DevPathIPv4+0x138>
        CatPrint( Str , L"%d" , Proto ) ;
    8c74:	48 8d 35 b5 12 02 00 	lea    0x212b5(%rip),%rsi        # 29f30 <_DYNAMIC+0xbf30>
    8c7b:	48 89 ef             	mov    %rbp,%rdi
    8c7e:	31 c0                	xor    %eax,%eax
    8c80:	e8 6b de ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L",%s" , IP-> StaticIpAddress ? L"Static" : L"DHCP" ) ;
    8c85:	80 7b 12 00          	cmpb   $0x0,0x12(%rbx)
    8c89:	48 8d 05 b0 12 02 00 	lea    0x212b0(%rip),%rax        # 29f40 <_DYNAMIC+0xbf40>
    8c90:	48 89 ef             	mov    %rbp,%rdi
    8c93:	48 8d 15 6c 12 02 00 	lea    0x2126c(%rip),%rdx        # 29f06 <_DYNAMIC+0xbf06>
    8c9a:	48 8d 35 cd 12 02 00 	lea    0x212cd(%rip),%rsi        # 29f6e <_DYNAMIC+0xbf6e>
    8ca1:	48 0f 44 d0          	cmove  %rax,%rdx
    8ca5:	31 c0                	xor    %eax,%eax
    8ca7:	e8 44 de ff ff       	call   6af0 <CatPrint>
    val |= Address-> Addr[ 2 ] | Address-> Addr[ 3 ] ;
    8cac:	0f b6 43 05          	movzbl 0x5(%rbx),%eax
    8cb0:	0a 43 04             	or     0x4(%rbx),%al
    8cb3:	0a 43 06             	or     0x6(%rbx),%al
    if ( ! show && DevicePathNodeLength( & IP-> Header ) == sizeof( IPv4_DEVICE_PATH ) ) {
    8cb6:	0a 43 07             	or     0x7(%rbx),%al
    8cb9:	74 55                	je     8d10 <_DevPathIPv4+0x110>
        CatPrint( Str , L"," ) ;
    8cbb:	4c 89 ee             	mov    %r13,%rsi
    8cbe:	48 89 ef             	mov    %rbp,%rdi
    8cc1:	31 c0                	xor    %eax,%eax
    8cc3:	e8 28 de ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    8cc8:	0f b6 4b 05          	movzbl 0x5(%rbx),%ecx
    8ccc:	0f b6 53 04          	movzbl 0x4(%rbx),%edx
    8cd0:	31 c0                	xor    %eax,%eax
    8cd2:	44 0f b6 4b 07       	movzbl 0x7(%rbx),%r9d
    8cd7:	44 0f b6 43 06       	movzbl 0x6(%rbx),%r8d
    8cdc:	4c 89 e6             	mov    %r12,%rsi
    8cdf:	48 89 ef             	mov    %rbp,%rdi
    8ce2:	e8 09 de ff ff       	call   6af0 <CatPrint>
        if ( DevicePathNodeLength( & IP-> Header ) == sizeof( IPv4_DEVICE_PATH ) ) {
    8ce7:	66 83 7b 02 1c       	cmpw   $0x1c,0x2(%rbx)
    8cec:	0f 84 7e 00 00 00    	je     8d70 <_DevPathIPv4+0x170>
}
    8cf2:	48 83 c4 08          	add    $0x8,%rsp
    CatPrint( Str , L")") ;
    8cf6:	48 89 ef             	mov    %rbp,%rdi
    8cf9:	48 8d 35 20 0e 02 00 	lea    0x20e20(%rip),%rsi        # 29b20 <_DYNAMIC+0xbb20>
    8d00:	31 c0                	xor    %eax,%eax
}
    8d02:	5b                   	pop    %rbx
    8d03:	5d                   	pop    %rbp
    8d04:	41 5c                	pop    %r12
    8d06:	41 5d                	pop    %r13
    CatPrint( Str , L")") ;
    8d08:	e9 e3 dd ff ff       	jmp    6af0 <CatPrint>
    8d0d:	0f 1f 00             	nopl   (%rax)
    if ( ! show && DevicePathNodeLength( & IP-> Header ) == sizeof( IPv4_DEVICE_PATH ) ) {
    8d10:	66 83 7b 02 1c       	cmpw   $0x1c,0x2(%rbx)
    8d15:	75 db                	jne    8cf2 <_DevPathIPv4+0xf2>
    if ( show ) {
    8d17:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    8d1b:	0a 43 14             	or     0x14(%rbx),%al
    8d1e:	0a 43 15             	or     0x15(%rbx),%al
    8d21:	0a 43 16             	or     0x16(%rbx),%al
    8d24:	0a 43 17             	or     0x17(%rbx),%al
    8d27:	0a 43 18             	or     0x18(%rbx),%al
    8d2a:	0a 43 19             	or     0x19(%rbx),%al
    8d2d:	0a 43 1a             	or     0x1a(%rbx),%al
    8d30:	74 c0                	je     8cf2 <_DevPathIPv4+0xf2>
    8d32:	eb 87                	jmp    8cbb <_DevPathIPv4+0xbb>
    8d34:	0f 1f 40 00          	nopl   0x0(%rax)
        CatPrint( Str , L"UDP" ) ;
    8d38:	48 8d 35 e9 11 02 00 	lea    0x211e9(%rip),%rsi        # 29f28 <_DYNAMIC+0xbf28>
    8d3f:	48 89 ef             	mov    %rbp,%rdi
    8d42:	31 c0                	xor    %eax,%eax
    8d44:	e8 a7 dd ff ff       	call   6af0 <CatPrint>
    8d49:	e9 37 ff ff ff       	jmp    8c85 <_DevPathIPv4+0x85>
    8d4e:	66 90                	xchg   %ax,%ax
        CatPrint( Str , L"TCP" ) ;
    8d50:	48 8d 35 c9 11 02 00 	lea    0x211c9(%rip),%rsi        # 29f20 <_DYNAMIC+0xbf20>
    8d57:	48 89 ef             	mov    %rbp,%rdi
    8d5a:	31 c0                	xor    %eax,%eax
    8d5c:	e8 8f dd ff ff       	call   6af0 <CatPrint>
    8d61:	e9 1f ff ff ff       	jmp    8c85 <_DevPathIPv4+0x85>
    8d66:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    8d6d:	00 00 00 
            if ( show ) {
    8d70:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    8d74:	0a 43 14             	or     0x14(%rbx),%al
    8d77:	0a 43 15             	or     0x15(%rbx),%al
    8d7a:	0a 43 16             	or     0x16(%rbx),%al
    8d7d:	0a 43 17             	or     0x17(%rbx),%al
    8d80:	0a 43 18             	or     0x18(%rbx),%al
    8d83:	0a 43 19             	or     0x19(%rbx),%al
    8d86:	0a 43 1a             	or     0x1a(%rbx),%al
    8d89:	0f 84 63 ff ff ff    	je     8cf2 <_DevPathIPv4+0xf2>
                CatPrint( Str , L",") ;
    8d8f:	4c 89 ee             	mov    %r13,%rsi
    8d92:	48 89 ef             	mov    %rbp,%rdi
    8d95:	31 c0                	xor    %eax,%eax
    8d97:	e8 54 dd ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    8d9c:	0f b6 4b 14          	movzbl 0x14(%rbx),%ecx
    8da0:	0f b6 53 13          	movzbl 0x13(%rbx),%edx
    8da4:	31 c0                	xor    %eax,%eax
    8da6:	44 0f b6 4b 16       	movzbl 0x16(%rbx),%r9d
    8dab:	44 0f b6 43 15       	movzbl 0x15(%rbx),%r8d
    8db0:	4c 89 e6             	mov    %r12,%rsi
    8db3:	48 89 ef             	mov    %rbp,%rdi
    8db6:	e8 35 dd ff ff       	call   6af0 <CatPrint>
    val |= Address-> Addr[ 2 ] | Address-> Addr[ 3 ] ;
    8dbb:	0f b6 43 17          	movzbl 0x17(%rbx),%eax
    8dbf:	0a 43 18             	or     0x18(%rbx),%al
    8dc2:	0a 43 19             	or     0x19(%rbx),%al
                if ( IsNotNullIPv4( & IP-> SubnetMask ) ) {
    8dc5:	0a 43 1a             	or     0x1a(%rbx),%al
    8dc8:	0f 84 24 ff ff ff    	je     8cf2 <_DevPathIPv4+0xf2>
                    CatPrint( Str , L",") ;
    8dce:	4c 89 ee             	mov    %r13,%rsi
    8dd1:	48 89 ef             	mov    %rbp,%rdi
    8dd4:	31 c0                	xor    %eax,%eax
    8dd6:	e8 15 dd ff ff       	call   6af0 <CatPrint>
    CatPrint( Str , L"%d.%d.%d.%d" , Address-> Addr[ 0 ] , Address-> Addr[ 1 ] ,
    8ddb:	0f b6 4b 18          	movzbl 0x18(%rbx),%ecx
    8ddf:	0f b6 53 17          	movzbl 0x17(%rbx),%edx
    8de3:	4c 89 e6             	mov    %r12,%rsi
    8de6:	44 0f b6 4b 1a       	movzbl 0x1a(%rbx),%r9d
    8deb:	44 0f b6 43 19       	movzbl 0x19(%rbx),%r8d
    8df0:	48 89 ef             	mov    %rbp,%rdi
    8df3:	31 c0                	xor    %eax,%eax
    8df5:	e8 f6 dc ff ff       	call   6af0 <CatPrint>
}
    8dfa:	e9 f3 fe ff ff       	jmp    8cf2 <_DevPathIPv4+0xf2>
    8dff:	90                   	nop

0000000000008e00 <DevicePathFromHandle>:
{
    8e00:	f3 0f 1e fa          	endbr64 
    8e04:	48 83 ec 38          	sub    $0x38,%rsp
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    8e08:	48 8b 05 21 48 01 00 	mov    0x14821(%rip),%rax        # 1d630 <BS>
{
    8e0f:	48 89 f9             	mov    %rdi,%rcx
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    8e12:	48 8d 15 d7 3f 01 00 	lea    0x13fd7(%rip),%rdx        # 1cdf0 <gEfiDevicePathProtocolGuid>
    8e19:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    8e1e:	ff 90 98 00 00 00    	call   *0x98(%rax)
    return DevicePath;
    8e24:	48 85 c0             	test   %rax,%rax
    8e27:	b8 00 00 00 00       	mov    $0x0,%eax
    8e2c:	48 0f 49 44 24 28    	cmovns 0x28(%rsp),%rax
}
    8e32:	48 83 c4 38          	add    $0x38,%rsp
    8e36:	c3                   	ret    
    8e37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    8e3e:	00 00 

0000000000008e40 <DevicePathInstance>:
{
    8e40:	f3 0f 1e fa          	endbr64 
    8e44:	41 57                	push   %r15
    8e46:	41 56                	push   %r14
    8e48:	41 55                	push   %r13
    8e4a:	41 54                	push   %r12
    8e4c:	55                   	push   %rbp
    8e4d:	53                   	push   %rbx
    8e4e:	48 83 ec 08          	sub    $0x8,%rsp
    DevPath = *DevicePath;
    8e52:	4c 8b 27             	mov    (%rdi),%r12
    if (!DevPath) {
    8e55:	4d 85 e4             	test   %r12,%r12
    8e58:	74 58                	je     8eb2 <DevicePathInstance+0x72>
        if (IsDevicePathEndType(DevPath)) {
    8e5a:	41 0f b6 04 24       	movzbl (%r12),%eax
        Next = NextDevicePathNode(DevPath);
    8e5f:	41 0f b7 5c 24 02    	movzwl 0x2(%r12),%ebx
    8e65:	49 89 fd             	mov    %rdi,%r13
    8e68:	49 89 f6             	mov    %rsi,%r14
        if (IsDevicePathEndType(DevPath)) {
    8e6b:	83 e0 7f             	and    $0x7f,%eax
        Next = NextDevicePathNode(DevPath);
    8e6e:	4c 01 e3             	add    %r12,%rbx
        if (IsDevicePathEndType(DevPath)) {
    8e71:	3c 7f                	cmp    $0x7f,%al
    8e73:	74 66                	je     8edb <DevicePathInstance+0x9b>
    8e75:	ba 01 02 00 00       	mov    $0x201,%edx
    8e7a:	eb 0a                	jmp    8e86 <DevicePathInstance+0x46>
    8e7c:	0f 1f 40 00          	nopl   0x0(%rax)
        if (Count > 01000) {
    8e80:	48 83 ea 01          	sub    $0x1,%rdx
    8e84:	74 3e                	je     8ec4 <DevicePathInstance+0x84>
        Next = NextDevicePathNode(DevPath);
    8e86:	0f b7 43 02          	movzwl 0x2(%rbx),%eax
    8e8a:	48 89 dd             	mov    %rbx,%rbp
    8e8d:	48 01 c3             	add    %rax,%rbx
        if (IsDevicePathEndType(DevPath)) {
    8e90:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
    8e94:	83 e0 7f             	and    $0x7f,%eax
    8e97:	3c 7f                	cmp    $0x7f,%al
    8e99:	75 e5                	jne    8e80 <DevicePathInstance+0x40>
            DumpHex (0, 0, ((UINT8 *) DevPath) - ((UINT8 *) Start), Start);
    8e9b:	49 89 ef             	mov    %rbp,%r15
    8e9e:	4d 29 e7             	sub    %r12,%r15
        Next = NULL;
    8ea1:	31 c0                	xor    %eax,%eax
    8ea3:	80 7d 01 ff          	cmpb   $0xff,0x1(%rbp)
    8ea7:	48 0f 44 d8          	cmove  %rax,%rbx
    *DevicePath = Next;
    8eab:	49 89 5d 00          	mov    %rbx,0x0(%r13)
    *Size = ((UINT8 *) DevPath) - ((UINT8 *) Start);
    8eaf:	4d 89 3e             	mov    %r15,(%r14)
}
    8eb2:	48 83 c4 08          	add    $0x8,%rsp
    8eb6:	4c 89 e0             	mov    %r12,%rax
    8eb9:	5b                   	pop    %rbx
    8eba:	5d                   	pop    %rbp
    8ebb:	41 5c                	pop    %r12
    8ebd:	41 5d                	pop    %r13
    8ebf:	41 5e                	pop    %r14
    8ec1:	41 5f                	pop    %r15
    8ec3:	c3                   	ret    
            DumpHex (0, 0, ((UINT8 *) DevPath) - ((UINT8 *) Start), Start);
    8ec4:	49 89 ef             	mov    %rbp,%r15
    8ec7:	4c 89 e1             	mov    %r12,%rcx
    8eca:	31 f6                	xor    %esi,%esi
    8ecc:	31 ff                	xor    %edi,%edi
    8ece:	4d 29 e7             	sub    %r12,%r15
    8ed1:	4c 89 fa             	mov    %r15,%rdx
    8ed4:	e8 c7 e3 ff ff       	call   72a0 <DumpHex>
            break;
    8ed9:	eb c6                	jmp    8ea1 <DevicePathInstance+0x61>
        if (IsDevicePathEndType(DevPath)) {
    8edb:	4c 89 e5             	mov    %r12,%rbp
    8ede:	45 31 ff             	xor    %r15d,%r15d
    8ee1:	eb be                	jmp    8ea1 <DevicePathInstance+0x61>
    8ee3:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8eea:	00 00 00 00 
    8eee:	66 90                	xchg   %ax,%ax

0000000000008ef0 <DevicePathInstanceCount>:
{
    8ef0:	f3 0f 1e fa          	endbr64 
    8ef4:	41 54                	push   %r12
    Count = 0;
    8ef6:	45 31 e4             	xor    %r12d,%r12d
{
    8ef9:	55                   	push   %rbp
    8efa:	53                   	push   %rbx
    8efb:	48 83 ec 20          	sub    $0x20,%rsp
    8eff:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
    8f04:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
    8f09:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
    while (DevicePathInstance(&DevicePath, &Size)) {
    8f0e:	eb 04                	jmp    8f14 <DevicePathInstanceCount+0x24>
        Count += 1;
    8f10:	49 83 c4 01          	add    $0x1,%r12
    while (DevicePathInstance(&DevicePath, &Size)) {
    8f14:	48 89 ee             	mov    %rbp,%rsi
    8f17:	48 89 df             	mov    %rbx,%rdi
    8f1a:	e8 21 ff ff ff       	call   8e40 <DevicePathInstance>
    8f1f:	48 85 c0             	test   %rax,%rax
    8f22:	75 ec                	jne    8f10 <DevicePathInstanceCount+0x20>
}
    8f24:	48 83 c4 20          	add    $0x20,%rsp
    8f28:	4c 89 e0             	mov    %r12,%rax
    8f2b:	5b                   	pop    %rbx
    8f2c:	5d                   	pop    %rbp
    8f2d:	41 5c                	pop    %r12
    8f2f:	c3                   	ret    

0000000000008f30 <DevicePathSize>:
{
    8f30:	f3 0f 1e fa          	endbr64 
    while (!IsDevicePathEnd(DevPath)) {
    8f34:	48 89 f8             	mov    %rdi,%rax
    8f37:	eb 0e                	jmp    8f47 <DevicePathSize+0x17>
    8f39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        DevPath = NextDevicePathNode(DevPath);
    8f40:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    8f44:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    8f47:	0f b6 10             	movzbl (%rax),%edx
    8f4a:	83 e2 7f             	and    $0x7f,%edx
    8f4d:	80 fa 7f             	cmp    $0x7f,%dl
    8f50:	75 ee                	jne    8f40 <DevicePathSize+0x10>
    8f52:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    8f56:	75 e8                	jne    8f40 <DevicePathSize+0x10>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    8f58:	48 29 f8             	sub    %rdi,%rax
    8f5b:	48 83 c0 04          	add    $0x4,%rax
}
    8f5f:	c3                   	ret    

0000000000008f60 <DuplicateDevicePath>:
{
    8f60:	f3 0f 1e fa          	endbr64 
    8f64:	41 55                	push   %r13
    8f66:	48 89 f8             	mov    %rdi,%rax
    8f69:	49 89 fd             	mov    %rdi,%r13
    8f6c:	41 54                	push   %r12
    8f6e:	53                   	push   %rbx
    8f6f:	48 83 ec 20          	sub    $0x20,%rsp
    8f73:	eb 0a                	jmp    8f7f <DuplicateDevicePath+0x1f>
    8f75:	0f 1f 00             	nopl   (%rax)
        DevPath = NextDevicePathNode(DevPath);
    8f78:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
    8f7c:	48 01 c8             	add    %rcx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    8f7f:	0f b6 08             	movzbl (%rax),%ecx
    8f82:	83 e1 7f             	and    $0x7f,%ecx
    8f85:	80 f9 7f             	cmp    $0x7f,%cl
    8f88:	75 ee                	jne    8f78 <DuplicateDevicePath+0x18>
    8f8a:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    8f8e:	75 e8                	jne    8f78 <DuplicateDevicePath+0x18>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    8f90:	4c 29 e8             	sub    %r13,%rax
    8f93:	48 8d 58 04          	lea    0x4(%rax),%rbx
    NewDevPath = AllocatePool (Size);
    8f97:	48 89 df             	mov    %rbx,%rdi
    8f9a:	e8 a1 b8 ff ff       	call   4840 <AllocatePool>
    8f9f:	49 89 c4             	mov    %rax,%r12
    if (NewDevPath) {
    8fa2:	48 85 c0             	test   %rax,%rax
    8fa5:	74 0e                	je     8fb5 <DuplicateDevicePath+0x55>
        CopyMem (NewDevPath, DevPath, Size);
    8fa7:	49 89 d8             	mov    %rbx,%r8
    8faa:	4c 89 ea             	mov    %r13,%rdx
    8fad:	48 89 c1             	mov    %rax,%rcx
    8fb0:	e8 8b ba ff ff       	call   4a40 <CopyMem>
}
    8fb5:	48 83 c4 20          	add    $0x20,%rsp
    8fb9:	4c 89 e0             	mov    %r12,%rax
    8fbc:	5b                   	pop    %rbx
    8fbd:	41 5c                	pop    %r12
    8fbf:	41 5d                	pop    %r13
    8fc1:	c3                   	ret    
    8fc2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    8fc9:	00 00 00 00 
    8fcd:	0f 1f 00             	nopl   (%rax)

0000000000008fd0 <AppendDevicePath>:
{
    8fd0:	f3 0f 1e fa          	endbr64 
    8fd4:	41 57                	push   %r15
    8fd6:	41 56                	push   %r14
    8fd8:	41 55                	push   %r13
    8fda:	49 89 f5             	mov    %rsi,%r13
    8fdd:	41 54                	push   %r12
    8fdf:	55                   	push   %rbp
    8fe0:	53                   	push   %rbx
    8fe1:	48 83 ec 48          	sub    $0x48,%rsp
    8fe5:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
    if (!Src1) {
    8fea:	48 85 ff             	test   %rdi,%rdi
    8fed:	0f 84 3e 01 00 00    	je     9131 <AppendDevicePath+0x161>
    8ff3:	49 89 f8             	mov    %rdi,%r8
    if (!Src2) {
    8ff6:	48 89 f8             	mov    %rdi,%rax
    8ff9:	48 85 f6             	test   %rsi,%rsi
    8ffc:	75 11                	jne    900f <AppendDevicePath+0x3f>
    8ffe:	e9 22 01 00 00       	jmp    9125 <AppendDevicePath+0x155>
    9003:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        DevPath = NextDevicePathNode(DevPath);
    9008:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    900c:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    900f:	0f b6 10             	movzbl (%rax),%edx
    9012:	83 e2 7f             	and    $0x7f,%edx
    9015:	80 fa 7f             	cmp    $0x7f,%dl
    9018:	75 ee                	jne    9008 <AppendDevicePath+0x38>
    901a:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    901e:	75 e8                	jne    9008 <AppendDevicePath+0x38>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    9020:	4c 29 c0             	sub    %r8,%rax
    9023:	4c 89 44 24 30       	mov    %r8,0x30(%rsp)
    Count = 0;
    9028:	31 db                	xor    %ebx,%ebx
    902a:	48 8d 6c 24 38       	lea    0x38(%rsp),%rbp
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    902f:	4c 8d 70 04          	lea    0x4(%rax),%r14
DevicePathInstanceCount (
    9033:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
    9038:	eb 0a                	jmp    9044 <AppendDevicePath+0x74>
    903a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        Count += 1;
    9040:	48 83 c3 01          	add    $0x1,%rbx
    while (DevicePathInstance(&DevicePath, &Size)) {
    9044:	48 89 ee             	mov    %rbp,%rsi
    9047:	4c 89 e7             	mov    %r12,%rdi
    904a:	e8 f1 fd ff ff       	call   8e40 <DevicePathInstance>
    904f:	48 85 c0             	test   %rax,%rax
    9052:	75 ec                	jne    9040 <AppendDevicePath+0x70>
    Src1Inst = DevicePathInstanceCount(Src1);
    9054:	4c 89 e8             	mov    %r13,%rax
    9057:	eb 0e                	jmp    9067 <AppendDevicePath+0x97>
    9059:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        DevPath = NextDevicePathNode(DevPath);
    9060:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    9064:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    9067:	0f b6 10             	movzbl (%rax),%edx
    906a:	83 e2 7f             	and    $0x7f,%edx
    906d:	80 fa 7f             	cmp    $0x7f,%dl
    9070:	75 ee                	jne    9060 <AppendDevicePath+0x90>
    9072:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    9076:	75 e8                	jne    9060 <AppendDevicePath+0x90>
    Size = Src1Size * Src1Inst + Src2Size;
    9078:	49 0f af de          	imul   %r14,%rbx
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    907c:	4c 29 e8             	sub    %r13,%rax
    907f:	4c 8d 74 24 28       	lea    0x28(%rsp),%r14
    9084:	4c 8d 60 04          	lea    0x4(%rax),%r12
            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
    9088:	4c 8d 3d 81 3d 01 00 	lea    0x13d81(%rip),%r15        # 1ce10 <EndInstanceDevicePath>
    Size = Src1Size * Src1Inst + Src2Size;
    908f:	4a 8d 3c 23          	lea    (%rbx,%r12,1),%rdi
    9093:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
    Dst = AllocatePool (Size);
    9098:	e8 a3 b7 ff ff       	call   4840 <AllocatePool>
    909d:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    if (Dst) {
    90a2:	48 89 c3             	mov    %rax,%rbx
    90a5:	48 85 c0             	test   %rax,%rax
    90a8:	75 3e                	jne    90e8 <AppendDevicePath+0x118>
    90aa:	eb 65                	jmp    9111 <AppendDevicePath+0x141>
    90ac:	0f 1f 40 00          	nopl   0x0(%rax)
            CopyMem(DstPos, Inst, Size);
    90b0:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
    90b5:	48 89 d9             	mov    %rbx,%rcx
    90b8:	e8 83 b9 ff ff       	call   4a40 <CopyMem>
            DstPos += Size;
    90bd:	48 03 5c 24 38       	add    0x38(%rsp),%rbx
            CopyMem(DstPos, Src2, Src2Size);
    90c2:	4d 89 e0             	mov    %r12,%r8
    90c5:	4c 89 ea             	mov    %r13,%rdx
    90c8:	48 89 d9             	mov    %rbx,%rcx
            DstPos += Src2Size;
    90cb:	4c 01 e3             	add    %r12,%rbx
            CopyMem(DstPos, Src2, Src2Size);
    90ce:	e8 6d b9 ff ff       	call   4a40 <CopyMem>
            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
    90d3:	48 89 d9             	mov    %rbx,%rcx
    90d6:	4c 89 fa             	mov    %r15,%rdx
            DstPos += sizeof(EFI_DEVICE_PATH);
    90d9:	48 83 c3 04          	add    $0x4,%rbx
            CopyMem(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
    90dd:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    90e3:	e8 58 b9 ff ff       	call   4a40 <CopyMem>
        while ((Inst = DevicePathInstance (&Src1, &Size))) {
    90e8:	48 89 ee             	mov    %rbp,%rsi
    90eb:	4c 89 f7             	mov    %r14,%rdi
    90ee:	e8 4d fd ff ff       	call   8e40 <DevicePathInstance>
    90f3:	48 89 c2             	mov    %rax,%rdx
    90f6:	48 85 c0             	test   %rax,%rax
    90f9:	75 b5                	jne    90b0 <AppendDevicePath+0xe0>
        DstPos -= sizeof(EFI_DEVICE_PATH);
    90fb:	48 8d 4b fc          	lea    -0x4(%rbx),%rcx
        CopyMem(DstPos, EndDevicePath, sizeof(EFI_DEVICE_PATH));
    90ff:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    9105:	48 8d 15 08 3d 01 00 	lea    0x13d08(%rip),%rdx        # 1ce14 <EndDevicePath>
    910c:	e8 2f b9 ff ff       	call   4a40 <CopyMem>
}
    9111:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    9116:	48 83 c4 48          	add    $0x48,%rsp
    911a:	5b                   	pop    %rbx
    911b:	5d                   	pop    %rbp
    911c:	41 5c                	pop    %r12
    911e:	41 5d                	pop    %r13
    9120:	41 5e                	pop    %r14
    9122:	41 5f                	pop    %r15
    9124:	c3                   	ret    
        return DuplicateDevicePath (Src1);
    9125:	e8 36 fe ff ff       	call   8f60 <DuplicateDevicePath>
    912a:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    912f:	eb e0                	jmp    9111 <AppendDevicePath+0x141>
        return DuplicateDevicePath (Src2);
    9131:	48 89 f7             	mov    %rsi,%rdi
    9134:	e8 27 fe ff ff       	call   8f60 <DuplicateDevicePath>
    9139:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    913e:	eb d1                	jmp    9111 <AppendDevicePath+0x141>

0000000000009140 <AppendDevicePathNode>:
{
    9140:	f3 0f 1e fa          	endbr64 
    9144:	41 55                	push   %r13
    9146:	49 89 fd             	mov    %rdi,%r13
    9149:	41 54                	push   %r12
    914b:	49 89 f4             	mov    %rsi,%r12
    914e:	55                   	push   %rbp
    914f:	53                   	push   %rbx
    9150:	48 83 ec 28          	sub    $0x28,%rsp
    Length = DevicePathNodeLength(Src2);
    9154:	0f b7 5e 02          	movzwl 0x2(%rsi),%ebx
    Temp = AllocatePool (Length + sizeof(EFI_DEVICE_PATH));
    9158:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
    915c:	e8 df b6 ff ff       	call   4840 <AllocatePool>
    if (!Temp) {
    9161:	48 85 c0             	test   %rax,%rax
    9164:	74 4a                	je     91b0 <AppendDevicePathNode+0x70>
    9166:	48 89 c5             	mov    %rax,%rbp
    CopyMem (Temp, Src2, Length);
    9169:	49 89 d8             	mov    %rbx,%r8
    916c:	4c 89 e2             	mov    %r12,%rdx
    916f:	48 89 c1             	mov    %rax,%rcx
    9172:	e8 c9 b8 ff ff       	call   4a40 <CopyMem>
    Eop = NextDevicePathNode(Temp);
    9177:	0f b7 45 02          	movzwl 0x2(%rbp),%eax
    Src1 = AppendDevicePath (Src1, Temp);
    917b:	48 89 ee             	mov    %rbp,%rsi
    917e:	4c 89 ef             	mov    %r13,%rdi
    SetDevicePathEndNode(Eop);
    9181:	c7 44 05 00 7f ff 04 	movl   $0x4ff7f,0x0(%rbp,%rax,1)
    9188:	00 
    Src1 = AppendDevicePath (Src1, Temp);
    9189:	e8 42 fe ff ff       	call   8fd0 <AppendDevicePath>
    FreePool (Temp);
    918e:	48 89 ef             	mov    %rbp,%rdi
    Src1 = AppendDevicePath (Src1, Temp);
    9191:	49 89 c4             	mov    %rax,%r12
    FreePool (Temp);
    9194:	e8 c7 b7 ff ff       	call   4960 <FreePool>
}
    9199:	48 83 c4 28          	add    $0x28,%rsp
    919d:	4c 89 e0             	mov    %r12,%rax
    91a0:	5b                   	pop    %rbx
    91a1:	5d                   	pop    %rbp
    91a2:	41 5c                	pop    %r12
    91a4:	41 5d                	pop    %r13
    91a6:	c3                   	ret    
    91a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    91ae:	00 00 
    91b0:	48 83 c4 28          	add    $0x28,%rsp
        return NULL;
    91b4:	45 31 e4             	xor    %r12d,%r12d
}
    91b7:	5b                   	pop    %rbx
    91b8:	4c 89 e0             	mov    %r12,%rax
    91bb:	5d                   	pop    %rbp
    91bc:	41 5c                	pop    %r12
    91be:	41 5d                	pop    %r13
    91c0:	c3                   	ret    
    91c1:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    91c8:	00 00 00 00 
    91cc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000091d0 <FileDevicePath>:
{
    91d0:	f3 0f 1e fa          	endbr64 
    91d4:	41 56                	push   %r14
    91d6:	49 89 fe             	mov    %rdi,%r14
    Size = StrSize(FileName);
    91d9:	48 89 f7             	mov    %rsi,%rdi
{
    91dc:	41 55                	push   %r13
    91de:	49 89 f5             	mov    %rsi,%r13
    91e1:	41 54                	push   %r12
    91e3:	53                   	push   %rbx
    91e4:	48 83 ec 38          	sub    $0x38,%rsp
    Size = StrSize(FileName);
    91e8:	e8 c3 e4 ff ff       	call   76b0 <StrSize>
    FilePath = AllocateZeroPool (Size + SIZE_OF_FILEPATH_DEVICE_PATH + sizeof(EFI_DEVICE_PATH));
    91ed:	48 8d 78 08          	lea    0x8(%rax),%rdi
    Size = StrSize(FileName);
    91f1:	48 89 c3             	mov    %rax,%rbx
    FilePath = AllocateZeroPool (Size + SIZE_OF_FILEPATH_DEVICE_PATH + sizeof(EFI_DEVICE_PATH));
    91f4:	e8 87 b6 ff ff       	call   4880 <AllocateZeroPool>
    91f9:	49 89 c4             	mov    %rax,%r12
    if (FilePath) {
    91fc:	48 85 c0             	test   %rax,%rax
    91ff:	74 7e                	je     927f <FileDevicePath+0xaf>
        FilePath->Header.Type = MEDIA_DEVICE_PATH;
    9201:	b8 04 04 00 00       	mov    $0x404,%eax
        CopyMem (FilePath->PathName, FileName, Size);
    9206:	49 8d 4c 24 04       	lea    0x4(%r12),%rcx
    920b:	49 89 d8             	mov    %rbx,%r8
    920e:	4c 89 ea             	mov    %r13,%rdx
        FilePath->Header.Type = MEDIA_DEVICE_PATH;
    9211:	66 41 89 04 24       	mov    %ax,(%r12)
        SetDevicePathNodeLength (&FilePath->Header, Size + SIZE_OF_FILEPATH_DEVICE_PATH);
    9216:	8d 43 04             	lea    0x4(%rbx),%eax
    9219:	41 88 44 24 02       	mov    %al,0x2(%r12)
    921e:	48 8d 43 04          	lea    0x4(%rbx),%rax
    9222:	0f b6 c4             	movzbl %ah,%eax
    9225:	41 88 44 24 03       	mov    %al,0x3(%r12)
        CopyMem (FilePath->PathName, FileName, Size);
    922a:	e8 11 b8 ff ff       	call   4a40 <CopyMem>
        Eop = NextDevicePathNode(&FilePath->Header);
    922f:	41 0f b7 44 24 02    	movzwl 0x2(%r12),%eax
        SetDevicePathEndNode(Eop);
    9235:	41 c7 04 04 7f ff 04 	movl   $0x4ff7f,(%r12,%rax,1)
    923c:	00 
        if (Device) {
    923d:	4d 85 f6             	test   %r14,%r14
    9240:	74 3d                	je     927f <FileDevicePath+0xaf>
    Status = uefi_call_wrapper(BS->HandleProtocol, 3, Handle, &DevicePathProtocol, (VOID*)&DevicePath);
    9242:	48 8b 05 e7 43 01 00 	mov    0x143e7(%rip),%rax        # 1d630 <BS>
    9249:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    924e:	48 8d 15 9b 3b 01 00 	lea    0x13b9b(%rip),%rdx        # 1cdf0 <gEfiDevicePathProtocolGuid>
    9255:	4c 89 f1             	mov    %r14,%rcx
    9258:	ff 90 98 00 00 00    	call   *0x98(%rax)
    return DevicePath;
    925e:	31 ff                	xor    %edi,%edi
            DevicePath = AppendDevicePath (
    9260:	4c 89 e6             	mov    %r12,%rsi
    return DevicePath;
    9263:	48 85 c0             	test   %rax,%rax
    9266:	48 0f 49 7c 24 28    	cmovns 0x28(%rsp),%rdi
            DevicePath = AppendDevicePath (
    926c:	e8 5f fd ff ff       	call   8fd0 <AppendDevicePath>
            FreePool(FilePath);
    9271:	4c 89 e7             	mov    %r12,%rdi
            DevicePath = AppendDevicePath (
    9274:	48 89 c3             	mov    %rax,%rbx
            FreePool(FilePath);
    9277:	e8 e4 b6 ff ff       	call   4960 <FreePool>
            DevicePath = AppendDevicePath (
    927c:	49 89 dc             	mov    %rbx,%r12
}
    927f:	48 83 c4 38          	add    $0x38,%rsp
    9283:	4c 89 e0             	mov    %r12,%rax
    9286:	5b                   	pop    %rbx
    9287:	41 5c                	pop    %r12
    9289:	41 5d                	pop    %r13
    928b:	41 5e                	pop    %r14
    928d:	c3                   	ret    
    928e:	66 90                	xchg   %ax,%ax

0000000000009290 <UnpackDevicePath>:
{
    9290:	f3 0f 1e fa          	endbr64 
    9294:	41 56                	push   %r14
    Src = DevPath;
    9296:	48 89 f8             	mov    %rdi,%rax
{
    9299:	41 55                	push   %r13
    929b:	41 54                	push   %r12
    929d:	55                   	push   %rbp
    929e:	53                   	push   %rbx
    929f:	48 89 fb             	mov    %rdi,%rbx
    Size = 0;
    92a2:	31 ff                	xor    %edi,%edi
{
    92a4:	48 83 ec 20          	sub    $0x20,%rsp
    92a8:	eb 09                	jmp    92b3 <UnpackDevicePath+0x23>
    92aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        Src = NextDevicePathNode(Src);
    92b0:	48 01 f0             	add    %rsi,%rax
        Size += DevicePathNodeLength(Src);
    92b3:	0f b7 70 02          	movzwl 0x2(%rax),%esi
    92b7:	48 01 f7             	add    %rsi,%rdi
        Size += ALIGN_SIZE(Size);
    92ba:	48 89 f9             	mov    %rdi,%rcx
    92bd:	48 8d 57 04          	lea    0x4(%rdi),%rdx
    92c1:	83 e1 03             	and    $0x3,%ecx
    92c4:	48 29 ca             	sub    %rcx,%rdx
    92c7:	48 85 c9             	test   %rcx,%rcx
    92ca:	48 0f 45 fa          	cmovne %rdx,%rdi
        if (IsDevicePathEnd(Src)) {
    92ce:	0f b6 10             	movzbl (%rax),%edx
    92d1:	83 e2 7f             	and    $0x7f,%edx
    92d4:	80 fa 7f             	cmp    $0x7f,%dl
    92d7:	75 d7                	jne    92b0 <UnpackDevicePath+0x20>
    92d9:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    92dd:	75 d1                	jne    92b0 <UnpackDevicePath+0x20>
    NewPath = AllocateZeroPool (Size);
    92df:	e8 9c b5 ff ff       	call   4880 <AllocateZeroPool>
    92e4:	49 89 c5             	mov    %rax,%r13
    if (NewPath) {
    92e7:	48 85 c0             	test   %rax,%rax
    92ea:	74 5b                	je     9347 <UnpackDevicePath+0xb7>
    92ec:	48 89 c5             	mov    %rax,%rbp
    92ef:	eb 0e                	jmp    92ff <UnpackDevicePath+0x6f>
    92f1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            Src = NextDevicePathNode(Src);
    92f8:	0f b7 43 02          	movzwl 0x2(%rbx),%eax
    92fc:	48 01 c3             	add    %rax,%rbx
            Size = DevicePathNodeLength(Src);
    92ff:	44 0f b7 63 02       	movzwl 0x2(%rbx),%r12d
            CopyMem (Dest, Src, Size);
    9304:	48 89 da             	mov    %rbx,%rdx
    9307:	48 89 e9             	mov    %rbp,%rcx
    930a:	4d 89 e0             	mov    %r12,%r8
    930d:	4d 89 e6             	mov    %r12,%r14
    9310:	e8 2b b7 ff ff       	call   4a40 <CopyMem>
            Size += ALIGN_SIZE(Size);
    9315:	44 89 e0             	mov    %r12d,%eax
    9318:	83 e0 03             	and    $0x3,%eax
    931b:	41 83 e6 03          	and    $0x3,%r14d
    931f:	74 0a                	je     932b <UnpackDevicePath+0x9b>
    9321:	49 83 c4 04          	add    $0x4,%r12
    9325:	0f b7 c0             	movzwl %ax,%eax
    9328:	49 29 c4             	sub    %rax,%r12
            Dest->Type |= EFI_DP_TYPE_UNPACKED;
    932b:	80 4d 00 80          	orb    $0x80,0x0(%rbp)
            SetDevicePathNodeLength (Dest, Size);
    932f:	66 44 89 65 02       	mov    %r12w,0x2(%rbp)
            if (IsDevicePathEnd(Src)) {
    9334:	0f b6 03             	movzbl (%rbx),%eax
            Dest = (EFI_DEVICE_PATH *) (((UINT8 *) Dest) + Size);
    9337:	4c 01 e5             	add    %r12,%rbp
            if (IsDevicePathEnd(Src)) {
    933a:	83 e0 7f             	and    $0x7f,%eax
    933d:	3c 7f                	cmp    $0x7f,%al
    933f:	75 b7                	jne    92f8 <UnpackDevicePath+0x68>
    9341:	80 7b 01 ff          	cmpb   $0xff,0x1(%rbx)
    9345:	75 b1                	jne    92f8 <UnpackDevicePath+0x68>
}
    9347:	48 83 c4 20          	add    $0x20,%rsp
    934b:	4c 89 e8             	mov    %r13,%rax
    934e:	5b                   	pop    %rbx
    934f:	5d                   	pop    %rbp
    9350:	41 5c                	pop    %r12
    9352:	41 5d                	pop    %r13
    9354:	41 5e                	pop    %r14
    9356:	c3                   	ret    
    9357:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    935e:	00 00 

0000000000009360 <AppendDevicePathInstance>:
{
    9360:	f3 0f 1e fa          	endbr64 
    9364:	41 56                	push   %r14
    9366:	48 89 f8             	mov    %rdi,%rax
    9369:	41 55                	push   %r13
    936b:	49 89 fd             	mov    %rdi,%r13
    936e:	41 54                	push   %r12
    9370:	49 89 f4             	mov    %rsi,%r12
    9373:	55                   	push   %rbp
    9374:	53                   	push   %rbx
    9375:	48 83 ec 20          	sub    $0x20,%rsp
    if (Src == NULL) {
    9379:	48 85 ff             	test   %rdi,%rdi
    937c:	75 11                	jne    938f <AppendDevicePathInstance+0x2f>
    937e:	e9 ab 00 00 00       	jmp    942e <AppendDevicePathInstance+0xce>
    9383:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        DevPath = NextDevicePathNode(DevPath);
    9388:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    938c:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    938f:	0f b6 10             	movzbl (%rax),%edx
    9392:	83 e2 7f             	and    $0x7f,%edx
    9395:	80 fa 7f             	cmp    $0x7f,%dl
    9398:	75 ee                	jne    9388 <AppendDevicePathInstance+0x28>
    939a:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    939e:	75 e8                	jne    9388 <AppendDevicePathInstance+0x28>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    93a0:	4c 29 e8             	sub    %r13,%rax
    93a3:	48 8d 68 04          	lea    0x4(%rax),%rbp
    93a7:	4c 89 e0             	mov    %r12,%rax
    93aa:	eb 0b                	jmp    93b7 <AppendDevicePathInstance+0x57>
    93ac:	0f 1f 40 00          	nopl   0x0(%rax)
        DevPath = NextDevicePathNode(DevPath);
    93b0:	0f b7 50 02          	movzwl 0x2(%rax),%edx
    93b4:	48 01 d0             	add    %rdx,%rax
    while (!IsDevicePathEnd(DevPath)) {
    93b7:	0f b6 10             	movzbl (%rax),%edx
    93ba:	83 e2 7f             	and    $0x7f,%edx
    93bd:	80 fa 7f             	cmp    $0x7f,%dl
    93c0:	75 ee                	jne    93b0 <AppendDevicePathInstance+0x50>
    93c2:	80 78 01 ff          	cmpb   $0xff,0x1(%rax)
    93c6:	75 e8                	jne    93b0 <AppendDevicePathInstance+0x50>
    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
    93c8:	4c 29 e0             	sub    %r12,%rax
    93cb:	48 8d 58 04          	lea    0x4(%rax),%rbx
    Ptr = AllocatePool (SrcSize + InstanceSize);
    93cf:	48 8d 3c 2b          	lea    (%rbx,%rbp,1),%rdi
    93d3:	e8 68 b4 ff ff       	call   4840 <AllocatePool>
    CopyMem (Ptr, Src, SrcSize);
    93d8:	49 89 e8             	mov    %rbp,%r8
    93db:	4c 89 ea             	mov    %r13,%rdx
    Ptr = AllocatePool (SrcSize + InstanceSize);
    93de:	49 89 c6             	mov    %rax,%r14
    CopyMem (Ptr, Src, SrcSize);
    93e1:	48 89 c1             	mov    %rax,%rcx
    93e4:	e8 57 b6 ff ff       	call   4a40 <CopyMem>
    DevPath = (EFI_DEVICE_PATH *)Ptr;
    93e9:	4c 89 f1             	mov    %r14,%rcx
    while (!IsDevicePathEnd(DevPath)) {
    93ec:	eb 09                	jmp    93f7 <AppendDevicePathInstance+0x97>
    93ee:	66 90                	xchg   %ax,%ax
        DevPath = NextDevicePathNode(DevPath);
    93f0:	0f b7 51 02          	movzwl 0x2(%rcx),%edx
    93f4:	48 01 d1             	add    %rdx,%rcx
    while (!IsDevicePathEnd(DevPath)) {
    93f7:	0f b6 11             	movzbl (%rcx),%edx
    93fa:	83 e2 7f             	and    $0x7f,%edx
    93fd:	80 fa 7f             	cmp    $0x7f,%dl
    9400:	75 ee                	jne    93f0 <AppendDevicePathInstance+0x90>
    9402:	80 79 01 ff          	cmpb   $0xff,0x1(%rcx)
    9406:	75 e8                	jne    93f0 <AppendDevicePathInstance+0x90>
    DevPath = NextDevicePathNode(DevPath);
    9408:	0f b7 41 02          	movzwl 0x2(%rcx),%eax
    DevPath->SubType = END_INSTANCE_DEVICE_PATH_SUBTYPE;
    940c:	c6 41 01 01          	movb   $0x1,0x1(%rcx)
    CopyMem (DevPath, Instance, InstanceSize);
    9410:	49 89 d8             	mov    %rbx,%r8
    9413:	4c 89 e2             	mov    %r12,%rdx
    DevPath = NextDevicePathNode(DevPath);
    9416:	48 01 c1             	add    %rax,%rcx
    CopyMem (DevPath, Instance, InstanceSize);
    9419:	e8 22 b6 ff ff       	call   4a40 <CopyMem>
}
    941e:	48 83 c4 20          	add    $0x20,%rsp
    9422:	4c 89 f0             	mov    %r14,%rax
    9425:	5b                   	pop    %rbx
    9426:	5d                   	pop    %rbp
    9427:	41 5c                	pop    %r12
    9429:	41 5d                	pop    %r13
    942b:	41 5e                	pop    %r14
    942d:	c3                   	ret    
    942e:	48 83 c4 20          	add    $0x20,%rsp
        return DuplicateDevicePath (Instance);
    9432:	48 89 f7             	mov    %rsi,%rdi
}
    9435:	5b                   	pop    %rbx
    9436:	5d                   	pop    %rbp
    9437:	41 5c                	pop    %r12
    9439:	41 5d                	pop    %r13
    943b:	41 5e                	pop    %r14
        return DuplicateDevicePath (Instance);
    943d:	e9 1e fb ff ff       	jmp    8f60 <DuplicateDevicePath>
    9442:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    9449:	00 00 00 00 
    944d:	0f 1f 00             	nopl   (%rax)

0000000000009450 <LibDevicePathToInterface>:
{
    9450:	f3 0f 1e fa          	endbr64 
    9454:	41 54                	push   %r12
    Status = uefi_call_wrapper(BS->LocateDevicePath, 3, Protocol, &FilePath, &Device);
    9456:	48 89 f9             	mov    %rdi,%rcx
{
    9459:	49 89 fc             	mov    %rdi,%r12
    945c:	53                   	push   %rbx
    945d:	48 89 d3             	mov    %rdx,%rbx
    9460:	48 83 ec 48          	sub    $0x48,%rsp
    Status = uefi_call_wrapper(BS->LocateDevicePath, 3, Protocol, &FilePath, &Device);
    9464:	48 8b 05 c5 41 01 00 	mov    0x141c5(%rip),%rax        # 1d630 <BS>
{
    946b:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    Status = uefi_call_wrapper(BS->LocateDevicePath, 3, Protocol, &FilePath, &Device);
    9470:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
    9475:	4c 8d 44 24 38       	lea    0x38(%rsp),%r8
    947a:	ff 90 b8 00 00 00    	call   *0xb8(%rax)
    if (!EFI_ERROR(Status)) {
    9480:	48 85 c0             	test   %rax,%rax
    9483:	78 1a                	js     949f <LibDevicePathToInterface+0x4f>
        if (IsDevicePathEnd(FilePath)) {
    9485:	48 b8 0e 00 00 00 00 	movabs $0x800000000000000e,%rax
    948c:	00 00 80 
    948f:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
    9494:	0f b6 11             	movzbl (%rcx),%edx
    9497:	83 e2 7f             	and    $0x7f,%edx
    949a:	80 fa 7f             	cmp    $0x7f,%dl
    949d:	74 11                	je     94b0 <LibDevicePathToInterface+0x60>
        *Interface = NULL;
    949f:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
    94a6:	48 83 c4 48          	add    $0x48,%rsp
    94aa:	5b                   	pop    %rbx
    94ab:	41 5c                	pop    %r12
    94ad:	c3                   	ret    
    94ae:	66 90                	xchg   %ax,%ax
        if (IsDevicePathEnd(FilePath)) {
    94b0:	80 79 01 ff          	cmpb   $0xff,0x1(%rcx)
    94b4:	75 e9                	jne    949f <LibDevicePathToInterface+0x4f>
            Status =uefi_call_wrapper(BS->HandleProtocol, 3, Device, Protocol, Interface);
    94b6:	48 8b 05 73 41 01 00 	mov    0x14173(%rip),%rax        # 1d630 <BS>
    94bd:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    94c2:	49 89 d8             	mov    %rbx,%r8
    94c5:	4c 89 e2             	mov    %r12,%rdx
    94c8:	ff 90 98 00 00 00    	call   *0x98(%rax)
    if (EFI_ERROR(Status)) {
    94ce:	48 85 c0             	test   %rax,%rax
    94d1:	78 cc                	js     949f <LibDevicePathToInterface+0x4f>
}
    94d3:	48 83 c4 48          	add    $0x48,%rsp
    94d7:	5b                   	pop    %rbx
    94d8:	41 5c                	pop    %r12
    94da:	c3                   	ret    
    94db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000094e0 <DevicePathToStr>:
    Turns the Device Path into a printable string.  Allcoates
    the string from pool.  The caller must FreePool the returned
    string.

--*/
{
    94e0:	f3 0f 1e fa          	endbr64 
    94e4:	41 57                	push   %r15
    POOL_PRINT          Str;
    EFI_DEVICE_PATH     *DevPathNode;
    VOID                (*DumpNode)(POOL_PRINT *, VOID *);
    UINTN               Index, NewSize;

    ZeroMem(&Str, sizeof(Str));
    94e6:	be 18 00 00 00       	mov    $0x18,%esi
{
    94eb:	41 56                	push   %r14
    94ed:	41 55                	push   %r13
        //
        //  Put a path seperator in if needed
        //

        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
            CatPrint (&Str, L"/");
    94ef:	4c 8d 2d 80 0a 02 00 	lea    0x20a80(%rip),%r13        # 29f76 <_DYNAMIC+0xbf76>
{
    94f6:	41 54                	push   %r12
            DumpNode = _DevPathNodeUnknown;
    94f8:	4c 8d 25 51 f1 ff ff 	lea    -0xeaf(%rip),%r12        # 8650 <_DevPathNodeUnknown>
{
    94ff:	55                   	push   %rbp
    9500:	48 89 fd             	mov    %rdi,%rbp
    9503:	53                   	push   %rbx
    9504:	48 83 ec 38          	sub    $0x38,%rsp
    ZeroMem(&Str, sizeof(Str));
    9508:	48 8d 5c 24 10       	lea    0x10(%rsp),%rbx
    950d:	48 89 df             	mov    %rbx,%rdi
    9510:	e8 6b b4 ff ff       	call   4980 <ZeroMem>
    DevPath = UnpackDevicePath(DevPath);
    9515:	48 89 ef             	mov    %rbp,%rdi
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    9518:	48 8d 2d c1 ea ff ff 	lea    -0x153f(%rip),%rbp        # 7fe0 <_DevPathEndInstance>
    DevPath = UnpackDevicePath(DevPath);
    951f:	e8 6c fd ff ff       	call   9290 <UnpackDevicePath>
    DevPathNode = DevPath;
    9524:	49 89 c6             	mov    %rax,%r14
    DevPath = UnpackDevicePath(DevPath);
    9527:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    while (!IsDevicePathEnd(DevPathNode)) {
    952c:	41 0f b6 16          	movzbl (%r14),%edx
    9530:	83 e2 7f             	and    $0x7f,%edx
    9533:	80 fa 7f             	cmp    $0x7f,%dl
    9536:	74 71                	je     95a9 <DevicePathToStr+0xc9>
    9538:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    953f:	00 
        for (Index = 0; DevPathTable[Index].Function; Index += 1) {
    9540:	4c 8b 3d 01 3c 01 00 	mov    0x13c01(%rip),%r15        # 1d148 <DevPathTable+0x8>
    9547:	48 8d 05 f2 3b 01 00 	lea    0x13bf2(%rip),%rax        # 1d140 <DevPathTable>
    954e:	4d 85 ff             	test   %r15,%r15
    9551:	75 1e                	jne    9571 <DevicePathToStr+0x91>
    9553:	e9 a0 00 00 00       	jmp    95f8 <DevicePathToStr+0x118>
    9558:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    955f:	00 
    9560:	4c 8b 78 18          	mov    0x18(%rax),%r15
    9564:	48 83 c0 10          	add    $0x10,%rax
    9568:	4d 85 ff             	test   %r15,%r15
    956b:	0f 84 87 00 00 00    	je     95f8 <DevicePathToStr+0x118>
            if (DevicePathType(DevPathNode) == DevPathTable[Index].Type &&
    9571:	38 10                	cmp    %dl,(%rax)
    9573:	75 eb                	jne    9560 <DevicePathToStr+0x80>
    9575:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    9579:	41 38 4e 01          	cmp    %cl,0x1(%r14)
    957d:	75 e1                	jne    9560 <DevicePathToStr+0x80>
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    957f:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
    9585:	74 05                	je     958c <DevicePathToStr+0xac>
    9587:	49 39 ef             	cmp    %rbp,%r15
    958a:	75 77                	jne    9603 <DevicePathToStr+0x123>

        //
        // Print this node of the device path
        //

        DumpNode (&Str, DevPathNode);
    958c:	4c 89 f6             	mov    %r14,%rsi
    958f:	48 89 df             	mov    %rbx,%rdi
    9592:	41 ff d7             	call   *%r15

        //
        // Next device path node
        //

        DevPathNode = NextDevicePathNode(DevPathNode);
    9595:	41 0f b7 46 02       	movzwl 0x2(%r14),%eax
    959a:	49 01 c6             	add    %rax,%r14
    while (!IsDevicePathEnd(DevPathNode)) {
    959d:	41 0f b6 16          	movzbl (%r14),%edx
    95a1:	83 e2 7f             	and    $0x7f,%edx
    95a4:	80 fa 7f             	cmp    $0x7f,%dl
    95a7:	75 97                	jne    9540 <DevicePathToStr+0x60>
    95a9:	41 80 7e 01 ff       	cmpb   $0xff,0x1(%r14)
    95ae:	75 90                	jne    9540 <DevicePathToStr+0x60>

    //
    // Shrink pool used for string allocation
    //

    FreePool (DevPath);
    95b0:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    95b5:	e8 a6 b3 ff ff       	call   4960 <FreePool>
    NewSize = (Str.len + 1) * sizeof(CHAR16);
    95ba:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    95bf:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    NewSize = (Str.len + 1) * sizeof(CHAR16);
    95c4:	48 8d 74 00 02       	lea    0x2(%rax,%rax,1),%rsi
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    95c9:	48 89 f2             	mov    %rsi,%rdx
    95cc:	e8 ff b2 ff ff       	call   48d0 <ReallocatePool>
    Str.str[Str.len] = 0;
    95d1:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    95d6:	31 c9                	xor    %ecx,%ecx
    Str.str = ReallocatePool (Str.str, NewSize, NewSize);
    95d8:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    Str.str[Str.len] = 0;
    95dd:	66 89 0c 50          	mov    %cx,(%rax,%rdx,2)
    return Str.str;
    95e1:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
}
    95e6:	48 83 c4 38          	add    $0x38,%rsp
    95ea:	5b                   	pop    %rbx
    95eb:	5d                   	pop    %rbp
    95ec:	41 5c                	pop    %r12
    95ee:	41 5d                	pop    %r13
    95f0:	41 5e                	pop    %r14
    95f2:	41 5f                	pop    %r15
    95f4:	c3                   	ret    
    95f5:	0f 1f 00             	nopl   (%rax)
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    95f8:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
            DumpNode = _DevPathNodeUnknown;
    95fe:	4d 89 e7             	mov    %r12,%r15
        if (Str.len  &&  DumpNode != _DevPathEndInstance) {
    9601:	74 89                	je     958c <DevicePathToStr+0xac>
            CatPrint (&Str, L"/");
    9603:	4c 89 ee             	mov    %r13,%rsi
    9606:	48 89 df             	mov    %rbx,%rdi
    9609:	31 c0                	xor    %eax,%eax
    960b:	e8 e0 d4 ff ff       	call   6af0 <CatPrint>
    9610:	e9 77 ff ff ff       	jmp    958c <DevicePathToStr+0xac>
    9615:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    961c:	00 00 00 00 

0000000000009620 <LibMatchDevicePaths>:
BOOLEAN
LibMatchDevicePaths (
    IN  EFI_DEVICE_PATH *Multi,
    IN  EFI_DEVICE_PATH *Single
    )
{
    9620:	f3 0f 1e fa          	endbr64 
    EFI_DEVICE_PATH     *DevicePath, *DevicePathInst;
    UINTN               Size;

    if (!Multi || !Single) {
    9624:	48 85 ff             	test   %rdi,%rdi
    9627:	74 67                	je     9690 <LibMatchDevicePaths+0x70>
{
    9629:	41 54                	push   %r12
    962b:	55                   	push   %rbp
    962c:	53                   	push   %rbx
    962d:	48 89 f3             	mov    %rsi,%rbx
    9630:	48 83 ec 10          	sub    $0x10,%rsp
    if (!Multi || !Single) {
    9634:	48 85 f6             	test   %rsi,%rsi
    9637:	74 3c                	je     9675 <LibMatchDevicePaths+0x55>
        return FALSE;
    }

    DevicePath = Multi;
    9639:	48 89 3c 24          	mov    %rdi,(%rsp)
    while ((DevicePathInst = DevicePathInstance (&DevicePath, &Size))) {
    963d:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
    9642:	48 89 e5             	mov    %rsp,%rbp
    9645:	eb 1b                	jmp    9662 <LibMatchDevicePaths+0x42>
    9647:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    964e:	00 00 
        if (CompareMem (Single, DevicePathInst, Size) == 0) {
    9650:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    9655:	48 89 df             	mov    %rbx,%rdi
    9658:	e8 93 b4 ff ff       	call   4af0 <CompareMem>
    965d:	48 85 c0             	test   %rax,%rax
    9660:	74 1e                	je     9680 <LibMatchDevicePaths+0x60>
    while ((DevicePathInst = DevicePathInstance (&DevicePath, &Size))) {
    9662:	4c 89 e6             	mov    %r12,%rsi
    9665:	48 89 ef             	mov    %rbp,%rdi
    9668:	e8 d3 f7 ff ff       	call   8e40 <DevicePathInstance>
    966d:	48 89 c6             	mov    %rax,%rsi
    9670:	48 85 c0             	test   %rax,%rax
    9673:	75 db                	jne    9650 <LibMatchDevicePaths+0x30>
            return TRUE;
        }
    }
    return FALSE;
}
    9675:	48 83 c4 10          	add    $0x10,%rsp
        return FALSE;
    9679:	31 c0                	xor    %eax,%eax
}
    967b:	5b                   	pop    %rbx
    967c:	5d                   	pop    %rbp
    967d:	41 5c                	pop    %r12
    967f:	c3                   	ret    
    9680:	48 83 c4 10          	add    $0x10,%rsp
            return TRUE;
    9684:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9689:	5b                   	pop    %rbx
    968a:	5d                   	pop    %rbp
    968b:	41 5c                	pop    %r12
    968d:	c3                   	ret    
    968e:	66 90                	xchg   %ax,%ax
        return FALSE;
    9690:	31 c0                	xor    %eax,%eax
}
    9692:	c3                   	ret    
    9693:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    969a:	00 00 00 00 
    969e:	66 90                	xchg   %ax,%ax

00000000000096a0 <LibDuplicateDevicePathInstance>:

EFI_DEVICE_PATH *
LibDuplicateDevicePathInstance (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    96a0:	f3 0f 1e fa          	endbr64 
    96a4:	41 55                	push   %r13
    96a6:	41 54                	push   %r12
    DevicePathInst = DevicePathInstance (&Temp, &Size);

    //
    // Make a copy and set proper end type
    //
    NewDevPath = NULL;
    96a8:	45 31 e4             	xor    %r12d,%r12d
{
    96ab:	48 83 ec 38          	sub    $0x38,%rsp
    Temp = DevPath;
    96af:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
    DevicePathInst = DevicePathInstance (&Temp, &Size);
    96b4:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
    96b9:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    UINTN               Size = 0;
    96be:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    96c5:	00 00 
    DevicePathInst = DevicePathInstance (&Temp, &Size);
    96c7:	e8 74 f7 ff ff       	call   8e40 <DevicePathInstance>
    if (Size) {
    96cc:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    96d1:	48 85 ff             	test   %rdi,%rdi
    96d4:	74 50                	je     9726 <LibDuplicateDevicePathInstance+0x86>
        NewDevPath = AllocatePool (Size + sizeof(EFI_DEVICE_PATH));
    96d6:	48 83 c7 04          	add    $0x4,%rdi
    96da:	49 89 c5             	mov    %rax,%r13
    96dd:	e8 5e b1 ff ff       	call   4840 <AllocatePool>
    96e2:	49 89 c4             	mov    %rax,%r12
    }

    if (NewDevPath) {
    96e5:	48 85 c0             	test   %rax,%rax
    96e8:	74 3c                	je     9726 <LibDuplicateDevicePathInstance+0x86>
        CopyMem (NewDevPath, DevicePathInst, Size);
    96ea:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
    96ef:	48 89 c1             	mov    %rax,%rcx
    96f2:	4c 89 ea             	mov    %r13,%rdx
    96f5:	e8 46 b3 ff ff       	call   4a40 <CopyMem>
        Temp = NextDevicePathNode(NewDevPath);
    96fa:	41 0f b7 44 24 02    	movzwl 0x2(%r12),%eax
    9700:	4c 01 e0             	add    %r12,%rax
    9703:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
        SetDevicePathEndNode(Temp);
    9708:	c6 00 7f             	movb   $0x7f,(%rax)
    970b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    9710:	c6 40 01 ff          	movb   $0xff,0x1(%rax)
    9714:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    9719:	c6 40 02 04          	movb   $0x4,0x2(%rax)
    971d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    9722:	c6 40 03 00          	movb   $0x0,0x3(%rax)
    }

    return NewDevPath;
}
    9726:	48 83 c4 38          	add    $0x38,%rsp
    972a:	4c 89 e0             	mov    %r12,%rax
    972d:	41 5c                	pop    %r12
    972f:	41 5d                	pop    %r13
    9731:	c3                   	ret    
    9732:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    9739:	00 00 00 
    973c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000009740 <InitializeGuid>:

VOID
InitializeGuid (
    VOID
    )
{
    9740:	f3 0f 1e fa          	endbr64 
}
    9744:	c3                   	ret    
    9745:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    974c:	00 00 00 00 

0000000000009750 <CompareGuid>:

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    9750:	f3 0f 1e fa          	endbr64 
    return RtCompareGuid (Guid1, Guid2);
    9754:	e9 77 e4 ff ff       	jmp    7bd0 <RtCompareGuid>
    9759:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000009760 <GuidToString>:
VOID
GuidToString (
    OUT CHAR16      *Buffer,
    IN EFI_GUID     *Guid
    )
{
    9760:	f3 0f 1e fa          	endbr64 
    9764:	41 55                	push   %r13
    9766:	49 89 f5             	mov    %rsi,%r13

    //
    // Else, (for now) use additional internal function for mapping guids
    //

    for (Index=0; KnownGuids[Index].Guid; Index++) {
    9769:	48 8d 35 b0 3e 01 00 	lea    0x13eb0(%rip),%rsi        # 1d620 <NullGuid>
{
    9770:	41 54                	push   %r12
    9772:	49 89 fc             	mov    %rdi,%r12
    9775:	55                   	push   %rbp
    for (Index=0; KnownGuids[Index].Guid; Index++) {
    9776:	31 ed                	xor    %ebp,%ebp
{
    9778:	53                   	push   %rbx
    9779:	48 8d 1d f0 3b 01 00 	lea    0x13bf0(%rip),%rbx        # 1d370 <KnownGuids+0x10>
    9780:	48 83 ec 48          	sub    $0x48,%rsp
    9784:	eb 1a                	jmp    97a0 <GuidToString+0x40>
    9786:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    978d:	00 00 00 
    for (Index=0; KnownGuids[Index].Guid; Index++) {
    9790:	48 8b 33             	mov    (%rbx),%rsi
    9793:	48 83 c3 10          	add    $0x10,%rbx
    9797:	48 83 c5 01          	add    $0x1,%rbp
    979b:	48 85 f6             	test   %rsi,%rsi
    979e:	74 38                	je     97d8 <GuidToString+0x78>
    return RtCompareGuid (Guid1, Guid2);
    97a0:	4c 89 ef             	mov    %r13,%rdi
    97a3:	e8 28 e4 ff ff       	call   7bd0 <RtCompareGuid>
        if (CompareGuid(Guid, KnownGuids[Index].Guid) == 0) {
    97a8:	48 85 c0             	test   %rax,%rax
    97ab:	75 e3                	jne    9790 <GuidToString+0x30>
            UnicodeSPrint (Buffer, 0, KnownGuids[Index].GuidName);
    97ad:	48 c1 e5 04          	shl    $0x4,%rbp
    97b1:	48 8d 05 a8 3b 01 00 	lea    0x13ba8(%rip),%rax        # 1d360 <KnownGuids>
    97b8:	4c 89 e7             	mov    %r12,%rdi
    97bb:	31 f6                	xor    %esi,%esi
    97bd:	48 8b 54 28 08       	mov    0x8(%rax,%rbp,1),%rdx
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]
        );
}
    97c2:	48 83 c4 48          	add    $0x48,%rsp
            UnicodeSPrint (Buffer, 0, KnownGuids[Index].GuidName);
    97c6:	31 c0                	xor    %eax,%eax
}
    97c8:	5b                   	pop    %rbx
    97c9:	5d                   	pop    %rbp
    97ca:	41 5c                	pop    %r12
    97cc:	41 5d                	pop    %r13
            UnicodeSPrint (Buffer, 0, KnownGuids[Index].GuidName);
    97ce:	e9 9d d4 ff ff       	jmp    6c70 <UnicodeSPrint>
    97d3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    UnicodeSPrint (Buffer, 0, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    97d8:	41 0f b6 45 0f       	movzbl 0xf(%r13),%eax
    97dd:	45 0f b7 4d 06       	movzwl 0x6(%r13),%r9d
    97e2:	4c 89 e7             	mov    %r12,%rdi
    97e5:	48 8d 15 94 07 02 00 	lea    0x20794(%rip),%rdx        # 29f80 <CSWTCH.43+0x6>
    97ec:	45 0f b7 45 04       	movzwl 0x4(%r13),%r8d
    97f1:	41 8b 4d 00          	mov    0x0(%r13),%ecx
    97f5:	89 44 24 38          	mov    %eax,0x38(%rsp)
    97f9:	41 0f b6 45 0e       	movzbl 0xe(%r13),%eax
    97fe:	89 44 24 30          	mov    %eax,0x30(%rsp)
    9802:	41 0f b6 45 0d       	movzbl 0xd(%r13),%eax
    9807:	89 44 24 28          	mov    %eax,0x28(%rsp)
    980b:	41 0f b6 45 0c       	movzbl 0xc(%r13),%eax
    9810:	89 44 24 20          	mov    %eax,0x20(%rsp)
    9814:	41 0f b6 45 0b       	movzbl 0xb(%r13),%eax
    9819:	89 44 24 18          	mov    %eax,0x18(%rsp)
    981d:	41 0f b6 45 0a       	movzbl 0xa(%r13),%eax
    9822:	89 44 24 10          	mov    %eax,0x10(%rsp)
    9826:	41 0f b6 45 09       	movzbl 0x9(%r13),%eax
    982b:	89 44 24 08          	mov    %eax,0x8(%rsp)
    982f:	41 0f b6 45 08       	movzbl 0x8(%r13),%eax
    9834:	89 04 24             	mov    %eax,(%rsp)
    9837:	31 c0                	xor    %eax,%eax
    9839:	e8 32 d4 ff ff       	call   6c70 <UnicodeSPrint>
}
    983e:	48 83 c4 48          	add    $0x48,%rsp
    9842:	5b                   	pop    %rbx
    9843:	5d                   	pop    %rbp
    9844:	41 5c                	pop    %r12
    9846:	41 5d                	pop    %r13
    9848:	c3                   	ret    
    9849:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000009850 <_relocate>:
#include <elf.h>

EFI_STATUS _relocate (long ldbase, Elf64_Dyn *dyn,
		      EFI_HANDLE image EFI_UNUSED,
		      EFI_SYSTEM_TABLE *systab EFI_UNUSED)
{
    9850:	f3 0f 1e fa          	endbr64 
	long relsz = 0, relent = 0;
	Elf64_Rel *rel = 0;
	unsigned long *addr;
	int i;

	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
    9854:	48 8b 06             	mov    (%rsi),%rax
    9857:	48 85 c0             	test   %rax,%rax
    985a:	74 7e                	je     98da <_relocate+0x8a>
    985c:	48 83 c6 08          	add    $0x8,%rsi
	Elf64_Rel *rel = 0;
    9860:	31 d2                	xor    %edx,%edx
	long relsz = 0, relent = 0;
    9862:	45 31 c0             	xor    %r8d,%r8d
    9865:	31 c9                	xor    %ecx,%ecx
    9867:	eb 1a                	jmp    9883 <_relocate+0x33>
    9869:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		switch (dyn[i].d_tag) {
    9870:	48 83 f8 07          	cmp    $0x7,%rax
    9874:	74 72                	je     98e8 <_relocate+0x98>
	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
    9876:	48 8b 46 08          	mov    0x8(%rsi),%rax
    987a:	48 83 c6 10          	add    $0x10,%rsi
    987e:	48 85 c0             	test   %rax,%rax
    9881:	74 1c                	je     989f <_relocate+0x4f>
		switch (dyn[i].d_tag) {
    9883:	48 83 f8 08          	cmp    $0x8,%rax
    9887:	74 57                	je     98e0 <_relocate+0x90>
    9889:	48 83 f8 09          	cmp    $0x9,%rax
    988d:	75 e1                	jne    9870 <_relocate+0x20>
			case DT_RELASZ:
				relsz = dyn[i].d_un.d_val;
				break;

			case DT_RELAENT:
				relent = dyn[i].d_un.d_val;
    988f:	4c 8b 06             	mov    (%rsi),%r8
	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
    9892:	48 8b 46 08          	mov    0x8(%rsi),%rax
    9896:	48 83 c6 10          	add    $0x10,%rsi
    989a:	48 85 c0             	test   %rax,%rax
    989d:	75 e4                	jne    9883 <_relocate+0x33>
			default:
				break;
		}
	}

        if (!rel && relent == 0)
    989f:	48 89 d0             	mov    %rdx,%rax
    98a2:	4c 09 c0             	or     %r8,%rax
    98a5:	74 33                	je     98da <_relocate+0x8a>
                return EFI_SUCCESS;

	if (!rel || relent == 0)
    98a7:	48 85 d2             	test   %rdx,%rdx
    98aa:	74 44                	je     98f0 <_relocate+0xa0>
    98ac:	4d 85 c0             	test   %r8,%r8
    98af:	74 3f                	je     98f0 <_relocate+0xa0>
		return EFI_LOAD_ERROR;

	while (relsz > 0) {
    98b1:	48 85 c9             	test   %rcx,%rcx
    98b4:	7e 24                	jle    98da <_relocate+0x8a>
    98b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    98bd:	00 00 00 
		/* apply the relocs */
		switch (ELF64_R_TYPE (rel->r_info)) {
    98c0:	83 7a 08 08          	cmpl   $0x8,0x8(%rdx)
    98c4:	75 09                	jne    98cf <_relocate+0x7f>
			case R_X86_64_NONE:
				break;

			case R_X86_64_RELATIVE:
				addr = (unsigned long *)
					(ldbase + rel->r_offset);
    98c6:	48 8b 02             	mov    (%rdx),%rax
    98c9:	48 01 f8             	add    %rdi,%rax
				*addr += ldbase;
    98cc:	48 01 38             	add    %rdi,(%rax)

			default:
				break;
		}
		rel = (Elf64_Rel*) ((char *) rel + relent);
		relsz -= relent;
    98cf:	4c 29 c1             	sub    %r8,%rcx
		rel = (Elf64_Rel*) ((char *) rel + relent);
    98d2:	4c 01 c2             	add    %r8,%rdx
	while (relsz > 0) {
    98d5:	48 85 c9             	test   %rcx,%rcx
    98d8:	7f e6                	jg     98c0 <_relocate+0x70>
                return EFI_SUCCESS;
    98da:	31 c0                	xor    %eax,%eax
    98dc:	c3                   	ret    
    98dd:	0f 1f 00             	nopl   (%rax)
				relsz = dyn[i].d_un.d_val;
    98e0:	48 8b 0e             	mov    (%rsi),%rcx
				break;
    98e3:	eb 91                	jmp    9876 <_relocate+0x26>
    98e5:	0f 1f 00             	nopl   (%rax)
					 + ldbase);
    98e8:	48 8b 16             	mov    (%rsi),%rdx
    98eb:	48 01 fa             	add    %rdi,%rdx
				break;
    98ee:	eb 86                	jmp    9876 <_relocate+0x26>
		return EFI_LOAD_ERROR;
    98f0:	48 b8 01 00 00 00 00 	movabs $0x8000000000000001,%rax
    98f7:	00 00 80 
	}
	return EFI_SUCCESS;
}
    98fa:	c3                   	ret    
    98fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
